<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Linux系统实践问题记录</title>
      <link href="/2020/02/28/Linux%E7%B3%BB%E7%BB%9F%E5%AE%9E%E8%B7%B5%E9%97%AE%E9%A2%98/"/>
      <url>/2020/02/28/Linux%E7%B3%BB%E7%BB%9F%E5%AE%9E%E8%B7%B5%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<ol><li><p>记录一次在Linux（Ubuntu）中date命令无效的情况</p><p> 解决方案参考<a href="http://blog.sina.cn/dpool/blog/s/blog_413d250e0102z2iy.html" target="_blank" rel="noopener">http://blog.sina.cn/dpool/blog/s/blog_413d250e0102z2iy.html</a></p><pre><code>1、sudo timedatectl set-ntp false2、sudo date -s &apos;2020-2-20 12:12:12&apos;此时通过命令查看时间的话，就可以发现日期修改成功了，而如果需要将时间同步回去，直接执行 sudo timedatectl set-ntp true即可。</code></pre><p>更改时区：tzselect命令</p><p>参考：<a href="https://blog.csdn.net/zhengchaooo/article/details/79500032" target="_blank" rel="noopener">https://blog.csdn.net/zhengchaooo/article/details/79500032</a></p></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>shell 通配符和正则表达式</title>
      <link href="/2020/02/06/shell-%E9%80%9A%E9%85%8D%E7%AC%A6%E5%92%8C%E6%AD%A3%E5%88%99/"/>
      <url>/2020/02/06/shell-%E9%80%9A%E9%85%8D%E7%AC%A6%E5%92%8C%E6%AD%A3%E5%88%99/</url>
      
        <content type="html"><![CDATA[<h5 id="通配符和正则"><a href="#通配符和正则" class="headerlink" title="通配符和正则"></a>通配符和正则</h5><ul><li><p>shell 元字符(也称为通配符) 由 shell 来解析，如 rm -rf <em>.pdf，元字符</em> Shell 将其解析为任意 多个字符</p><p>正则表达式元字符 由各种执行模式匹配操作的程序来解析，比如 vi、grep、sed、awk、python</p></li><li><p>shell中定义元字符</p><pre><code>*   任意字符?  单个任意字符[] 子shell ，不会影响主shell[^abcd]这里^是非的意思，但是外面不支持，不同与正则。正则[]里面同此，外面使用是以什么开头的意思{} 集合</code></pre></li></ul><ul><li><p>基本正则表达式元字符:</p><pre><code>元字符 功能 示例 ======================================================== ^ 行首定位符 ^love$ 行尾定位符 love$. 匹配单个任意字符 l..e* 匹配前导符 0 到多次 ab*love.* 任意多个字符[] 匹配指定范围内的一个字符 [lL]ove[ - ] 匹配指定范围内的一个字符 [a-z0-9]ove[^] 匹配不在指定组内的字符 [^a-z0-9]ove\ 用来转义元字符 love\.\&lt; 词首定位符 \&lt;love\&gt; 词尾定位符 love\&gt;\(..\) 匹配稍后使用的字符的标签 :% s/172.16.130.1/172.16.130.5/ :% s/\(172.16.130.\)1/\15/:% s/\(172.\)\(16.\)\(130.\)1/\1\2\35/:3,9 s/\(.*\)/#\1/x\{m\} 字符 x 重复出现 m 次 o\{5\}x\{m,\} 字符 x 重复出现 m 次以上 o\{5,\} x\{m,n\} 字符x重复出现m到n次o\{5,10\}</code></pre></li><li><p>扩展正则表达式元字符（egrep或使用转义\）</p><pre><code>+ 匹配一个或多个前导字符 [a-z]+ove? 匹配零个或一个前导字符 lo?vea|b 匹配 a 或 b love|hate() 组字符 loveable|rs love(able|rs) ov+ (ov)+ (..)(..)\1\2 标签匹配字符 (love)able\1er x{m} 字符x重复m次o{5}x{m,} 字符 x 重复至少 m 次 o{5,}x{m,n} 字符x重复m到n次o{5,10}</code></pre></li><li><p>其他</p><pre><code>\w  所有字母和数字 相当于[a-zA-Z0-9]*\W  非字母和数字\b  边界</code></pre></li></ul><h5 id="grep命令"><a href="#grep命令" class="headerlink" title="grep命令"></a>grep命令</h5><ul><li><p>习惯性加上单引号</p></li><li><p>返回状态exit 0 1 2</p></li><li><p>grep -e  相当于 egrep </p></li><li><p>grep  –help |grep ‘-v’<br>其中-v被认为是选项，非模式，所以需要转义</p></li></ul><pre><code>-i, --ignore-case         忽略大小写-v, --invert-match        选中不匹配的行-q, --quiet, --silent     不显示所有常规输出-r, --recursive           等同于--directories=recurse递归目录-o, --only-matching       只显示匹配PATTERN 部分的行-B, --before-context=NUM  打印文本及其前面NUM 行-A, --after-context=NUM   打印文本及其后面NUM 行-C, --context=NUM         打印NUM 行输出文本-n, --line-number         输出的同时打印行号</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>shell 变量和数组</title>
      <link href="/2020/02/06/shell-%E5%8F%98%E9%87%8F%E5%92%8C%E6%95%B0%E7%BB%84/"/>
      <url>/2020/02/06/shell-%E5%8F%98%E9%87%8F%E5%92%8C%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<h4 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h4><ul><li><p>查看变量: echo $变量名 set(所有变量:包括自定义变量和环境变量) </p></li><li><p>取消变量: unset 变量名</p></li><li><p>位置变量：如通过$1 $2获取第一第二个参数</p></li><li><p>环境变量：export back_dir=xxxx  定义全局变量；或者export $var 转化成全局变量</p></li><li><p>预定义变量</p><pre><code>$0 脚本名$* 所有的参数$@ 所有的参数$# 参数的个数$$ 当前进程的 PID$! 上一个后台进程的 PID$? 上一个命令的返回值 0 表示成功</code></pre><p>$@和$星区别：不加引号时,二者都是返回传入的参数,但加了引号后（”$@”）,此时$*把参数作为一个字符串整体(单字符串)返回,$@把每个参数作为一个字符串返回</p></li><li><p>键盘输入变量：通过read -n 2 -p “please input: “ p</p></li></ul><ul><li><p>调用其他脚本变量值：可在b脚本中通过调用.a.sh,直接获取a的变量数据</p></li><li><p>“”双引号-强引用会替换里面变量值；’’-弱引用，原样输出引用符号</p></li><li><p>变量删除（获取部分字符串）</p><pre><code>${url#*a}  从头到尾最短匹配删除即直到第一个a之前的都删除${url##*a}  从头到尾贪婪匹配，删除直到最后一个匹配a${url%a*}  后面加%，从后到前最短匹配删除a后面所有字符    ${url%%}  后面加%，从后到前贪婪匹配删除最后一个a后面所有字符</code></pre></li><li><p>变量替换(最短替换/和贪婪替换//)</p><pre><code>liyuan$ var=tom.ton.comliyuan$ echo ${var/to/TO}TOm.ton.comliyuan$ echo ${var//to/TO}</code></pre></li></ul><ul><li><p>变量替代；可理解为变量初始化</p><pre><code>echo ${var1-aaaaa}echo ${var1:-aaaaa}</code></pre><p>  使用 <font color="red">-</font> ,若没有被赋值过，就使用默认值替代(是否unset)</p><p>  使用 <font color="red">:-</font>，区别在于即使赋值空值也会被新值替代(是否为空值)</p></li><li><p>切片操作  echo ${url:5:7}</p></li><li><p>可使用反引号或者$()执行内部命令</p></li><li><p>date +%F  格式化日期输出</p></li><li><p>特殊符号总结</p><pre><code>（） 子shell执行(()) 数值比较$()  命令替换，同反引号$(()) 整数运算{}  集合${}  变量[]  条件测试[[]] 条件测试，支持正则 =~$[]  整数运算</code></pre></li></ul><h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><ol><li><p>普通数组</p><pre><code>一次赋多值，可指定索引# array2=(tom jack alice [20]=aa)# echo ${!array2[@]}0 1 2 20</code></pre></li><li><p>关联数组</p><p> 必须申明关联数组变量</p><pre><code># declare -A ass_array1# ass_array2=([index1]=tom [index2]=jack [index4]=&apos;bash shell&apos;)查看数组# declare -A</code></pre></li><li><p>访问数组元数:</p><pre><code># echo ${ass_array2[index2]} 访问数组中的第二个元数# echo ${ass_array2[@]} 访问数组中所有元数 等同于 echo ${array1[*]} # echo ${#ass_array2[@]} 获得数组元数的个数# echo ${!ass_array2[@]} 获得数组元数的索引</code></pre></li><li><p>遍历数组</p><p>通过获取数组索引遍历   </p></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>shell 函数</title>
      <link href="/2020/02/06/shell-%E5%87%BD%E6%95%B0/"/>
      <url>/2020/02/06/shell-%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h5 id="1-定义函数"><a href="#1-定义函数" class="headerlink" title="1. 定义函数"></a>1. 定义函数</h5><h6 id="方法一（常用）"><a href="#方法一（常用）" class="headerlink" title="方法一（常用）:"></a>方法一（常用）:</h6><pre><code>函数名() { 函数要实现的功能代码 }</code></pre><h6 id="方法二"><a href="#方法二" class="headerlink" title="方法二:"></a>方法二:</h6><pre><code>function 函数名 { 函数要实现的功能代码 }</code></pre><h5 id="调用函数"><a href="#调用函数" class="headerlink" title="调用函数"></a>调用函数</h5><pre><code>函数名 函数名参数1 参数2</code></pre><p>举例：</p><pre><code>#!/usr/bin/bashjiecheng(){result=1for i in `seq $1`do        echo $i        result=$[$result*$i]doneecho $result}jiecheng $11.实践证明，do中的result必须不能加$符号，否则错误2.$[]运算结果赋值的时候，=左右不能有空格</code></pre><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul><li><p>函数接收位置参数 $1 $2… $n</p></li><li><p>函数接收数组变量使用$@ $*</p></li><li><p>函数接收参数个数$#</p></li><li><p>函数将受到的所有参数赋值给数组 newarray=($*)</p></li><li><p>养成在函数内部的变量习惯性加local关键字供内部函数使用的习惯</p></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>shell 条件测试</title>
      <link href="/2020/02/06/shell-%E6%9D%A1%E4%BB%B6%E6%B5%8B%E8%AF%95/"/>
      <url>/2020/02/06/shell-%E6%9D%A1%E4%BB%B6%E6%B5%8B%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<p>Shell 条件测试</p><pre><code>格式 1: test 条件表达式 格式 2: [ 条件表达式 ] 格式 3: [[ 条件表达式 ]]</code></pre><ol><li><p>文件测试</p><pre><code>test -d /home[ -e dir|file ]  True if file exists (regardless of type)[ -d dir ] True if file exists and is a directory.[ -f file ] True if file exists and is a regular file.[ -d /ccc ] || mkdir /ccc</code></pre></li><li><p>数值比较 </p><pre><code>[ 整数1  操作符  整数2] [ 1 -gt 10 ] 大于[ 1 -eq 10 ] 等于</code></pre></li><li><p>数值比较–C语言风格 </p><pre><code>[root@xxxx ~]# ((1&lt;2));echo $?0[root@xxxx ~]# ((1==2));echo $?</code></pre></li><li><p>字符串比较</p><pre><code>等号[root@xxxx ~]# [ &quot;$USER&quot; = &quot;root&quot; ];echo $?[root@xxxx ~]# [ -z &quot;$var1&quot; ];echo $?条件判断[root@xxxx ~]# [ 1 -lt 2 -a 5 -gt 10 ];echo $?[root@xxxx ~]# [ 1 -lt 2 -o 5 -gt 10 ];echo $?使用正则    [root@yangs ~]# [[ &quot;$num10&quot; =~ ^[0-9]+$ ]];echo $?</code></pre><p> 【注】:变量为空 或 未定义: 长度都为 0</p></li><li><p>eq  ge等用于数字比较</p><p>= &gt;等都是字符串比较    </p><p> 字符串比较一般要加双引号</p></li><li><p>在shell脚本里，推荐按以下方式声明和使用布尔类型。</p><pre><code>bool=trueif [ &quot;$bool&quot; = true ]; thenif [ &quot;$bool&quot; = &quot;true&quot; ]; thenif [[ &quot;$bool&quot; = true ]]; thenif [[ &quot;$bool&quot; = &quot;true&quot; ]]; thenif [[ &quot;$bool&quot; == true ]]; thenif [[ &quot;$bool&quot; == &quot;true&quot; ]]; thenif test &quot;$bool&quot; = true; thenif test &quot;$bool&quot; = &quot;true&quot;; then</code></pre></li></ol><ol start="7"><li><p>实例 判断bool变量不存在或者为false</p><pre><code>if [ ${#usePFB} -eq 0 -o &quot;$usePFB&quot; = &quot;false&quot; ]</code></pre></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Go语言</title>
      <link href="/2020/02/03/Go%E8%AF%AD%E8%A8%80/"/>
      <url>/2020/02/03/Go%E8%AF%AD%E8%A8%80/</url>
      
        <content type="html"><![CDATA[<h4 id="IDE"><a href="#IDE" class="headerlink" title="IDE"></a>IDE</h4><p>官网下载atom，并安装go-plus插件</p><h4 id="运行程序"><a href="#运行程序" class="headerlink" title="运行程序"></a>运行程序</h4><pre><code>go run hello.go或者$ go build hello.go $ lshello    hello.go$ ./hello</code></pre><h4 id="特点-与其他语言差别"><a href="#特点-与其他语言差别" class="headerlink" title="特点:与其他语言差别"></a>特点:与其他语言差别</h4><ul><li><p>应用程序入口</p><ol><li>必须是 main 包：package main</li><li>必须是 main ⽅法：func main()</li><li>⽂件名不⼀定是 main.go</li></ol></li><li><p>Go 中 main 函数不⽀持任何返回值<br>通过 os.Exit 来返回状态</p></li><li><p>main 函数不⽀持传⼊参数 func main(arg []string) 是错误的<br>在程序中直接通过 os.Args 获取命令⾏参数 </p></li><li><p>编写测试程序</p><ol><li>源码⽂件以 _test 结尾：xxx_test.go</li><li>测试⽅法名以 Test 开头：func TestXXX(t *testing.T){}</li></ol><p>运行测试程序：</p><p>1）Atom-&gt;preferences-&gt;packages<br>搜索找到go-plus<br>在settings中，Test配置中选中 Run with verbose flag setting<br>2）若不好用，可以用修改快捷键绑定keymap.cson文件,先执行保存再使用快捷键运行</p></li><li><p>不支持隐式类型转换，如Int和Int64。别名和原有类型也不能进⾏隐式类型转换</p></li><li><p>不支持指针运算</p></li><li><p>运算符之后后置++和–</p></li><li><p>&amp;^ 运算符：只要后面是1，结果变成0，否则为左边值即不变</p><p>   1 &amp;^ 0 – 1<br>   1 &amp;^ 1 – 0<br>   0 &amp;^ 1 – 0<br>   0 &amp;^ 0 – 0</p></li><li><p>string 是值类型，其默认的初始化值为空字符串，⽽不是 nil</p></li><li><p>Go 语⾔仅⽀持循环关键字 for</p></li><li><p>条件语句</p><ol><li>condition 表达式结果必须为布尔值</li><li>⽀持变量赋值：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if  var declaration;  condition &#123;</span><br><span class="line">    // code to be executed if condition is true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li><li><p>switch条件</p><ol><li>条件表达式不限制为常量或者整数；</li><li>单个 case 中，可以出现多个结果选项, 使⽤逗号分隔；</li><li>Go 语⾔不需要⽤break来明确退出⼀个 case；</li><li>可以不设定 switch 之后的条件表达式，在此种情况下，整个 switch 结构与多个 if…else… 的逻辑作⽤等同</li></ol></li></ul><h5 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h5><ul><li>数组的声明<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var a [3] int //声明并初始化为默认零值</span><br><span class="line">a[0] = 1</span><br><span class="line">b := [3]int&#123;1, 2, 3&#125; //声明同时初始化</span><br></pre></td></tr></table></figure></li></ul><ul><li>数组元素遍历</li></ul><pre><code>func TestTravelArray(t *testing.T) { a := [...]int{1, 2, 3, 4, 5} //不指定元素个数 for idx/*索引*/, elem/*元素*/ := range a { fmt.Println(idx, elem) }</code></pre><ul><li><p>数组截取</p><pre><code>a := [...]int{1, 2, 3, 4, 5}a[1:2] //2a[1:3] //2,3a[1:len(a)] //2,3,4,5a[1:] //2,3,4,5a[:3] //1,2,3</code></pre><p>  负数索引？不支持</p></li></ul><h5 id="Go-语言切片-Slice"><a href="#Go-语言切片-Slice" class="headerlink" title="Go 语言切片(Slice)"></a>Go 语言切片(Slice)</h5><p>Go 语言切片是对数组的抽象。</p><p>Go 数组的长度不可改变，在特定场景中这样的集合就不太适用，Go中提供了一种灵活，功能强悍的内置类型切片(“动态数组”),与数组相比切片的长度是不固定的，可以追加元素，在追加时可能使切片的容量增大。 </p><ul><li><p>初始化同数组，缺少长度 </p></li><li><p>数组可以比较，切片不可比较</p><p>切⽚声明</p><pre><code> var s0 []int s0 = append(s0, 1) s := []int{} s1 := []int{1, 2, 3} s2 := make([]int, 2, 4)  make参数/*[]type, len, cap其中len个元素会被初始化为默认零值，未初始化元素不可以访问*/</code></pre></li><li><p>len() cap()  make()</p><p>append() 和 copy() 函数</p></li></ul><h5 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h5><ul><li><p>Map 声明</p><p>  声明变量，默认 map 是 nil</p><pre><code>var map_variable map[key_data_type]value_data_type</code></pre><p>  使用 make 函数</p><pre><code>map_variable := make(map[key_data_type]value_data_type)</code></pre><p>  举例：</p><pre><code>m := map[string]int{&quot;one&quot;: 1, &quot;two&quot;: 2, &quot;three&quot;: 3}m1 := map[string]int{}m1[&quot;one&quot;] = 1m2 := make(map[string]int, 10 /*Initial Capacity*/)</code></pre></li><li><p>在访问的 Key 不存在时，仍会返回零值，不能通过返回 nil 来判断元素是否存在</p></li><li><p>Mapi遍历</p><pre><code>m := map[string]int{&quot;one&quot;: 1}for k, v := range m {    t.Log(k, v)}</code></pre></li><li><p>Mapi delete()函数</p></li><li><p>Go 的内置集合中没有 Set 实现， 可以 map[type]bool</p></li></ul><h5 id="字符串与字符编码"><a href="#字符串与字符编码" class="headerlink" title="字符串与字符编码"></a>字符串与字符编码</h5><p>字符串是只读不可变的byte slice</p><p>len()函数得出的是byte的长度而未必是字符长度。</p><p>rune()函数:得到unicode编码</p><p>常用的函数包：strings strconv<br>如：split join Atoi  itoA</p><h5 id="变量声明"><a href="#变量声明" class="headerlink" title="变量声明"></a>变量声明</h5><p>可单独声明，也可以一次声明多个变量：如</p><pre><code>var a string = &quot;Runoob&quot;var b, c int = 1, 2</code></pre><ul><li><p>若没有初始化系统默认为0或者False或者”“</p></li><li><p>也可是不指定类型，系统自动识别</p></li><li><p>使用因式分解关键字写法</p><pre><code>var (  // 这种因式分解关键字的写法一般用于声明全局变量  a int  b bool  )</code></pre></li><li><p>也可是省略var,使用:=来声明新变量</p><pre><code>vname1, vname2, vname3 := v1, v2, v3</code></pre></li></ul><h5 id="常量：iota"><a href="#常量：iota" class="headerlink" title="常量：iota"></a>常量：iota</h5><p> iota 在 const关键字出现时将被重置为 0(const 内部的第一行之前)，const 中每<font color="red">新增一行</font>常量声明将使 iota 计数一次</p><pre><code>package mainimport &quot;fmt&quot;func main() {    const (            a = iota   //0            b          //1            c          //2            d = &quot;ha&quot;   //独立值，iota += 1            e          //&quot;ha&quot;   iota += 1            f = 100    //iota +=1            g          //100  iota +=1            h = iota   //7,恢复计数            i          //8    )    fmt.Println(a,b,c,d,e,f,g,h,i)}</code></pre><h6 id="记录"><a href="#记录" class="headerlink" title="记录"></a>记录</h6><pre><code>t.Logf(&quot;%T&quot;, aP)</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Python-GIL&amp;进程线程</title>
      <link href="/2020/02/03/python-GIL/"/>
      <url>/2020/02/03/python-GIL/</url>
      
        <content type="html"><![CDATA[<h5 id="GIL-全局解释器锁"><a href="#GIL-全局解释器锁" class="headerlink" title="GIL 全局解释器锁"></a>GIL 全局解释器锁</h5><p>GIL本质就是一把互斥锁，既然是互斥锁，所有互斥锁的本质都一样，都是将并发运行变成串行，以此来控制同一时间内共享数据只能被一个任务所修改，进而保证数据安全。</p><h6 id="实例："><a href="#实例：" class="headerlink" title="实例："></a>实例：</h6><p>  使用死循环程序while True:pass</p><p>  双核CPU:可用htop实时查看进程占用情况</p><ul><li>单进程单线程执行1个线程   CPU1占满100%</li><li>单进程多线程执行两个线程   各占用50%（加起来是一个核）</li><li>使用多进程执行两个进程   各占满100%（每个进程真正占满一个核）</li></ul><h6 id="结论：python中多线程是假的。只有多进程能实现并发，每个进程占用一个CPU。"><a href="#结论：python中多线程是假的。只有多进程能实现并发，每个进程占用一个CPU。" class="headerlink" title="结论：python中多线程是假的。只有多进程能实现并发，每个进程占用一个CPU。"></a>结论：<font color="red">python中多线程是假的。只有多进程能实现并发</font>，每个进程占用一个CPU。</h6><h6 id="原因：GIL：使得多线程程序一个时刻只能有一个线程在使用。"><a href="#原因：GIL：使得多线程程序一个时刻只能有一个线程在使用。" class="headerlink" title="原因：GIL：使得多线程程序一个时刻只能有一个线程在使用。"></a>原因：<font color="red">GIL</font>：使得多线程程序一个时刻只能有一个线程在使用。</h6><p>为什么python有这个问题？</p><pre><code>实际不是python本身的问题，而是由于其解释器的限制：Python默认使用C-python解释器（其他版本比如Java版的python解释器就不会有这个问题,但是这个GIL问题不容易解决所以至今依旧如此）</code></pre><p>所以python可使用多进程来实现多任务并发，替代多线程实现。</p><h5 id="多线程是否要比单线程快？"><a href="#多线程是否要比单线程快？" class="headerlink" title="多线程是否要比单线程快？"></a>多线程是否要比单线程快？</h5><p>回答：是的。因为多线程会在适当的实际执行必要的操作，避免等待造成的时间消耗。增加效率。</p><h5 id="什么时候用进程什么时候用线程？"><a href="#什么时候用进程什么时候用线程？" class="headerlink" title="什么时候用进程什么时候用线程？"></a>什么时候用进程什么时候用线程？</h5><ul><li><p>计算密集型程序：进程（可以发挥多核cpu的作用）</p></li><li><p>io密集型程序：线程、协程（可以充分利用等待时间）</p></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>RT中的chrome设置</title>
      <link href="/2020/02/02/RT%E4%B8%AD%E7%9A%84chrome%E8%AE%BE%E7%BD%AE/"/>
      <url>/2020/02/02/RT%E4%B8%AD%E7%9A%84chrome%E8%AE%BE%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h5 id="jenkins在执行远程docker-chrome-hub运行RT时候报错："><a href="#jenkins在执行远程docker-chrome-hub运行RT时候报错：" class="headerlink" title="jenkins在执行远程docker chrome hub运行RT时候报错："></a>jenkins在执行远程docker chrome hub运行RT时候报错：</h5><pre><code>selenium.common.exceptions.WebDriverException: Message: unknown error: session deleted because of page crashfrom unknown error: cannot determine loading statusfrom tab crashed</code></pre><ul><li>解决方法一</li></ul><p>一个解决办法就是要添加chrome参数Add the following chrome_options:</p><pre><code>chrome_options.add_argument(&apos;--no-sandbox&apos;)   </code></pre><p>参考：<a href="https://stackoverflow.com/questions/53902507/unknown-error-session-deleted-because-of-page-crash-from-unknown-error-cannot" target="_blank" rel="noopener">https://stackoverflow.com/questions/53902507/unknown-error-session-deleted-because-of-page-crash-from-unknown-error-cannot</a></p><h6 id="那么这些参数都有哪些意义呢？"><a href="#那么这些参数都有哪些意义呢？" class="headerlink" title="那么这些参数都有哪些意义呢？"></a>那么这些参数都有哪些意义呢？</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">from selenium import webdriver</span><br><span class="line">from selenium.webdriver.chrome.options import Options</span><br><span class="line">chrome_options = Options()</span><br><span class="line">chrome_options.add_argument(&apos;--no-sandbox&apos;)#停止使用沙箱模式（沙箱模式就是一个封闭的独立的环境。）,也可解决DevToolsActivePort文件不存在的报错</span><br><span class="line">chrome_options.add_argument(&apos;window-size=1920x3000&apos;) #指定浏览器分辨率</span><br><span class="line">chrome_options.add_argument(&apos;--disable-gpu&apos;) #谷歌文档提到需要加上这个属性来规避bug</span><br><span class="line">chrome_options.add_argument(&apos;--hide-scrollbars&apos;) #隐藏滚动条, 应对一些特殊页面</span><br><span class="line">chrome_options.add_argument(&apos;blink-settings=imagesEnabled=false&apos;) #不加载图片, 提升速度</span><br><span class="line">chrome_options.add_argument(&apos;--headless&apos;) #浏览器不提供可视化页面. linux下如果系统不支持可视化不加这条会启动失败</span><br><span class="line">chrome_options.binary_location = r&quot;C:\Program Files (x86)\Google\Chrome\Application\chrome.exe&quot; #手动指定使用的浏览器位置</span><br><span class="line"></span><br><span class="line">driver=webdriver.Chrome(chrome_options=chrome_options)</span><br><span class="line">driver.get(&apos;https://www.baidu.com&apos;)</span><br><span class="line"></span><br><span class="line">print(&apos;hao123&apos; in driver.page_source)</span><br><span class="line">driver.close() #切记关闭浏览器，回收资源</span><br></pre></td></tr></table></figure><h6 id="如何在RT中应用？"><a href="#如何在RT中应用？" class="headerlink" title="如何在RT中应用？"></a>如何在RT中应用？</h6><p>RT中添加需要转化成capabilities这样才可在使用远程driver的时候应用。</p><p>参考大神:<a href="https://stackoverflow.com/questions/46812155/how-to-run-headless-remote-chrome-using-robot-framework/46817149" target="_blank" rel="noopener">https://stackoverflow.com/questions/46812155/how-to-run-headless-remote-chrome-using-robot-framework/46817149</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Headless Chrome - Open Browser</span><br><span class="line">    $&#123;chrome_options&#125; =     Evaluate    sys.modules[&apos;selenium.webdriver&apos;].ChromeOptions()    sys, selenium.webdriver</span><br><span class="line">    Call Method    $&#123;chrome_options&#125;   add_argument    headless</span><br><span class="line">    Call Method    $&#123;chrome_options&#125;   add_argument    disable-gpu</span><br><span class="line">    $&#123;options&#125;=     Call Method     $&#123;chrome_options&#125;    to_capabilities     </span><br><span class="line"></span><br><span class="line">    Open Browser    http://cnn.com    browser=chrome    remote_url=http://localhost:4444/wd/hub     desired_capabilities=$&#123;options&#125;</span><br><span class="line"></span><br><span class="line">    Maximize Browser Window</span><br><span class="line">    Capture Page Screenshot</span><br></pre></td></tr></table></figure><p>解决方法二：方法一并没有有效的解决问题，以下贴出完整的问题log</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">[ WARN ] Keyword &apos;Capture Page Screenshot&apos; could not be run on failure: WebDriverException: Message: Session [0c86405952403c3719bb6d9e8467b7f9] was terminated due to BROWSER_TIMEOUT</span><br><span class="line">Stacktrace:</span><br><span class="line">    at org.openqa.grid.internal.ActiveTestSessions.getExistingSession (ActiveTestSessions.java:115)</span><br><span class="line">    at org.openqa.grid.internal.DefaultGridRegistry.getExistingSession (DefaultGridRegistry.java:387)</span><br><span class="line">    at org.openqa.grid.web.servlet.handler.RequestHandler.getSession (RequestHandler.java:241)</span><br><span class="line">    at org.openqa.grid.web.servlet.handler.RequestHandler.process (RequestHandler.java:123)</span><br><span class="line">    at org.openqa.grid.web.servlet.DriverServlet.process (DriverServlet.java:85)</span><br><span class="line">    at org.openqa.grid.web.servlet.DriverServlet.doGet (DriverServlet.java:63)</span><br><span class="line">    at javax.servlet.http.HttpServlet.service (HttpServlet.java:687)</span><br><span class="line">    at javax.servlet.http.HttpServlet.service (HttpServlet.java:790)</span><br><span class="line">    at org.seleniumhq.jetty9.servlet.ServletHolder.handle (ServletHolder.java:865)</span><br><span class="line">    at org.seleniumhq.jetty9.servlet.ServletHandler.doHandle (ServletHandler.java:535)</span><br><span class="line">    [ Message content over the limit has been removed. ]</span><br><span class="line">    at org.seleniumhq.jetty9.io.AbstractConnection$ReadCallback.succeeded (AbstractConnection.java:305)</span><br><span class="line">    at org.seleniumhq.jetty9.io.FillInterest.fillable (FillInterest.java:103)</span><br><span class="line">    at org.seleniumhq.jetty9.io.ChannelEndPoint$2.run (ChannelEndPoint.java:118)</span><br><span class="line">    at org.seleniumhq.jetty9.util.thread.strategy.EatWhatYouKill.runTask (EatWhatYouKill.java:333)</span><br><span class="line">    at org.seleniumhq.jetty9.util.thread.strategy.EatWhatYouKill.doProduce (EatWhatYouKill.java:310)</span><br><span class="line">    at org.seleniumhq.jetty9.util.thread.strategy.EatWhatYouKill.tryProduce (EatWhatYouKill.java:168)</span><br><span class="line">    at org.seleniumhq.jetty9.util.thread.strategy.EatWhatYouKill.run (EatWhatYouKill.java:126)</span><br><span class="line">    at org.seleniumhq.jetty9.util.thread.ReservedThreadExecutor$ReservedThread.run (ReservedThreadExecutor.java:366)</span><br><span class="line">    at org.seleniumhq.jetty9.util.thread.QueuedThreadPool.runJob (QueuedThreadPool.java:765)</span><br><span class="line">    at org.seleniumhq.jetty9.util.thread.QueuedThreadPool$2.run (QueuedThreadPool.java:683)</span><br><span class="line">    at java.lang.Thread.run (Thread.java:748)</span><br><span class="line">| FAIL |</span><br><span class="line">WebDriverException: Message: unknown error: session deleted because of page crash</span><br><span class="line">from unknown error: cannot determine loading status</span><br><span class="line">from tab crashed</span><br><span class="line">  (Session info: chrome=79.0.3945.79)</span><br></pre></td></tr></table></figure><p>解决方法：增加共享内存<br>虽然通过df -h 可以看到/dev/shm有7个多G的空间，但是容器默认配置共享空间是64M：”default-shm-size”: “64M”,使用docker for python 可以通过添加–shm-size参数来修改,官方参数说明</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shm_size (str or int) – Size of /dev/shm (e.g. 1G).</span><br></pre></td></tr></table></figure><p>参考<br><a href="https://github.com/elgalu/docker-selenium/issues/20" target="_blank" rel="noopener">https://github.com/elgalu/docker-selenium/issues/20</a><br><a href="https://www.zhihu.com/question/40125229?sort=created" target="_blank" rel="noopener">https://www.zhihu.com/question/40125229?sort=created</a><br><a href="https://blog.csdn.net/isea533/article/details/95197468" target="_blank" rel="noopener">https://blog.csdn.net/isea533/article/details/95197468</a><br><a href="https://www.cnblogs.com/FZfangzheng/p/10851762.html" target="_blank" rel="noopener">https://www.cnblogs.com/FZfangzheng/p/10851762.html</a><br><a href="https://docker-py.readthedocs.io/en/stable/containers.html" target="_blank" rel="noopener">https://docker-py.readthedocs.io/en/stable/containers.html</a></p><p>Finally:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">client.containers.run(&apos;selenium/hub&apos;, name=hub_name, detach=True, tty=True, stdin_open=True,publish_all_ports=True,shm_size=&apos;1G&apos;)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>RT运行命令</title>
      <link href="/2020/02/01/RT%E8%BF%90%E8%A1%8C%E5%91%BD%E4%BB%A4/"/>
      <url>/2020/02/01/RT%E8%BF%90%E8%A1%8C%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h5 id="robot命令"><a href="#robot命令" class="headerlink" title="robot命令"></a>robot命令</h5><p>使用1：运行程序并生成报告</p><pre><code>robot -d Output --loglevel TRACE -v env:$env -v HUB:$hub -i $area SellerCenterUI/TestCase/06Wallet/</code></pre><p>使用2：重新运行失败的case</p><pre><code>robot -d Output --rerunfailed Output/output.xml --output rerun.xml --loglevel TRACE -v env:$env -v HUB:$hub  -i $area SellerCenterUI/TestCase/01Login/</code></pre><p>据robot –help可知</p><pre><code>-d  --outputdir dir       Where to create output files. The default is the directory where tests are run from and the given path   is considered relative to that unless it is absolute.即指定生成报告的文件-L --loglevel level      Threshold level for logging. Available levels: TRACE,DEBUG, INFO (default), WARN, NONE (no logging). -i --include tag *  -v --variable name:value *      Set variables in the test data. Only scalar variables with string value are supported and name is given without `${}`.  -R --rerunfailed output       Select failed tests from an earlier output file</code></pre><h5 id="rebot命令"><a href="#rebot命令" class="headerlink" title="rebot命令"></a>rebot命令</h5><p>使用：合并报告</p><pre><code>/usr/local/python3/bin/rebot -d Output --output output.xml --merge Output/output.xml Output/rerun.xml</code></pre><p>   使用rebot –help可知</p><pre><code>-o --output file         XML output file. Not created unless this option is specified. Given path, similarly as paths given to --log, --report and --xunit, is relative to --outputdir unless given as an absolute path.-R --merge               When combining results, merge outputs together Example: rebot --merge orig.xml rerun.xml</code></pre><p>  最终根据xml文件生成Log和Report文件（个人理解）</p><pre><code>Output:  /var/lib/jenkins/workspace/Staging/login for th/Output/output.xmlLog:     /var/lib/jenkins/workspace/Staging/login for th/Output/log.htmlReport:  /var/lib/jenkins/workspace/Staging/login for th/Output/report.html</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Selenium&amp;Docker使用</title>
      <link href="/2020/01/31/Selenium%E4%B8%8BDocker%E4%BD%BF%E7%94%A8/"/>
      <url>/2020/01/31/Selenium%E4%B8%8BDocker%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h4 id="Docker-API"><a href="#Docker-API" class="headerlink" title="Docker  API"></a>Docker  API</h4><p>原文：<a href="https://www.missshi.cn/api/view/blog/5a63285f0a745f6335000008" target="_blank" rel="noopener">https://www.missshi.cn/api/view/blog/5a63285f0a745f6335000008</a></p><p>在Docker的生态系统中，存在下列三种API：</p><ol><li><p>Reistry API：与存储Docker镜像的Registry相关的功能。</p></li><li><p>Docker Hub API：与Docker Hub相关的功能</p></li><li><p>** Docker Remote API：与Docker守护进程相关的功能**</p></li></ol><h4 id="Docker-Remote-API"><a href="#Docker-Remote-API" class="headerlink" title="Docker Remote API"></a>Docker Remote API</h4><p>  以下可以得到类似的docker info时的JSON格式的数据</p><pre><code>curl http://10.129.144.66:2375/info</code></pre><p>  调用/images/json接口可以获取<strong>镜像</strong>列表：</p><pre><code>curl http://example.com:2375/images/json | python -mjson.tool</code></pre><p>  调用/containers/json接口可以获取正在运行中的<strong>容器</strong>列表：</p><pre><code>curl http://example.com:2375/containers/json | python -mjson.tool</code></pre><p>  其中python -mjson.tool可以将JSON数据格式化显示。</p><h4 id="Python调用Docker-API"><a href="#Python调用Docker-API" class="headerlink" title="Python调用Docker API"></a>Python调用Docker API</h4><p>对于原生Docker Remote API而言，虽然功能很强大，但是使用起来并不是十分的方便。</p><p>为了简化Docker Remote API的使用，Python针对Docker API进行了封装，提供了一套完整的Python第三方库：docker，专门用于操作调用Docker服务。</p><p>可通过pip安装</p><pre><code>pip install docker</code></pre><p>创建一个docker_api.py的文件，修改文件内容如下：</p><pre><code>import dockerclient = docker.DockerClient(base_url=&apos;tcp://example.com:2375&apos;, version=&quot;auto&quot;)client.containers.run(&quot;ubuntu&quot;, &quot;echo hello world&quot;)</code></pre><p>client.containers.run相当于docker run，参数ports字典类型，端口映射 {8000: 80}表示容器的8000端口映射到宿主机的80端口</p><p>对于client.containers.run的函数的返回值，当detach=False时，返回值是运行过程中的日志，而当detach=True时，返回值是<strong>Container对象</strong>。</p><h4 id="Selenium-Grid"><a href="#Selenium-Grid" class="headerlink" title="Selenium Grid"></a>Selenium Grid</h4><p>本文参考 <a href="https://www.cnblogs.com/hellangels333/p/9749905.html" target="_blank" rel="noopener">https://www.cnblogs.com/hellangels333/p/9749905.html</a><br><a href="https://www.cnblogs.com/nanaheidebk/p/10109013.html" target="_blank" rel="noopener">https://www.cnblogs.com/nanaheidebk/p/10109013.html</a></p><p>具体可看原文，原文更加详细，以下为部分摘录：</p><p>这里主要针对的是 Selenium Grid，它用于分布式自动化测试，就是一套Selenium 代码可在不同的环境上运行。刚好，Docker可快速的创建各种环境。</p><h6 id="Selenium-Grid-有两个概念"><a href="#Selenium-Grid-有两个概念" class="headerlink" title="Selenium Grid 有两个概念"></a>Selenium Grid 有两个概念</h6><ul><li><p>hub ：主节点，你可以看作 “北京总公司的测试经理”。</p></li><li><p>node：分支节点，你可以看作 “北京总公司的测试小兵A” 和 “上海分公司的测试小兵B”，还有 “深圳分公司的测试小兵C” …。</p></li></ul><p>也就是说在Selenium Grid中只能有一个主hub，但可以在本地或远程建立 N 多个分支node，测试脚本指向主hub，由主hub 分配给本地/远程node 运行测试用例。</p><h6 id="docker-selenium-环境安装"><a href="#docker-selenium-环境安装" class="headerlink" title="docker selenium 环境安装"></a>docker selenium 环境安装</h6><ol><li><p>下载主hub镜像（北京总公司的测试经理）</p><pre><code>$ sudo docker pull selenium/hub</code></pre></li><li><p>下载主node chrome 镜像（上海分公司的测试小兵B）</p><pre><code>$ sudo docker pull selenium/node-chrome</code></pre></li><li><p>启动主hub容器</p><pre><code>$ sudo docker run -d -P --name selenium-hub selenium/hub</code></pre><p>-P 表示 Docker 会随机映射一个 49000~49900 的端口到内部容器开放的网络端口。</p></li><li><p>启动分支node chrome 容器</p><pre><code>$ sudo docker run -d --link selenium-hub:hub selenium/node-chrome</code></pre><p> –link 通过 link 关联 selenium-hub 容器，并为其设置了别名hub</p></li><li><p>查看容器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">  LiyuanChendeMacBook-Pro:~ liyuanchen$ docker ps</span><br><span class="line">CONTAINER ID        IMAGE                  COMMAND                  CREATED             STATUS              PORTS                     NAMES</span><br><span class="line">e96d18013f73        selenium/node-chrome   &quot;/opt/bin/entry_poin…&quot;   4 seconds ago       Up 3 seconds                                  eager_sammet</span><br><span class="line">b9449483ccb5        selenium/hub           &quot;/opt/bin/entry_poin…&quot;   2 minutes ago       Up 2 minutes        0.0.0.0:32768-&gt;4444/tcp   selenium-hub                             eloquent_gates</span><br></pre></td></tr></table></figure><p> 这里需要注意，Selenium/hub 容器的端口号为 4444，对Ubuntu映射的端口为 32768，前面通过 -P 参数自动分配。</p><p> 工作原理：</p><p> <font color="red">selenium Grid脚本 -&gt; ubuntu(32768) -&gt; Hub容器(4444) -&gt; Node Chrome 容器</font></p><p> 最终得到可使用的hub链接是<a href="http://127.0.0.1:32768/wd/hub" target="_blank" rel="noopener">http://127.0.0.1:32768/wd/hub</a></p><h6 id="本地实践"><a href="#本地实践" class="headerlink" title="本地实践"></a>本地实践</h6><ol><li><p>启动主hub容器，获取端口号（按照如上命令）</p></li><li><p>启动分支node chrome 容器（按照如上命令）</p></li><li><p>使用HUB执行RT命令</p><pre><code>robot -d Output --loglevel TRACE -v env:staging -v area:sg  -v HUB:http://127.0.0.1:32769/wd/hub   -i all -i sg  SellerCenterUI/TestCase/03HomePage/</code></pre></li></ol><p>若改成使用 Remote API 启动容器呢？<br>待续</p></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>RT元素定位等问题</title>
      <link href="/2020/01/29/%E5%85%83%E7%B4%A0%E5%AE%9A%E4%BD%8D%E9%97%AE%E9%A2%98/"/>
      <url>/2020/01/29/%E5%85%83%E7%B4%A0%E5%AE%9A%E4%BD%8D%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h5 id="1-元素定位问题"><a href="#1-元素定位问题" class="headerlink" title="1. 元素定位问题"></a>1. 元素定位问题</h5><ol><li><p>元素名称错误，比如后面少了对应右括号）</p></li><li><p>元素本身就不存在，比如调试元素在所在环境中不存在，然而编写代码定位的时候使用的是线上环境账号，其具有该元素，造成元素找不到</p></li><li><p>元素前面未加css=或者xpath=类型名称</p></li><li><p>元素不在屏幕可视范围内导致找不到元素。可使用避免方法：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ExecuteJavascriptdocument.documentElement.scrollTop=10000</span><br></pre></td></tr></table></figure><p> scroll element into view  ${locator}貌似不好用</p></li><li><p>css之间不能用空格，用点来替代</p></li><li><p>AttributeError: ‘list’ object has no attribute ‘startswith’？</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$&#123;obj&#125;    GetWebElements    $&#123;homepage_ele&#125;[button_proceed]</span><br><span class="line">Runkeywordif    $&#123;obj&#125;  click element    $&#123;obj&#125;</span><br></pre></td></tr></table></figure><p> click element后面的按钮元素多次被我写成了对象，会报这个错</p></li><li><p>is not clickable at point (1435, 107). Other element would receive the click: &lt;div class=”shopee-modal__container”</p><p>确实是被其他元素遮挡住了</p></li><li><p>StaleElementReferenceException: Message: stale element reference: element is not attached to the page document</p><p> 很多时候sleep一下就好了</p></li><li><p>一个查了很久的问题，有个场景，进入链接后如果有密码框则点击按钮，但是第一个链接执行之后第二个链接依旧检测到有密码框于是就开始找按钮（实际没有）</p><p> 本来以为是变量第二次赋值的时候有第一次的缓存，但是重新设置${None}后依旧无效。</p><p> 原因：第二个link页面没有展示密码框但是元素中却能搜索到这个css元素值。</p></li><li><p>元素前面忘了写css=  或者xpath=</p></li><li><p>元素一直定位不到，本地机器可以。但是实际看页面上是展示出该元素的</p><p>后来找人查了很久，还是最后查出还是之前我怀疑过的一个问题，就是侧边栏的链接父元素class会变化，后来由开发得知是根据高度来判断的，后来兼容使用模糊匹配xpath=//ul[contains(@class, ‘sidebar’)]//a[contains(text(),”{}”)]</p></li><li><p>同一个页面元素有时候路径不同，需要综合不同情况时的共同点，来取该元素的值。<br>比如my wallet链接。有时候是a有时候是div/span</p></li></ol><h6 id="2-远程下载"><a href="#2-远程下载" class="headerlink" title="2. 远程下载"></a>2. 远程下载</h6><p>  解决：使用谷歌驱动获取远程下载路径文件列表</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">from openapi_utils import split_order, init_forder</span><br><span class="line">from robot.libraries.BuiltIn import BuiltIn</span><br><span class="line">def get_downloaded_files():</span><br><span class="line">    seleniumlib = BuiltIn().get_library_instance(&apos;SeleniumLibrary&apos;)</span><br><span class="line">    driver = seleniumlib.driver</span><br><span class="line">    if not driver.current_url.startswith(&quot;chrome://downloads&quot;):</span><br><span class="line">        driver.get(&quot;chrome://downloads/&quot;)</span><br><span class="line"></span><br><span class="line">    return driver.execute_script( \</span><br><span class="line">    &quot;return downloads.Manager.get().items_   &quot;</span><br><span class="line">    &quot;  .filter(e =&gt; e.state === &apos;COMPLETE&apos;)  &quot;</span><br><span class="line">    &quot;  .map(e =&gt; e.filePath || e.file_path); &quot; )</span><br></pre></td></tr></table></figure><h6 id="3-使用以上js下载脚本时一直提示这个错"><a href="#3-使用以上js下载脚本时一直提示这个错" class="headerlink" title="3. 使用以上js下载脚本时一直提示这个错"></a>3. 使用以上js下载脚本时一直提示这个错</h6><p>JavascriptException: Message: javascript error: Cannot read property ‘get’ of undefined<br>  (Session info: chrome=80.0.3987.122)</p><p>  原因是chrome版本的问题，可能是80版本不兼容，将版本将至79且禁止浏览器更新~</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>RT本地环境配置</title>
      <link href="/2020/01/29/RT%E6%9C%AC%E5%9C%B0%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"/>
      <url>/2020/01/29/RT%E6%9C%AC%E5%9C%B0%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<p>本地环境:Mac</p><ul><li><p>安装谷歌浏览器</p></li><li><p>安装chromedriver</p></li></ul><p><a href="http://chromedriver.chromium.org/downloads" target="_blank" rel="noopener">http://chromedriver.chromium.org/downloads</a><br>或<a href="http://chromedriver.storage.googleapis.com/index.html" target="_blank" rel="noopener">http://chromedriver.storage.googleapis.com/index.html</a></p><p>下载的driver的版本需要和浏览器的版本匹配，解压后放到本机,将文件路径添加至PATH中</p><p>1、将下载的可执行文件移到/usr/local/bin下</p><p>sudo mv chromedriver /usr/local/bin/chromedriver</p><p>2、: 修改文件权限</p><p>sudo chmod u+x,o+x /usr/local/bin/chromedriver</p><p>3、检查是否安装成功:</p><p>chromedriver –version</p><ul><li><p>安装本地运行环境依赖库</p><p>如Python版本：python3.6</p><p>requirements.txt:</p><pre><code>requests==2.22.0robotframework==3.1.2robotframework-ride==1.7.3.1robotframework-seleniumlibrary==3.3.1selenium==3.141.0xlrd==1.2.0Pillow==6.2.1</code></pre></li><li><p>安装插件 IntelliBot 、IntelliBot @SeleniumLibrary Patched、Robot Framework support </p></li><li><p>Preferences-Editor-File Types-Robot Feature下添加*.robot类型</p></li><li><p>Tools-External Tools 配置Tool Setting，其中Arguments配置如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">--loglevel TRACE -d /Users/liyuan/Documents/Log     $FileName$</span><br><span class="line"></span><br><span class="line">-d /Users/liyuan/Documents/Log --loglevel TRACE -t &quot;$SelectedText$&quot; ./</span><br></pre></td></tr></table></figure><p><img src="/images/pasted-77.png" alt="upload successful"></p><p><img src="/images/pasted-78.png" alt="upload successful"></p></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>RT使用pycharm点击引用失效问题</title>
      <link href="/2020/01/29/RT%E4%BD%BF%E7%94%A8pycharm%E7%82%B9%E5%87%BB%E5%BC%95%E7%94%A8%E5%A4%B1%E6%95%88%E9%97%AE%E9%A2%98/"/>
      <url>/2020/01/29/RT%E4%BD%BF%E7%94%A8pycharm%E7%82%B9%E5%87%BB%E5%BC%95%E7%94%A8%E5%A4%B1%E6%95%88%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h5 id="pycharm引用库文件失效问题"><a href="#pycharm引用库文件失效问题" class="headerlink" title="pycharm引用库文件失效问题"></a>pycharm引用库文件失效问题</h5><p>点击引用的库文件应用链接无效，导致输入相应库方法无提示，有以下几种检查办法：</p><p>-1) 检查以下插件是否已安装</p><p>IntelliBot、IntelliBot@SeleniumLibrary Patched 、Robot Framework support</p><p>2) 检查IDE设置</p><p>如pycharm检查Project Interpreter编译器是否错选，或者没选</p><p>3) 检查库文件引用是否重复</p><p>如通过集成已经继承了的库文件，就不要再引用一遍了</p><p>4) 检查代码格式</p><p>Keywords 前最好留有空格；</p><p>本次未提交文件提交上去；</p><p>5) 清零</p><p>如果以上都无法解决，删除本地代码，重新拉取； 重启电脑</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>RT使用语法记录</title>
      <link href="/2020/01/29/RobotFramework/"/>
      <url>/2020/01/29/RobotFramework/</url>
      
        <content type="html"><![CDATA[<h5 id="语法记录"><a href="#语法记录" class="headerlink" title="语法记录"></a>语法记录</h5><p>官方文档：<a href="https://robotframework.org/#/documentation" target="_blank" rel="noopener">https://robotframework.org/#/documentation</a></p><h6 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">*** Test Cases ***</span><br><span class="line"></span><br><span class="line">test case8</span><br><span class="line">    $&#123;a&#125;    Set variable    59</span><br><span class="line">    run keyword if    $&#123;a&#125;&gt;=90    log    优秀</span><br><span class="line">    ...    ELSE IF    $&#123;a&#125;&gt;=70    log    良好</span><br><span class="line">    ...    ELSE IF    $&#123;a&#125;&gt;=60    log    及格</span><br><span class="line">    ...    ELSE    log    不及格</span><br></pre></td></tr></table></figure><p>条件判断赋值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$&#123;ele&#125;    run keyword if    $&#123;i&#125;&lt;$&#123;pagescount&#125;        Get WebElement    $&#123;ele_path&#125;</span><br></pre></td></tr></table></figure><p>一个条件多个执行,注意AND大写</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">run keyword if    $&#123;variable&#125;   run keywords  点击按钮    $&#123;homepage_ele&#125;[vacationmode_on]    AND    获取文本    $&#123;homepage_ele&#125;</span><br></pre></td></tr></table></figure><p>条件判断字符串不存在的时候,字符串变量必须外边必须加引号用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\    run keyword if    &apos;$&#123;temp&#125;&apos;!=&apos;&apos;   exit for loop</span><br></pre></td></tr></table></figure><p>可以使用and和or连接。连接两个条件经常报错，可能是空格的问题，and两边必须保持一个空格</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Run Keyword If   &apos;$&#123;B_name&#125;&apos;==&apos;$&#123;B&#125;&apos; and &apos;$&#123;C&#125;&apos;== &apos;0&apos;</span><br></pre></td></tr></table></figure><p>数字使用或操作</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$&#123;0|0|0|1|0&#125;</span><br></pre></td></tr></table></figure><h6 id="For循环"><a href="#For循环" class="headerlink" title="For循环"></a>For循环</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">test case9</span><br><span class="line">:FOR    $&#123;i&#125;    IN RANGE     1      $&#123;trsize&#125;</span><br><span class="line">\    $&#123;ele&#125;    Catenate    SEPARATOR=$&#123;i+1&#125;   css=tbody tr:nth-of-type(    )&gt;.transaction-escrow-status</span><br><span class="line">\    log    $&#123;ele&#125;</span><br></pre></td></tr></table></figure><p>若for循环体中嵌套了条件判断则else前无需加\，否则报错</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">\    Run Keyword If    &apos;$&#123;get_value&#125;&apos;!=&apos;register&apos;    获取文本校验    $&#123;ele&#125;    $&#123;get_value&#125;</span><br><span class="line">     ...    ELSE    获取文本校验  $&#123;ele_register&#125;    Register/Login</span><br></pre></td></tr></table></figure><h6 id="字符串使用"><a href="#字符串使用" class="headerlink" title="字符串使用"></a>字符串使用</h6><p>三目运算</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$&#123;seller&#125;    set variable if    $&#123;seller&#125;    $&#123;seller&#125;    $&#123;test_data&#125;[seller][account]</span><br></pre></td></tr></table></figure><p>移除部分字符串</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$&#123;t&#125;    remove string     ShopeePay.ps_reports_wallet_all.20191125_20191225.csv    .csv</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$&#123;after&#125;=     remove string     $&#123;test&#125;       ,     $&#123;SPACE&#125;</span><br></pre></td></tr></table></figure><p>字符串连接 Catenate（与变量连接直接放一起也可以）<br><img src="/images/pasted-79.png" alt="upload successful"></p><p>字符串转换成数字，可直接使用${${numstr}}或者int(${numstr})</p><h6 id="列表操作"><a href="#列表操作" class="headerlink" title="列表操作"></a>列表操作</h6><p>所有列表操作举例：cnblogs.com/ronyjay/p/11598107.html </p><p>对列表进行遍历的时候IN后面需用@</p><p>如果通过“@{}”去定义列表的话，可以通过“log many”关键字进行打印 ,当然也可以选择不这么做默认还是用$<br>列表切片</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$&#123;expectedlist&#125;    get slice from list     $&#123;expected&#125;    1</span><br></pre></td></tr></table></figure><p>列表元素是整形</p><pre><code>| ${ints} =   | Create List | ${1} | ${2} | ${3} |</code></pre><h6 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h6><p>需要双杠</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$&#123;rt&#125;=    Get Regexp Matches        $&#123;test&#125;     \\$\\d,\\d+</span><br><span class="line">should match regexp    $&#123;get_amount&#125;    \\$(\\d)*,?(\\d)+</span><br></pre></td></tr></table></figure><p>模糊匹配</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">File Should Exist    /Users/liyuanchen/Downloads/weekly_report*</span><br></pre></td></tr></table></figure><h6 id="其他关键字"><a href="#其他关键字" class="headerlink" title="其他关键字"></a>其他关键字</h6><ul><li><strong>Get WebElement 和Get WebElements的区别</strong>：前者会中断执行，后者返回空。可使用来判断元素是否存在</li></ul><p><img src="/images/pasted-76.png" alt="upload successful"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$&#123;temp&#125;    GetWebElements    css=.username</span><br><span class="line">run keyword if  $&#123;temp&#125;   click button   css=.username</span><br></pre></td></tr></table></figure><ul><li><p>对输入框执行ENTER操作可使用<strong>press keys</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">press keys   css=.shopee-input__input    RETURN</span><br></pre></td></tr></table></figure></li><li><p>生成指定数据范围的随机数字(包括左边，也包括右边)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$&#123;pagenum&#125;    Evaluate    random.randint(1, $&#123;pagescount+1&#125;)    random</span><br><span class="line">log    $&#123;pagenum&#125;</span><br></pre></td></tr></table></figure></li><li><p>robot中，断言有时会失败，但不想影响后面语句的执行，这时候要用到</p><p>  Run Keyword And Continue On Failure</p></li><li><p>计算可使用Evaluate关键字</p><p>  ${rt}    Evaluate    ${num}+1<br>  或${i+1} </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$&#123;if_visible_download&#125;    Run_keyword_and_return_status    Element_Should_Contain    Xpath=//button[@class=&apos;shopee-button shopee-button--primary shopee-button--normal&apos;]    Download</span><br></pre></td></tr></table></figure></li><li><p>其他：</p><p>  run keyword and return status</p></li></ul><h5 id="为解决有些操作失败重新执行："><a href="#为解决有些操作失败重新执行：" class="headerlink" title="为解决有些操作失败重新执行："></a>为解决有些操作失败重新执行：</h5><h6 id="1-添加关键字"><a href="#1-添加关键字" class="headerlink" title="1.添加关键字"></a>1.添加关键字</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">若找不到元素则重新执行</span><br><span class="line">    [Arguments]    $&#123;locator&#125;    $&#123;keyword&#125;</span><br><span class="line">    $&#123;ele&#125;    get webelements    $&#123;locator&#125;</span><br><span class="line">    run keyword unless     $&#123;ele&#125;     $&#123;keyword&#125;</span><br></pre></td></tr></table></figure><h6 id="2-case后添加teardown"><a href="#2-case后添加teardown" class="headerlink" title="2.case后添加teardown"></a>2.case后添加teardown</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">03BlanceAccountCB</span><br><span class="line">    [Documentation]  CB seller进入balance页面，能够展示cb卡片信息,同Bank页面</span><br><span class="line">    [Tags]  all</span><br><span class="line">    [Setup]    获取配置数据</span><br><span class="line">    登录SellerCenter    seller=cbseller</span><br><span class="line">    进入cb_balance模块</span><br><span class="line">    comment  cb账号进如balance校验cb卡片信息</span><br><span class="line">    校验CB卡片信息</span><br><span class="line">    [Teardown]    run keyword if test failed    校验CB卡片信息</span><br></pre></td></tr></table></figure><p>   3.登陆的时候经常不定时出现某些弹窗影响下一步的case？封装关键字轮询查找弹窗<br>登陆弹窗轮询查找</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[Arguments]    $&#123;timeout&#125;=5</span><br><span class="line">:FOR    $&#123;i&#125;    IN RANGE    $&#123;timeout&#125;</span><br><span class="line">\   $&#123;servererror&#125;    弹出框存在则点击    $&#123;homepage_ele&#125;[alert_servererror]     $&#123;timeout&#125;</span><br><span class="line">\   $&#123;version&#125;    弹出框存在则点击    $&#123;login_ele&#125;[version]     $&#123;timeout&#125;</span><br><span class="line">\   $&#123;navigation&#125;    弹出框存在则点击    $&#123;login_ele&#125;[navigation]     $&#123;timeout&#125;</span><br><span class="line">\   $&#123;mainaccount_tips&#125;    弹出框存在则点击    $&#123;login_ele&#125;[mainaccount_tips]     $&#123;timeout&#125;</span><br><span class="line">\   $&#123;mainaccount_tips&#125;    弹出框存在则点击    $&#123;login_ele&#125;[mainaccount_tips]     $&#123;timeout&#125;</span><br><span class="line">\   弹出框存在则点击    $&#123;homepage_ele&#125;[alert_servererror]     $&#123;timeout&#125;</span><br><span class="line">\   exit for loop if   $&#123;$&#123;servererror&#125;|$&#123;version&#125;|$&#123;navigation&#125;|$&#123;mainaccount_tips&#125;|$&#123;mainaccount_tips&#125;&#125;==0</span><br></pre></td></tr></table></figure><h5 id="窗口问题："><a href="#窗口问题：" class="headerlink" title="窗口问题："></a>窗口问题：</h5><p>当有两个窗口如果选择新打开的窗口则用select window   NEW   老窗口换成MAIN，但是如果是三个窗口取中间的窗口呢？</p><p>使用Handles解决：</p><p>1、删除第三个窗口<br>2、获取当前Handle,选择最后一个（实践证明，不可用New，若使用可能会认为被关掉的那个才是new，故不生效）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$&#123;handels_bf&#125;    get window handles</span><br><span class="line">close window</span><br><span class="line">$&#123;handels&#125;    get window handles</span><br><span class="line">$&#123;currenthd&#125;    get from list    $&#123;handels&#125;    -1</span><br><span class="line">select window    $&#123;currenthd&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>mac终端快捷键使用</title>
      <link href="/2020/01/28/mac%E7%BB%88%E7%AB%AF%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
      <url>/2020/01/28/mac%E7%BB%88%E7%AB%AF%E5%BF%AB%E6%8D%B7%E9%94%AE/</url>
      
        <content type="html"><![CDATA[<p>常用的快捷键：<br>参考<a href="https://www.jianshu.com/p/87581b2c570c" target="_blank" rel="noopener">https://www.jianshu.com/p/87581b2c570c</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Ctrl + a 跳到行首</span><br><span class="line">Ctrl + e 跳到行尾</span><br><span class="line">Ctrl + l 清屏，相当于执行clear命令</span><br><span class="line">Command + K 清屏</span><br><span class="line">ctrl+u   删除前面的所有内容</span><br></pre></td></tr></table></figure><p>mac下是否显示隐藏文件，可使用shit+cmd+句号来切换</p><p>终端相关 </p><p><a href="https://support.apple.com/zh-cn/guide/terminal/trmlshtcts/mac" target="_blank" rel="noopener">https://support.apple.com/zh-cn/guide/terminal/trmlshtcts/mac</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">新建标签页    Command-T</span><br><span class="line">下一个标签页    Control-Tab</span><br><span class="line">上一个标签页    Control-Shift-Tab</span><br><span class="line">放大字体    Command-加号键 (+)</span><br><span class="line">缩小字体   Command-减号键 (–)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Jenkins安装和配置</title>
      <link href="/2020/01/28/jenkins%E5%AE%89%E8%A3%85/"/>
      <url>/2020/01/28/jenkins%E5%AE%89%E8%A3%85/</url>
      
        <content type="html"><![CDATA[<h6 id="Jenkins安装"><a href="#Jenkins安装" class="headerlink" title="Jenkins安装"></a>Jenkins安装</h6><p>环境：Ubuntu</p><p>参考：<br><a href="https://www.jianshu.com/p/845f267aec52" target="_blank" rel="noopener">https://www.jianshu.com/p/845f267aec52</a><br><a href="https://www.cnblogs.com/shuoer/p/9471839.html" target="_blank" rel="noopener">https://www.cnblogs.com/shuoer/p/9471839.html</a></p><p>步骤：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#添加官方软件仓库的秘钥到本地的apt秘钥中</span><br><span class="line"> wget -q -O - https://pkg.jenkins.io/debian-stable/jenkins.io.key | sudo apt-key add -</span><br><span class="line"> </span><br><span class="line">echo deb http://pkg.jenkins.io/debian-stable binary/ | sudo tee /etc/apt/sources.list.d/jenkins.list</span><br><span class="line"></span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install jenkins</span><br></pre></td></tr></table></figure><p>安装成功后打开服务</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">root@sz-dev-77-89:/var/lib/dpkg# /etc/init.d/jenkins  start</span><br><span class="line">Correct java version found</span><br><span class="line">[ ok ] Starting jenkins (via systemctl): jenkins.service.</span><br><span class="line">root@sz-dev-77-89:/var/lib/dpkg# systemctl status jenkins</span><br></pre></td></tr></table></figure><p>安装时若报错：</p><p><img src="/images/pasted-74.png" alt="upload successful"></p><p>使用操作文件/var/lib/dpkg/info解决：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">cd /var/lib/dpkg/</span><br><span class="line">mv info/ info_bak         </span><br><span class="line">mkdir info                 </span><br><span class="line">apt-get update            </span><br><span class="line">apt-get -f install         </span><br><span class="line">mv info/* info_bak/        </span><br><span class="line">rm -rf info                </span><br><span class="line">mv info_bak info</span><br></pre></td></tr></table></figure><h6 id="Jenkins安装git插件"><a href="#Jenkins安装git插件" class="headerlink" title="Jenkins安装git插件"></a>Jenkins安装git插件</h6><p>安装jenkins时候安装git插件失败，需在本地先安装git</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-get install git</span><br></pre></td></tr></table></figure><p>然后在插件管理中选中git安装</p><h6 id="Jenkins安装配置git"><a href="#Jenkins安装配置git" class="headerlink" title="Jenkins安装配置git"></a>Jenkins安装配置git</h6><p><img src="/images/pasted-75.png" alt="upload successful"></p><p>【问题】配置git用户时一直报错：Jenkins Host key verification failed</p><p>1.需要在jenkins路径下生产公钥和私钥</p><p>2.把所属用户改成jenkins</p><p>具体步骤   参考<a href="https://blog.csdn.net/hursing/article/details/90521031" target="_blank" rel="noopener">https://blog.csdn.net/hursing/article/details/90521031</a></p><p>1）ssh-keygen -t rsa -C <a href="mailto:jenkinsServerOnLinux@shopeemobile.com" target="_blank" rel="noopener">jenkinsServerOnLinux@shopeemobile.com</a>     </p><p>-c是备注；-f 指定密钥的文件名  ;-t 是type用于指定算法一般rsa;<br>在过程中提示生成路径可以直接改成/var/lib/jenkins/.ssh/id_rsa，其他直接回车即可</p><p>2）生成的公钥放在gitlab下<br>3）按照jenkins提示执行命令<br> git ls-remote -h ssh://gitlab@git.garena.com:2222/autotest/scqa_ui_auto_platform_projects.git HEAD</p><p>根据提示直接yes就好，此步骤会生产know_hosts的文件如果在根路径/root/.ssh下就拷贝过jenkins路径下（不确定这一步的作用是否对结果管用）<br>4）对文件授权<br>chown jenkins:jenkins  id_rsa   id_rsa.pub</p><p>5)重启jenkins<br>/etc/init.d/jenkins restart</p><p>如果没设置管理员密码，需要通过命令获取cat   /var/lib/jenkins/secrets/initialAdminPassword</p><h6 id="设置jenkins无需登录"><a href="#设置jenkins无需登录" class="headerlink" title="设置jenkins无需登录"></a>设置jenkins无需登录</h6><p>链接：<a href="https://www.jianshu.com/p/6591c9bdcca6" target="_blank" rel="noopener">https://www.jianshu.com/p/6591c9bdcca6</a></p><ul><li>进入Jenkins根目录，复制config.xml 为 config.xml.bak用于备份  </li><li>而后打开 config.xml 配置文件；    </li><li>修改“&lt; useSecurity &gt;true&lt; /useSecurity &gt;”为“&lt; useSecurity&gt;false&lt; /useSecurity&gt;”；      </li><li>删掉“&lt; authorizationStrategy …&gt;…&lt; /authorizationStrategy&gt;”；      </li><li>保存修改的confi.xml，重启Jenkins服务已无需登录 </li></ul><h6 id="【问题】打不开log-html-提示Opening-Robot-Framework-log-failed"><a href="#【问题】打不开log-html-提示Opening-Robot-Framework-log-failed" class="headerlink" title="【问题】打不开log.html 提示Opening Robot Framework log failed"></a>【问题】打不开log.html 提示Opening Robot Framework log failed</h6><p>Verify that you have JavaScript enabled in your browser.<br>Make sure you are using a modern enough browser. Firefox 3.5, IE 8, or equivalent is required, newer browsers are recommended.<br>Check are there messages in your browser’s JavaScript error log. Please report the problem if you suspect you have encountered a bug.<br>…”</p><p>解决办法：<br>For resolve your problem you must :</p><ul><li><p>Connect on your jenkins url (http://[IP]:8080/)</p></li><li><p>Click on Manage Jenkins from left side panel.</p></li><li><p>Click on Script Console</p></li><li><p>Copy this into the field<br>System.setProperty(“hudson.model.DirectoryBrowserSupport.CSP”,”sandbox allow-scripts; default-src ‘none’; img-src ‘self’ data: ; style-src ‘self’ ‘unsafe-inline’ data: ; script-src ‘self’ ‘unsafe-inline’ ‘unsafe-eval’ ;”)</p></li><li><p>Click on Run button.</p></li><li><p>Execute your Jenkins build.</p><h5 id="【问题】设置multijob构建任务时只执行第一个任务，报错信息"><a href="#【问题】设置multijob构建任务时只执行第一个任务，报错信息" class="headerlink" title="【问题】设置multijob构建任务时只执行第一个任务，报错信息"></a>【问题】设置multijob构建任务时只执行第一个任务，报错信息</h5><p> Job status: [login for id] the ‘build only if scm changes’ feature is disabled.</p><p>  解决：勾选build only if scm changes为true</p></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>本地上传和下载远程LInux</title>
      <link href="/2020/01/28/%E6%9C%AC%E5%9C%B0%E4%B8%8A%E4%BC%A0%E5%92%8C%E4%B8%8B%E8%BD%BD%E8%BF%9C%E7%A8%8BLInux/"/>
      <url>/2020/01/28/%E6%9C%AC%E5%9C%B0%E4%B8%8A%E4%BC%A0%E5%92%8C%E4%B8%8B%E8%BD%BD%E8%BF%9C%E7%A8%8BLInux/</url>
      
        <content type="html"><![CDATA[<p>上传命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scp path/filename userName@sseverName:path</span><br></pre></td></tr></table></figure><p>下载：调换位置即可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scp userName@sseverName:path path/filename</span><br></pre></td></tr></table></figure><p>我的执行命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo scp /Users/liyuanchen/Documents/workspace/JenkinsTask.zip  xxxxqa@10.12.77.89:/home</span><br></pre></td></tr></table></figure><p>【报错】</p><ol><li><p><a href="mailto:xxxxqa@10.12.77.89" target="_blank" rel="noopener">xxxxqa@10.12.77.89</a>: Permission denied (publickey,password). </p><p>解决方法，在同账户下把A的公钥放到B上，注意你scp的账户，添加在该账户下。<br>具体操作：<br>A：cat .ssh/id_rsa.pub<br>B: cat .ssh/authorized_keys （没有该文件创建一个）<br> 把A的公钥贴过来即可</p></li><li><p>scp: /home/setuptools/JenkinsTask.zip: Permission denied</p><p>还是报错，按照网上的折腾了一番/etc/ssh/sshd/sshd_config中的PasswordAuthentication和AuthorizedKeysFile,放开了注释保证是开通状态；<br>还是不行，在命令行前加sudo。<br>还是不行，直到更改目标文件夹到xxxxqa，因为原文件夹权限是root，使用xxxxqa用户当然不行啦。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">drwxr-xr-x  8 root     root     4096 1月  21 14:40 setuptools</span><br><span class="line">drwxr-xr-x 17 xxxxqa   xxxxqa   4096 1月  27 22:14 xxxxqa</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Django</title>
      <link href="/2019/11/10/Django/"/>
      <url>/2019/11/10/Django/</url>
      
        <content type="html"><![CDATA[<ul><li><p>MVC的核心是思想是：解耦即减少相互联系，使得各个模块相互独立。</p></li><li><p>Django : MTV </p></li><li><p>安装：pip install Django==1.11.4  不写等号默认安装最新版本</p><p>卸载：pip uninsall Django</p></li><li><p>验证 django.get_version()</p></li><li><p>创建项目：</p><ol><li>创建目录  </li><li>cd到该目录下，输入命令django-admin startproject projectname  </li><li>tree . /F (win)查看目录层级</li></ol></li><li><p>配置数据库：</p><pre><code>mysql数据库：安装pymysql1、setting配置：&apos;ENGINE&apos;:&apos;django.db.backends.mysql&apos;,&apos;NAME&apos;:&apos;Learn&apos;,&apos;USER&apos;:&apos;root&apos;,&apos;PASSWORD&apos;:&apos;rock1204&apos;,&apos;HOST&apos;:&apos;localhost&apos;,&apos;PORT&apos;:&apos;3306&apos;,2、在__init__.py中添加 import pymysql pymysql.install_as_MySQLdb()  不添加这些会报错</code></pre></li><li><p>创建应用（app）：<br>可以创建多个应用；</p><p> 步骤：</p><ol><li>在manage所在目录中，输入命令python manage.py startapp myapp</li><li>激活应用，在setting将myapp应用加入到app配置中</li></ol></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>正则表达式+grep</title>
      <link href="/2019/11/10/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F-grep/"/>
      <url>/2019/11/10/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F-grep/</url>
      
        <content type="html"><![CDATA[<h4 id="正则表表达式"><a href="#正则表表达式" class="headerlink" title="正则表表达式"></a>正则表表达式</h4><ul><li>shell 通配符不区分大小写，正则区分;  </li><li>是一种字符模式（pattern）；  </li><li>绝大部分正则表达式都被放在两个正斜杠之间；  </li><li>元字符是最重要的概念;  </li><li>习惯:加单引号如  grep ‘^root’ /etc/passwd   </li></ul><h5 id="基本元字符"><a href="#基本元字符" class="headerlink" title="基本元字符"></a>基本元字符</h5><pre><code>^ 行首定位符$ 行尾定位符.指的是任意一个字符* 单独不能活，指的是前面字符出现次数&gt;=0.*任意多个字符（无敌了）[]匹配指定范围内的一个字符 [lL]ove[ - ]匹配指定范围内的一个字符 [a-z0-9]ove[^]用来匹配不在指定范围内的字符    注意与外面的^的区别：外面的指的是行首，[]里面的指的是取反，如[^0-9A-Z]love不在0-9和A-Z范围内的一个字符\ 用来转义后面的字符，使得后面字符失去元字符作用\&lt;词首定位符\&gt;词尾定位符 \&lt;love\&gt;指的是love这个单词\(..\)匹配稍后使用的字符的标签  如vim中替换:%s#\(10.18.40.\)#\1200#   其中\1替代的是第一个括号的内容x\{m\}x重复出现m次  o\{5\}x\{m,\}x重复出现m次及以上 o\{5,\}x\{m,n\}x重复出现m次到n次 o\{5,8\}\+\|</code></pre><h5 id="扩展元字符"><a href="#扩展元字符" class="headerlink" title="扩展元字符"></a>扩展元字符</h5><pre><code>+ 单独不能活，指的是前面字符出现次数&gt;=1      grep &apos;ro\+t&apos; /etc/passwd  或者 egrep &apos;ro+t&apos; /etc/passwd  （grep不支持元字符，需要转义，或者替换成egrep）? 单独不能活，指的是前面字符出现次数0次或者1次a|b 匹配a或b()组字符  ov+ 指的是v出现1次或多次 (ov)+ 指的是ov出现1次或多次 (..)(..)\1\2 标签匹配字符 （love)able\1er     x{m}x重复出现m次  o{5}x{m,}x重复出现m次及以上 o｛5,}x{m,n}x重复出现m次到n次 o{5,8}</code></pre><h4 id="grep-egrep-fgrep"><a href="#grep-egrep-fgrep" class="headerlink" title="grep/egrep/fgrep"></a>grep/egrep/fgrep</h4><p>  grep：支持基本元字符  grep -e 等价于egrep<br>  egrep:支持扩展元字符<br>  fgrep   </p><pre><code>格式： grep [选项] PATTERN filename1 filename2如：grep -i &apos;Tom&apos; /etc/passwd</code></pre><p>   特别可以使用：</p><pre><code>    \w 代表所有字母与数字  等价于[a-zA-Z0-9]    \W 代表所有字母与数字之外的字符   等价于[^a-zA-Z0-9]    \b 词边界 等价于\&lt; \&gt;选项参数：-i  忽略大小写-q   quiet  无输出-v    反向查找grep --help|grep &apos;\-v&apos;-r/-R 针对目录文件-o  only match 只打印找到的内容，非匹配的整行-n 显示行号-l 显示匹配的目录  grep -l &apos;root&apos; /etc/passwd  /etc/shadow /etc/hosts-A  后几行-B  前几行-C  前后几行</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>matplotlib_pyplot</title>
      <link href="/2019/11/05/matplotlib/"/>
      <url>/2019/11/05/matplotlib/</url>
      
        <content type="html"><![CDATA[<h4 id="pyplot"><a href="#pyplot" class="headerlink" title="pyplot"></a>pyplot</h4><p>subplot(numRows, numCols, plotnum)   如</p><pre><code>plt.figure()plt.subplot(121) #一行两列，处于第一个位置plt.title(&quot;line&quot;)#只有一个列表，默认索引为X轴坐标p1=plt.plot(range(5),linewidth=2.0,color=&apos;g&apos;)p2=plt.plot([5,4,3,2,1],linewidth=2.0,color=&apos;r&apos;)plt.xlabel(&quot;this is x&quot;)plt.ylabel(&quot;this is y&quot;)plt.legend([p1,p2],[&apos;p1label&apos;,&apos;p2label&apos;])#print(line)#line.set(color = &apos;g&apos;,linewidth = 2.0)plt.subplot(122)plt.title(&quot;src_img&quot;)plt.imshow(src_img, cmap=&apos;gray&apos;)plt.savefig(&quot;d:/cly/xuanxiu/img/test.png&quot;)#不支持jpgplt.show()#必须加</code></pre><h4 id="pyplot-legend"><a href="#pyplot-legend" class="headerlink" title="pyplot.legend"></a>pyplot.legend</h4><p>loc：位置信息</p><pre><code>0: ‘best&apos;1: ‘upper right&apos;2: ‘upper left&apos;3: ‘lower left&apos;4: ‘lower right&apos;5: ‘right&apos;6: ‘center left&apos;7: ‘center right&apos;8: ‘lower center&apos;9: ‘upper center&apos;10: ‘center&apos;</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>python  OpenCV</title>
      <link href="/2019/11/04/python-OpenCV/"/>
      <url>/2019/11/04/python-OpenCV/</url>
      
        <content type="html"><![CDATA[<h4 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h4><pre><code>import cv2#生成图片img=cv2.imread(&quot;D:/cly/xuanxiu/img/girl.jpg&quot;)#生成灰色图片imgGray=cv2.imread(&quot;D:/cly/xuanxiu/img/girl.jpg&quot;,0)print(img.shape)#图片高、宽、通道print(img.size)#图总像素print(img.dtype)#图片数据类型是uint8print(imgGray.shape)#图片高、宽、通道；灰色图不返通道#操作：中值滤波result=cv2.medianBlur(imgGray,3)cv2.namedWindow(&apos;result&apos;,0)#创建窗口cv2.resizeWindow(&apos;result&apos;,300,400)#设置大小#显示图片cv2.imshow(&quot;result&quot;,result)#等待图片关闭cv2.waitKey(0)#销毁所有窗口cv2.destroyAllWindows()</code></pre><h4 id="图像处理"><a href="#图像处理" class="headerlink" title="图像处理"></a>图像处理</h4><h5 id="中值滤波：medianBlur"><a href="#中值滤波：medianBlur" class="headerlink" title="中值滤波：medianBlur"></a>中值滤波：medianBlur</h5><p>优点：中值滤波在一定的条件下可以克服常见线性滤波器如方框滤波器、均值滤波等带来的图像细节模糊，而且对滤除脉冲干扰及图像扫描噪声非常有效，也常用于保护边缘信息, 保存边缘的特性使它在不希望出现边缘模糊的场合也很有用，是非常经典的平滑噪声处理方法。</p><p>缺点：但是中值滤波的缺点也很明显，因为要进行排序操作，所以处理的时间长，是均值滤波的5倍以上。</p><h5 id="双边滤波-bilateralFilter"><a href="#双边滤波-bilateralFilter" class="headerlink" title="双边滤波 bilateralFilter"></a>双边滤波 bilateralFilter</h5><p>是一种非线性滤波方法。能够保持边界清晰的情况下有效的去除噪声，但是这种操作比较慢。它拥有着美颜的效果。</p><pre><code>dst = cv2.bilateralFilter(src=image, d=0, sigmaColor=100, sigmaSpace=15)src：原图像；d：像素的邻域直径，可有sigmaColor和sigmaSpace计算可得；sigmaColor：颜色空间的标准方差，一般尽可能大；（越大越模糊）sigmaSpace：坐标空间的标准方差(像素单位)，一般尽可能小。(发现越大处理时间越久)</code></pre><p>链接：<a href="https://www.jianshu.com/p/6c8db06bb0dc" target="_blank" rel="noopener">https://www.jianshu.com/p/6c8db06bb0dc</a><br>链接：<a href="https://www.jianshu.com/p/8d11e26c9665" target="_blank" rel="noopener">https://www.jianshu.com/p/8d11e26c9665</a></p><h4 id="问题："><a href="#问题：" class="headerlink" title="问题："></a>问题：</h4><p>1、读取图片尽量不用中文路径</p><p>2、不加waitKey造成程序无响应</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>http前端</title>
      <link href="/2019/10/26/http%E5%89%8D%E7%AB%AF/"/>
      <url>/2019/10/26/http%E5%89%8D%E7%AB%AF/</url>
      
        <content type="html"><![CDATA[<h5 id="http版本："><a href="#http版本：" class="headerlink" title="http版本："></a>http版本：</h5><pre><code>http1.0:需要使用keep-alive建立长连接（因为创建tcp连接经过三次握手有一定的开销）。从1.1开始默认支持长连接。http1.1:支持只发送header、断点续传、host域http2.0（基于https）:多路复用、header数据压缩、服务器推送http强制缓存：只要不过期就要走缓存，缺点是不能及时更新。http协商缓存：没有修改返304状态码，否则200响应结果。</code></pre><h5 id="浏览器输入网址到加载完页面发生了什么？"><a href="#浏览器输入网址到加载完页面发生了什么？" class="headerlink" title="浏览器输入网址到加载完页面发生了什么？"></a>浏览器输入网址到加载完页面发生了什么？</h5><pre><code>1、    查找DNS缓存（浏览器缓存、操作系统缓存、host查看域名IP、运营商的DNS服务器缓存）2、    DNS域名解析，查找相应IP（过程是从后面往前递归查找）如com-&gt;baidu-&gt;www3、    发起TCP3次握手 建立TCP连接4、    发送http请求  5、    服务端处理请求    MVC分层6、    浏览器接收响应，解析html文件请求静态资源（css/js/imge，若服务器返回304说明请求资源没做修改从本地缓存取即可）7、    根据http响应渲染前端页面，构建DOM树8、    关闭tcp连接（四次挥手手）</code></pre><p>参考：<a href="https://www.cnblogs.com/zgq123456/articles/11641187.html" target="_blank" rel="noopener">https://www.cnblogs.com/zgq123456/articles/11641187.html</a></p><p>【几个问题】：</p><pre><code>1、http新版本请求除非connection:close时会断开TCP，否则在请求完成之前不会断开2、一个TCP连接中可以对应几个http请求？多个3、一个TCP连接中可以一起发送多个http请求么？在http2.0提供了多路复用（Multiplexing）支持此功能。4、为什么有的时候刷新页面不需要重新建立SSL连接 因为TCP连接维持的时候，SSL自然也会用以前的5、浏览器对同一HOST建议TCP连接到数量有没有限制？有 chrome最多建议6个TCP连接。不同浏览器限制不同。</code></pre><h5 id="请求报文的格式"><a href="#请求报文的格式" class="headerlink" title="请求报文的格式"></a>请求报文的格式</h5><p>请求行：url、http协议版本、请求方式<br>请求头：<br>Accept<br>Accept-language<br>Accept-Encoding<br>Cache-Control:<br>Cookie<br>Connection:<br>Content-Type:<br>Content-Length:<br>Host:<br>Referer:<br>User-Agent:</p><p>请求体：数据正文(入参)</p><h4 id="请求方法："><a href="#请求方法：" class="headerlink" title="请求方法："></a>请求方法：</h4><p>  GET POST DELETE PUT HEAD</p><pre><code>DELETE:请求服务端删除指定页面PUT：使传入数据取代指定的文档内容HEAD：类似GET，只是返回内容里只有报头</code></pre><h5 id="状态码："><a href="#状态码：" class="headerlink" title="状态码："></a>状态码：</h5><pre><code>1xx：标识请求已接受，继续处理2xx：成功3xx：重定向4xx：客户端错误5xx：服务端错误常用几个：302:重定向，比如把http请求都转成https400：客户端语法错误403：服务器拒绝提供服务404：请求资源不存在500：服务器内部错误</code></pre><h4 id="cookie和session"><a href="#cookie和session" class="headerlink" title="cookie和session"></a>cookie和session</h4><p>cookie相当于用户身份证，session相当于客户表记录</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>shell命令</title>
      <link href="/2019/10/23/shell%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/"/>
      <url>/2019/10/23/shell%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h4 id="shell执行"><a href="#shell执行" class="headerlink" title="shell执行"></a>shell执行</h4><ul><li><p>执行脚本</p><pre><code>./01.sh   需要执行权限  在子shell中执行bash 01.sh   不需要执行权限  在子shell中执行. 01.sh  不需要执行权限  在当前shell中执行source 01.sh 不需要执行权限  在当前shell中执行</code></pre></li><li><p>调试脚本</p><pre><code>sh -n 02.sh   验证语法是否有错sh -vx 02.sh  查看运行详情</code></pre><p>  若想让代码影响当前shell需要在主shell中执行</p></li><li><p>bg 后台 ，fg 前台</p><p>例如：执行 vi /etc/hosts可以通过ctrl+Z暂停退出，在shell窗口通过fg再返回来</p></li><li><p>cat &lt; /etc/hosts 同 cat  /etc/hosts</p></li><li><p>cat &lt;&lt;EOF 把后面输入的内容给cat作为参数执行</p></li><li><p>cat   &gt;file  &lt;&lt;EOF 将后面输入的内容重定向到file文件中</p></li></ul><h5 id="命令行排序-；-amp"><a href="#命令行排序-；-amp" class="headerlink" title="命令行排序 ；&amp; ||"></a>命令行排序 ；&amp; ||</h5><pre><code>;  无论怎样每条都执行  &amp;  上一条为真下条才执行  ||  上条为假下一条才执行  </code></pre><h4 id="运算总结"><a href="#运算总结" class="headerlink" title="运算总结"></a>运算总结</h4><p>使用let、expr、$(())或$[]进行基本的整数运算，使用bc进行高级的运算，包括小数运算。其中expr命令也能进行整数运算，还能判断参数是否为整数.除此外还有awk</p><pre><code>A=5B=6C= $[$A+$B]  # 方法 1let C=$A+$B     #方法2 :可使用let i++C= $(($A+$B)) # 方法 3C=`expr $A + $B`   # 方法 4其他：C=`echo $A+$B | bc` # 方法 5awk &apos;BEGIN{print &apos;&quot;$A&quot;&apos;+&apos;&quot;$B&quot;&apos;}&apos;  # 方法 6</code></pre><h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><ul><li><p>shell中调用Python程序</p><p>使用相同的标识符比如EOF，其中-为了格式考虑</p><pre><code>#!/usr/bin/bashecho &quot;hello shell&quot;/usr/bin/python &lt;&lt;-EOFprint(&quot;hello python&quot;)EOF</code></pre></li><li><p>变量使用推荐加花括号，如${name}，但定义变量时，变量名不加美元符号！</p></li><li><p>字符串可以用单引号，双引号，也可以不用引号</p></li><li><p>语句中一般不包含分号，空格/tab，以及冒号的标点符号；只在特殊条件下使用。</p><ul><li>分号：只有在代码块都写在一行的时候用分号区分，注意then后面和结束不用分号如if [ “$PS1” ]; then echo test is ok; fi</li></ul><ul><li>冒号：主要用于参数扩展。如echo ${a:-newword}或者{a:=newword}即— word前的“-”可以理解为“没定义，则替换成word”；“+”正相反，可以理解为“有定义，则替换成word”。“?”可以理解为“参数到底定义了没，没定义，把word当错误消息打印出来。”<br>除此获取子字符串可以用${parameter:offset}和${parameter:offset:length}若倒数，则加负号如echo $(var: -5)区别于(var:-5)，后者是没定义则替换成5</li></ul></li><li><p>函数内部使用$n来调用入参</p><pre><code>$0当前脚本名称$n 参数名$#参数总个数$*以一个字符串显示所有参数，与$@同义，前者一个字符串输出，后者N个$?上个命令的推出状态或函数的返回值$$当前shell进程ID</code></pre></li><li><p>和其他语言不同，调用函数仅使用函数名即可,参数直接空格跟后面，没有括号</p></li><li><p>和其他语言不同，shell语言中0代表true，其他值代表false</p></li><li><p>条件表达式要放在方括号[]之间，并且所有地方都要有空格如[ $a == $b ]<br>==用于数字比较[ $a == $b ] ，=用于字符串比较[ $a = $b]<br>条件表达式中运算符前面都有横杠-</p></li><li><p>f 表示文件(普通)存在<br>条件控制：if 要加then fi 循环控制要加do done</p></li><li><p>引用其他文件： .filename或者source filename</p></li><li><p>字符串运算符：单目-z(长度为0) -n（长度不为0） $（是否为空）</p></li><li><p>命令export作用是使变量可以在子shell中使用，与source类似也有区别。</p></li><li><p>使用nohup command &amp;使程序在后台运行，hohup作用是即使session关闭程序也不中断</p></li><li><p>输入重定向与输出相反，command&lt; filename ，是将本来从键盘获取的输入变成了文件，然后利用command执行该文件</p></li><li><p>追加重定向都是双大于等于号，如&gt;&gt;或&lt;&lt;</p></li><li><p>读取文件read:使用 cat 命令并通过管道将结果直接传送给包含 read 命令的 while 命令。如cat test.txt | while read line<br>大括号的作用：相当于创建了个匿名函数，左括号后必须有空格，右括号前的命令必须有分号。</p></li><li><p>怎样获取文件第k行？ head -k filename|tail -1 其中head/tail -n k与head/tail -k相同<br>或者sed -n ‘kp’ filename</p></li><li><p>egrep除了grep -e的功能外，还可以用扩展表达式egrep “^test|^root” /etc/hosts<br>grep xxx filename  文件中包含xx的行记录</p><pre><code>写程序为用户计算主组数目并显示次数和组名cat /etc/passwd|cut -d: -f4|sort|uniq -c|while read c gdo{ echo $c; grep :$g: /etc/group|cut -d: -f1;}|xargs -n 2done</code></pre></li><li><p>文件描述符0代表标准输入、1代表标准输出、2代表标准错误输出。<br>若错误输出和标准输出都同时重定向到一个位置，使用2&gt;&amp;1如</p><pre><code>ls /usr/share/doc &gt; out.txt 2&gt;&amp;1</code></pre></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>web测试</title>
      <link href="/2019/10/21/web%E6%B5%8B%E8%AF%95/"/>
      <url>/2019/10/21/web%E6%B5%8B%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<h4 id="web测试与APP测试区别"><a href="#web测试与APP测试区别" class="headerlink" title="web测试与APP测试区别"></a>web测试与APP测试区别</h4><p><img src="%5Cimages%5Cpasted-70.png" alt="upload successful"><br>参照：<a href="https://blog.csdn.net/weixin_34043301/article/details/94216811" target="_blank" rel="noopener">https://blog.csdn.net/weixin_34043301/article/details/94216811</a></p><p>H5与web的不同点（具有的app特性）：</p><pre><code>1、网络：2G、3G以及弱网测试2、有横屏竖屏之分3、兼容：需兼容不同分辨率/操作系统的手机浏览器4、手指滑动流畅度，手机点击焦点是否定位准确5、关注交互是否友好，尤其弹层6、嵌入手机端与native页有交互7、返回功能非手机自带，自己拥有</code></pre><p>H5与APP的不同点（具有的web特性）：</p><pre><code>1、可以在PC端浏览器打开进行功能测试2、缓存在浏览器上，需要清理缓存测试3、安卓和IOS统一版本，一套代码部署</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>numpy函数总结</title>
      <link href="/2019/10/19/numpy%E5%87%BD%E6%95%B0%E6%80%BB%E7%BB%93/"/>
      <url>/2019/10/19/numpy%E5%87%BD%E6%95%B0%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>==DataFrame用法==</p><h3 id="一、类型转换"><a href="#一、类型转换" class="headerlink" title="一、类型转换"></a>一、类型转换</h3><p> Numpy matrices必须是2维的,但是 numpy arrays (ndarrays) 可以是多维的（1D，2D，3D····ND）. Matrix是Array的一个小的分支，包含于Array。所以matrix 拥有array的所有特性。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">data = DataFrame(np.arange(16).reshape(4,4),index = list(&quot;ABCD&quot;),columns=list(&apos;wxyz&apos;))</span><br><span class="line">a=data.as_matrix() #将dataframe形式的数据框data转化为矩阵a</span><br><span class="line"> </span><br><span class="line">  #将dataframe形式的数据框存储到Excel文件中：</span><br><span class="line">data.to_excel(r&apos;E:\pypractice\Yun\doc\2.xls&apos;, sheet_name=&apos;Sheet1&apos;)      </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; from numpy import *</span><br><span class="line">&gt;&gt;&gt; a1 =[[1,2,3],[4,5,6]] #列表</span><br><span class="line">&gt;&gt;&gt; a1</span><br><span class="line">[[1, 2, 3], [4, 5, 6]]</span><br><span class="line">&gt;&gt;&gt; a2 = array(a1)   #列表 -----&gt; 数组</span><br><span class="line">&gt;&gt;&gt; a2</span><br><span class="line">array([[1, 2, 3],</span><br><span class="line">       [4, 5, 6]])</span><br><span class="line">&gt;&gt;&gt; a3 = np.mat(a1)      #列表 ----&gt; 矩阵</span><br><span class="line">&gt;&gt;&gt; a3</span><br><span class="line">matrix([[1, 2, 3],</span><br><span class="line">        [4, 5, 6]])</span><br><span class="line">&gt;&gt;&gt; a4=a3[:,0:2]   #对矩阵的操作,选取其前两列的数据</span><br><span class="line">&gt;&gt;&gt; a4</span><br><span class="line">matrix([[1, 2],</span><br><span class="line">        [4, 5]])</span><br><span class="line">&gt;&gt;&gt; a5 = a3.tolist()   #矩阵 ---&gt; 列表</span><br><span class="line">&gt;&gt;&gt; a5</span><br><span class="line">[[1, 2, 3], [4, 5, 6]]</span><br><span class="line">&gt;&gt;&gt; a5 == a1</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; a6 = list(a2)   #数组 ---&gt; 列表</span><br><span class="line">&gt;&gt;&gt; a6</span><br><span class="line">[array([1, 2, 3]), array([4, 5, 6])]</span><br><span class="line">&gt;&gt;&gt; a7=a2.tolist() #数组 ---&gt; 列表,内部数组也转换成列表</span><br><span class="line">&gt;&gt;&gt; a7</span><br><span class="line">[[1, 2, 3], [4, 5, 6]]</span><br><span class="line">&gt;&gt;&gt; a8 = array(a3)  #矩阵 ---&gt; 数组</span><br><span class="line">&gt;&gt;&gt; a8</span><br><span class="line">array([[1, 2, 3],</span><br><span class="line">       [4, 5, 6]])</span><br><span class="line">&gt;&gt;&gt; a9 = mat(a2)   #数组 ---&gt; 矩阵</span><br><span class="line">&gt;&gt;&gt; a9</span><br><span class="line">matrix([[1, 2, 3],</span><br><span class="line">        [4, 5, 6]])</span><br><span class="line">&gt;&gt;&gt; ################</span><br><span class="line">&gt;&gt;&gt; #在一维情况下的#矩阵 ---&gt; 数组---&gt; 矩阵结果不同</span><br><span class="line">&gt;&gt;&gt; #在一维情况下的列表 ----&gt; 矩阵 ---&gt; 列表结果不同</span><br><span class="line">&gt;&gt;&gt; a1 =[1,2,3,4,5,6] #列表</span><br><span class="line">&gt;&gt;&gt; a1</span><br><span class="line">[1, 2, 3, 4, 5, 6]</span><br><span class="line">&gt;&gt;&gt; a3 = mat(a1)      #列表 ----&gt; 矩阵</span><br><span class="line">&gt;&gt;&gt; a3</span><br><span class="line">matrix([[1, 2, 3, 4, 5, 6]])</span><br><span class="line">&gt;&gt;&gt; a4 = a3.tolist()  #矩阵 ---&gt; 列表</span><br><span class="line">&gt;&gt;&gt; a4</span><br><span class="line">[[1, 2, 3, 4, 5, 6]]</span><br><span class="line">&gt;&gt;&gt; a4[0]</span><br><span class="line">[1, 2, 3, 4, 5, 6]</span><br><span class="line">&gt;&gt;&gt; a5 = mat(array(a1))   #数组 ---&gt; 矩阵</span><br><span class="line">&gt;&gt;&gt; a5</span><br><span class="line">matrix([[1, 2, 3, 4, 5, 6]])</span><br><span class="line">&gt;&gt;&gt; a6 = array(a5)  #矩阵 ---&gt; 数组</span><br><span class="line">&gt;&gt;&gt; a6</span><br><span class="line">array([[1, 2, 3, 4, 5, 6]])</span><br></pre></td></tr></table></figure><h3 id="二、选择对象"><a href="#二、选择对象" class="headerlink" title="二、选择对象"></a>二、选择对象</h3><p>1.选择特定列和行的数据<br>a[‘x’] 那么将会返回columns为x的列，注意这种方式一次只能返回一个列。a.x与a[‘x’]意思一样。</p><p>取行数据，通过切片[]来选择<br>如：a[0:3] 则会返回前三行的数据。</p><p>2.loc是通过标签来选择数据<br>a.loc[‘one’]则会默认表示选取行为’one’的行；</p><p>a.loc[:,[‘a’,’b’] ] 表示选取所有的行以及columns为a,b的列；</p><p>a.loc[[‘one’,’two’],[‘a’,’b’]] 表示选取’one’和’two’这两行以及columns为a,b的列；</p><p>a.loc[‘one’,’a’]与a.loc[[‘one’],[‘a’]]作用是一样的，不过前者只显示对应的值，而后者会显示对应的行和列标签。</p><p>3.iloc则是直接通过位置来选择数据<br>这与通过标签选择类似<br>a.iloc[1:2,1:2] 则会显示第一行第一列的数据;(切片后面的值取不到)</p><p>a.iloc[1:2] 即后面表示列的值没有时，默认选取行位置为1的数据;</p><p>a.iloc[[0,2],[1,2]] 即可以自由选取行位置，和列位置对应的数据。</p><p>原文：<a href="https://blog.csdn.net/tanlangqie/article/details/78659988" target="_blank" rel="noopener">https://blog.csdn.net/tanlangqie/article/details/78659988</a> </p><p>==转置==<br><img src="https://img-blog.csdnimg.cn/20190129142722602.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20190129142701422.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N1cGVyX2NoZW5seQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>==numpy的array和python中自带的list之间相互转化==</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a=([3.234,34,3.777,6.33])#a为python的list类型</span><br><span class="line"></span><br><span class="line">np.array(a)#将a转化为numpy的array</span><br><span class="line">array([  3.234,  34.   ,   3.777,   6.33 ])</span><br><span class="line"></span><br><span class="line">a.tolist()#将a转化为python的list</span><br></pre></td></tr></table></figure><p>==pandas中利用 .iloc 和 .loc 切片==</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rows = pd.read_csv(&apos;test.csv&apos;)</span><br><span class="line">row_slice = rows.iloc[0:2, 1:3]  # 取rows的0-1行，1-2列的元素</span><br><span class="line">print(row_slice)</span><br></pre></td></tr></table></figure><p><a href="https://blog.csdn.net/qq1483661204/article/details/77587881" target="_blank" rel="noopener">https://blog.csdn.net/qq1483661204/article/details/77587881</a></p><p>==numpy中reshape函数==<br>必须是矩阵格式或者数组格式，才能使用 .reshape(c, -1) 函数， 表示将此矩阵或者数组重组，以 c行d列的形式表示（-1的作用就在此，自动计算d(行或列)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">a1=np.ones((3,2))</span><br><span class="line">print(a1.reshape(-1,1))</span><br><span class="line">结果：</span><br><span class="line">[[1.]</span><br><span class="line"> [1.]</span><br><span class="line"> [1.]</span><br><span class="line"> [1.]</span><br><span class="line"> [1.]</span><br><span class="line"> [1.]]</span><br></pre></td></tr></table></figure><p>==Python取numpy数组的某几行某几列方法==<br><img src="https://img-blog.csdnimg.cn/20181218180709674.png" alt="在这里插入图片描述"></p><p>正确分析：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">C_A = c[[0,2]]    #先取出想要的行数据</span><br><span class="line">C_A = C_A[:,[2,3]] #再取出要求的列数据</span><br><span class="line">print(C_A) #输出最终结果</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td></tr></table></figure><p>原文：<a href="https://blog.csdn.net/qq_34734303/article/details/80631831" target="_blank" rel="noopener">https://blog.csdn.net/qq_34734303/article/details/80631831</a><br>==stack==</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">np.vstack():在竖直方向上堆叠</span><br><span class="line">np.hstack():在水平方向上平铺</span><br><span class="line"></span><br><span class="line">import numpy as np</span><br><span class="line">arr1=np.array([1,2,3])</span><br><span class="line">arr2=np.array([4,5,6])</span><br><span class="line">print (np.vstack((arr1,arr2)))</span><br><span class="line"> #[[1 2 3]</span><br><span class="line"> #[4 5 6]]</span><br><span class="line">print (np.hstack((arr1,arr2)))</span><br><span class="line">#  [1 2 3 4 5 6]</span><br><span class="line"></span><br><span class="line">a1=np.array([[1,2],[3,4],[5,6]])</span><br><span class="line">a2=np.array([[7,8],[9,10],[11,12]])</span><br><span class="line">print (a1)</span><br><span class="line">print (a2)</span><br><span class="line">print (np.hstack((a1,a2)))</span><br><span class="line"># [[ 1  2  7  8]</span><br><span class="line">#  [ 3  4  9 10]</span><br><span class="line">#  [ 5  6 11 12]]</span><br></pre></td></tr></table></figure><p>原文 <a href="https://blog.csdn.net/m0_37393514/article/details/79538748" target="_blank" rel="noopener">https://blog.csdn.net/m0_37393514/article/details/79538748</a><br>==np.random.choice==</p><p>参数意思分别 是从a 中以概率P，随机选择3个, p没有指定的时候相当于是一致的分布</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a1 = np.random.choice(a=5, size=3, replace=False, p=None)</span><br><span class="line">print(a1)</span><br></pre></td></tr></table></figure><p>非一致的分布，会以多少的概率提出来</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a2 = np.random.choice(a=5, size=3, replace=False, p=[0.2, 0.1, 0.3, 0.4, 0.0])</span><br><span class="line">print(a2)</span><br></pre></td></tr></table></figure><p> replacement 代表的意思是抽样之后还放不放回去，如果是False的话，那么出来的三个数都不一样，如果是<br>True的话， 有可能会出现重复的，因为前面的抽的放回去了</p><hr><p>原文：<a href="https://blog.csdn.net/qfpkzheng/article/details/79061601" target="_blank" rel="noopener">https://blog.csdn.net/qfpkzheng/article/details/79061601</a> </p><p>==numpy添加新的维度：newaxis==</p><pre><code>newaxis放在第几个位置，就会在shape里面看到相应的位置增加了一个维数</code></pre><p><img src="https://img-blog.csdnimg.cn/20181218180609497.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Nub3d5YmVhcg==,size_16,color_FFFFFF,t_70" alt="è¿™é‡Œå†™å›¾ç‰‡æè¿°"><br>来源：<a href="https://blog.csdn.net/xtingjie/article/details/72510834" target="_blank" rel="noopener">https://blog.csdn.net/xtingjie/article/details/72510834</a><br>==.dot()==<br>一开始看到这个函数的时候，总是把它想成点积，因为dot是点的意思。。。</p><p>后来在经历了dot()和*完全搞混，犯下错误之后，才终于弄明白了。</p><p><em>dot()计算的是我们经常计算的矩阵乘法，设A(2 * 3), B(3 * 4), 那么dot(A, B)就表示两个矩阵相乘，得到的结果是一个2 * 4的矩阵。</em></p><p>而<em>，相当于matlab中的.</em>, 也就是真正的点积，即元素对应相乘。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; a = [[1, 0], [0, 1]]</span><br><span class="line">&gt;&gt;&gt; b = [[4, 1], [2, 2]]</span><br><span class="line">&gt;&gt;&gt; np.dot(a, b)</span><br><span class="line">array([[4, 1],</span><br><span class="line">       [2, 2]])</span><br></pre></td></tr></table></figure><p>两个向量a = [a1, a2,…, an]和b = [b1, b2,…, bn]的点积定义为：a·b=a1b1+a2b2+……+anbn</p><p>引用：<a href="https://blog.csdn.net/qq_25436597/article/details/78839059" target="_blank" rel="noopener">https://blog.csdn.net/qq_25436597/article/details/78839059</a></p><p>==numpy.concatenate==</p><p>numpy提供了numpy.concatenate((a1,a2,…), axis=0)函数。能够一次完成多个数组的拼接。其中a1,a2,…是数组类型的参数</p><p>示例3：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; a=np.array([1,2,3])</span><br><span class="line">&gt;&gt;&gt; b=np.array([11,22,33])</span><br><span class="line">&gt;&gt;&gt; c=np.array([44,55,66])</span><br><span class="line">&gt;&gt;&gt; np.concatenate((a,b,c),axis=0)  # 默认情况下，axis=0可以不写</span><br><span class="line">array([ 1,  2,  3, 11, 22, 33, 44, 55, 66]) #对于一维数组拼接，axis的值不影响最后的结果</span><br><span class="line">#多维数组：</span><br><span class="line">&gt;&gt;&gt; a=np.array([[1,2,3],[4,5,6]])</span><br><span class="line">&gt;&gt;&gt; b=np.array([[11,21,31],[7,8,9]])</span><br><span class="line">&gt;&gt;&gt; np.concatenate((a,b),axis=0)</span><br><span class="line">array([[ 1,  2,  3],</span><br><span class="line">       [ 4,  5,  6],</span><br><span class="line">       [11, 21, 31],</span><br><span class="line">       [ 7,  8,  9]])</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; np.concatenate((a,b),axis=1)  #axis=1表示对应行的数组进行拼接</span><br><span class="line">array([[ 1,  2,  3, 11, 21, 31],</span><br><span class="line">       [ 4,  5,  6,  7,  8,  9]])OC](这里写自定义目录标题)</span><br></pre></td></tr></table></figure><h4 id="其他函数-np-arange-np-repeat"><a href="#其他函数-np-arange-np-repeat" class="headerlink" title="其他函数 np.arange np.repeat"></a>其他函数 np.arange np.repeat</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line"> </span><br><span class="line">x = np.arange(5)  </span><br><span class="line">print (x)</span><br><span class="line">c=np.array(([1,2],[3,4]))</span><br><span class="line">print (c)</span><br><span class="line">print(np.repeat(c,2))</span><br><span class="line">print(np.repeat(c,2,0))</span><br><span class="line">print(np.repeat(c,2,1))</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>jmeter实践笔记</title>
      <link href="/2019/10/16/jmeter%E5%AE%9E%E8%B7%B5%E7%AC%94%E8%AE%B0/"/>
      <url>/2019/10/16/jmeter%E5%AE%9E%E8%B7%B5%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h4 id="1-安装"><a href="#1-安装" class="headerlink" title="1.安装"></a>1.安装</h4><p>安装参考：<a href="https://blog.csdn.net/lovesoo/article/details/78579547" target="_blank" rel="noopener">https://blog.csdn.net/lovesoo/article/details/78579547</a></p><p>线程数：可以理解为并发数，在jmeter中一个线程代表一个用户。</p><p>Ramp-Up Period (in seconds): 多长时间内初始化完这些线程。单位是秒。我这里设置的是10秒启动100个也就是1秒启动10。</p><p>循环次数：如果你要限定循环次数为10次的话，就取消永远前面的那个勾，然后在后面的文本框里面填写10；在这里我们勾上永远，表示如果不停止或者限定时间将会一直执行下去， 是为了方便调度器的调用。一般勾选永远后要在调度器里填写持续时间。</p><p>对于结果和图表，原生三个元件常用：聚合报告、图表结果、响应时间图</p><h4 id="2-插件使用"><a href="#2-插件使用" class="headerlink" title="2.插件使用"></a>2.插件使用</h4><p>第一步：下载jmeter-plugins，<a href="https://jmeter-plugins.org/install/Install/，安装提示将jar包放在jmeter安装目录lib/ext下" target="_blank" rel="noopener">https://jmeter-plugins.org/install/Install/，安装提示将jar包放在jmeter安装目录lib/ext下</a>  </p><p>第二步：jmeter中option-jmeter plugins Manager-Available Plugins-jdbc Standard Set,点击右下角的Apply Changes and Restart JMeter</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Crypto模块</title>
      <link href="/2019/10/07/Django%E9%A1%B9%E7%9B%AE%E5%AE%9E%E8%B7%B5-Crypto%E5%BA%93/"/>
      <url>/2019/10/07/Django%E9%A1%B9%E7%9B%AE%E5%AE%9E%E8%B7%B5-Crypto%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<p>背景：<br>    由于公司接口有加密解密，自定义接口脚本需要调取Crypto模块，之前用的是php调用python脚本实现的结构体，过于繁琐，打算搭建Django框架实现</p><h2 id="问题一："><a href="#问题一：" class="headerlink" title="问题一："></a>问题一：</h2><p>但是搭建后发现调用Crypto模块经常会报错，主要报错是：<br>from Crypto.Cipher import _AES<br>ImportError: DLL load failed: 找不到指定的模块。<br>这个问题困扰了我很久，原来代码目录<br><img src="https://img-blog.csdnimg.cn/201903111457336.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N1cGVyX2NoZW5seQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>1、一直认为引用这个模块使用的是目录调用，然后验证路径调用是否正确，怎么验证也没发现什么毛病<br>2、文件里引用当前目录的_AES,最开始以为是AES.py文件本身（单下划线私有变量）；后来知道.pyd文件实际上就是个库文件（DLL），才转移到是引用的_ASE.pyd，但是也没有找出找不到它的理由<br><img src="https://img-blog.csdnimg.cn/20190311150008620.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N1cGVyX2NoZW5seQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>解决：<br>后来尝试在原来PHP框架里删除该引用文件，发现依旧可用，于是明确一点：该实现并不依赖该路径，而是与系统安装的pycrypto路径文件有关，但是wondows本地一直有问题，于是直接从当前正在使用PHP linux服务器上调试。做法：删除本地目录（直接用系统的，经之前项目验证系统的没问题，可以用），然后启动Django服务就不报错了，后来又调试了下报错都是些其他的问题了，困扰我两周的问题终于终于落幕了，可以收下心做正事了~~</p><h2 id="问题2："><a href="#问题2：" class="headerlink" title="问题2："></a>问题2：</h2><p>虽然在linux上的这个问题莫名其妙的解决了，但是在台式机win7（py3.7）系统上还是有问题，使用django框架吊起来没有问题，但是直接执行python脚本还是会报一样的错误。忍了一段时间后终于忍不下去了。<br>最开始听人说在linux环境可行，于是在windows下打开git bash确实可行，但是还是会报其他的错，可能是因为版本换了，因为他走的是Anaconda里面的插件，后来干脆还是修复本地的吧<br>1、卸载本地的pycrypto<br>卸载失败提示:Cannot uninstall ‘’. It is a distutils installed project and thus we cannot accurately.<br>解决：直接全局搜索对应文件，具体包括 “package name” 文件夹 和 “package name”.egg-info ，找到后直接删除即可<br>2、重新安装pip install pycrypto<br>直接安装报错，使用源码安装？一样报错<br>error: command ‘C:\Program Files (x86)\Microsoft Visual Studio 14.0\VC\BIN\<br>x86_amd64\cl.exe’ failed with exit status 2<br>解决：从网上找的经验<br>1）添加VC环境变量，设置用户环境变量，这里划重点！！！是用户环境变量，不是系统环境变量<br>变量名：VCINSTALLDIR<br>（变量值为vs安装路径下的VC，默认是这个）<br>变量值：C:\Program Files (x86)\Microsoft Visual Studio 14.0\VC<br> win+R运行cmd，执行命令set CL=/FI”%VCINSTALLDIR%\INCLUDE\stdint.h” %CL% </p><p>2）安装twisted <a href="https://blog.csdn.net/jiangyunsheng147/article/details/80449556" target="_blank" rel="noopener">https://blog.csdn.net/jiangyunsheng147/article/details/80449556</a></p><p>还会报错warning: GMP or MPIR library not found; Not building Crypto.PublicKey._fastmath.<br>building ‘Crypto.Random.OSRNG.winrandom’ extension<br>error: Unable to find vcvarsall.bat</p><p>3）降低版本3.7–&gt;3.6<br>还是报楼上错误，最后看到有pycrypto-2.6.1.win-amd64-py3.4.exe可行，但是需要3.4.于是降到3.4，刚开始用的exe事32位的不行，后来下了64的果然可以了，搞了一天的环境终于在最后搞定了，也不辜负这一天的工时。<br>插曲：在降低版本的时候，出现了明明已经降到3.4，但是python -V的时候一直仍然显示3.7，后来又是删注册表，又是卸载程序的，我怀疑跟我安装的Anaconda有关系。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Docker使用篇</title>
      <link href="/2019/10/07/Docker/"/>
      <url>/2019/10/07/Docker/</url>
      
        <content type="html"><![CDATA[<p>参考菜鸟教程 <a href="https://www.runoob.com/docker/docker-tutorial.html" target="_blank" rel="noopener">https://www.runoob.com/docker/docker-tutorial.html</a><br><a href="https://www.cnblogs.com/hellangels333/p/9749905.html" target="_blank" rel="noopener">https://www.cnblogs.com/hellangels333/p/9749905.html</a></p><h4 id="启动docker"><a href="#启动docker" class="headerlink" title="启动docker"></a>启动docker</h4><p> 命令行启动 或点击图标启动app</p><p> $ docker   可查看所有命令</p><p> 比如常用命令：</p>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker version</span><br><span class="line">$ docker info</span><br></pre></td></tr></table></figure><h4 id="镜像管理"><a href="#镜像管理" class="headerlink" title="镜像管理"></a>镜像管理</h4><ul><li>docker search 命令来搜索镜像</li></ul><p>ps:镜像加速 mac:<a href="http://f971cfe6.m.daocloud.io加入deamon-Registry" target="_blank" rel="noopener">http://f971cfe6.m.daocloud.io加入deamon-Registry</a> mirrors</p><ul><li><p>docker pull  获取新镜像</p><p>注意使用OFFICIAL的官方镜像</p><p>  我们可以从 Docker Hub 网站来搜索镜像，Docker Hub 网址为：<br><a href="https://hub.docker.com/" target="_blank" rel="noopener">https://hub.docker.com/</a></p><p>  使用国内镜像参考地址：<a href="https://www.docker-cn.com/registry-mirror" target="_blank" rel="noopener">https://www.docker-cn.com/registry-mirror</a></p></li><li><p>docker images   //列出本地主机上的镜像 </p><pre><code>REPOSITORY：表示镜像的仓库源TAG：镜像的标签(可以理解为不同的版本号)IMAGE ID：镜像IDCREATED：镜像创建时间</code></pre><p>实例：</p><p>1、docker ps或docker images</p><p>Cannot connect to the Docker daemon at unix:///var/run/docker.sock. Is the docker daemon running?</p><p>原因：未打开docker，启动docker图标，直至展示running</p><p>2、打开后发现需要指定运行目录</p><p>ls查看当前目录结构，选择映射目录<br>再停掉容器：<br>docker stop  362f8b09c8f43517957423b23f5e0d07ffa164864170262ec14150f2ad267<br>再打开的时候加-v 参数</p></li></ul><h4 id="容器管理"><a href="#容器管理" class="headerlink" title="容器管理"></a>容器管理</h4><p>可通过docker –help 查看所有命令，常用以下几个命令</p><pre><code>$ docker ps  -a  //使用 docker ps 来查看我们正在运行的容器</code></pre><p><img src="https://img-blog.csdnimg.cn/20190514152454652.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N1cGVyX2NoZW5seQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><pre><code>docker rm +容器名   //删除容器时，容器必须是停止状态，否则会报错docker rm $(docker ps -a -q)docker stop +ID 或者名字docker start +容器名 //已经停止状态的容器，我们可以使用命令 docker start 来启动。docker port +（ID 或者名字）//容器的某个确定端口映射到宿主机的端口号docker logs [ID或者名字] //可以查看容器内部的标准输出。  docker top +容器名  //查看容器内部运行的进程docker inspect +容器名 //查看 Docker 的底层信息。它会返回一个JSON 文件记录着 Docker 容器的配置和状态信息。</code></pre><h4 id="启动容器"><a href="#启动容器" class="headerlink" title="启动容器"></a>启动容器</h4><p>如果把镜像看成面向对象中的 类 的话，那么容器就是 类 的实例化 对象。</p><h6 id="查看运行帮助："><a href="#查看运行帮助：" class="headerlink" title="查看运行帮助："></a>查看运行帮助：</h6><pre><code>$ sudo docker run --help</code></pre><h6 id="举例：启动-ngnix-容器"><a href="#举例：启动-ngnix-容器" class="headerlink" title="举例：启动 ngnix 容器"></a>举例：启动 ngnix 容器</h6><pre><code>$ sudo docker run --name some-nginx -d -p 8080:80 registry.docker-cn.com/library/nginxb5bbf1dfe86a21d641a161c05598c0f4f4d4b32fc8d756b6fdf306295067625f</code></pre><p>-name 指定启动容器的名称为 some-nginx。</p><p>-d 让Docker容器在后台以守护态（Daemonized）形式运行。</p><p>-p 将容器的80端口映射到主机的8080端口</p><p>registry.docker-cn.com/library/nginx 为启动容器的镜像。</p><p>处理过程： <font color="red"><br>浏览器 –&gt; ubuntu(8080) –&gt; Nginx容器(80)</font></p><h6 id="其他参数说明"><a href="#其他参数说明" class="headerlink" title="其他参数说明"></a>其他参数说明</h6><p>  -t （tty）选项让Docker分配一个伪终端（pseudo-tty）并绑定到容器的标准输入上。</p><p>  -i (interactive)则让容器的标准输入保持打开,即保持交互模式。 </p><p>  -v  :   表示需要将本地哪个目录挂载到容器中，格式：-v &lt;宿主机目录&gt;:&lt;容器目录&gt;<br>   eg：<del>/tensorflow:/notebooks/data<br>   将本地的</del>/tensorflow文件夹挂载到新建容器的/notebooks/data下（这样可是实现本地文件和docker文件互通）<br>   tensorflow/tensorflow为指定的镜像，默认标签为latest（即tensorflow/tensorflow:latest）</p><p>   -w  指定其为工作目录</p><pre><code>runoob@runoob:~/python$ docker run  -v $PWD/myapp:/usr/src/myapp  -w /usr/src/myapp python:3.5 python helloworld.py    命令说明：        -v ：$PWD/myapp:/usr/src/myapp :将主机中当前目录下的myapp挂载到容器的/usr/src/myapp        -w ：/usr/src/myapp :指定容器的/usr/src/myapp目录为工作目录        python helloworld.py : 使用容器的python命令来执行工作目录中的helloworld.py文件</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>性能测试</title>
      <link href="/2019/10/05/%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/"/>
      <url>/2019/10/05/%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<ul><li><strong>重要指标</strong></li></ul><p>TPS ：是TransactionsPerSecond的缩写，也就是事务数/秒</p><p>QPS：Queries Per Second意思是“每秒查询率</p><p>区别：  </p><pre><code>tps，即每秒处理事务数，每个事务包括了如下3个过程：a.用户请求服务器b.服务器自己的内部处理（包含应用服务器、数据库服务器等）c.服务器返回给用户如果每秒能够完成N个这三个过程，tps就是N；qps，如果是对一个页面请求一次，形成一个tps，但一次页面请求，可能产生多次对服务器的请求（页面上有很多**html资源，比如图片**等），服务器对这些请求，就可计入“qps”之中；但是，如今的项目基本上都是前后端分离的，性能也分为前端性能和后端性能，通常默认是后端性能，即服务端性能，也就是对服务端接口做压测如果是对一个接口（单场景）压测，且这个接口内部不会再去请求其它接口，那么tps=qps，否则，tps≠qps如果是对多个接口（混合场景）压测，不加事务控制器，jmeter会统计每个接口的tps，而混合场景是要测试这个场景的tps，显然这样得不到混合场景的tps，所以，要加了事物控制器，结果才是整个场景的tps</code></pre><p><strong>找到平衡点</strong></p><p>1.尽可能多的做不同并发数下的压测，记录下响应时间（1s以内）和最大tps，当然，服务器端，各个服务器的资源利用率在可接受范围内（每个公司不一样，我们是90%以内）；</p><p>2.然后根据获取到的不同并发下的指标数据（并发数、tps、响应时间），画出上图，关注右侧的交点，即tps下降的地方和响应时间的交点，这个点的tps最大，如果响应时间在1s以内，此时并发数也是比较大的，这个点就可以认为是三个指标都不错的平衡点（当然，我这里把tps放在第一位优先考虑了，这个就看大家最在乎哪个指标了，排个优先级）；如果响应时间大于1s，最佳平衡点就往左找，找到响应时间为1秒的点，此时对应的tps和并发值，就是最佳平衡点。总之，测试采样越多，获取的平衡点就越准确</p><p>参考：<a href="https://mp.weixin.qq.com/s/p_3C7e65v7mwfth3tHUB9A" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/p_3C7e65v7mwfth3tHUB9A</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>接口测试</title>
      <link href="/2019/09/26/%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95/"/>
      <url>/2019/09/26/%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<p><strong>接口测试</strong></p><ul><li><p>业务功能测试</p><p>  正常场景</p><p> 异常场景：重复提交，库存不足,风控失败</p></li><li><p>边界值测试</p><p>  输入/输出参数边界值测试：必选参数、可选参数、无，null，特殊字符<br>参数的顺序，个数，类型，取值范围，字符串长短</p></li><li><p>输入参数组合测试</p></li><li><p>性能测试</p><p>  响应时间、吞吐量。。</p></li><li><p>安全性测试</p><p>  敏感信息是否加密、SQL注入</p></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>面试准备</title>
      <link href="/2019/09/24/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/"/>
      <url>/2019/09/24/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/</url>
      
        <content type="html"><![CDATA[<ul><li><p>*<em>HTTP  *</em>  </p><p>  8种方法 GET POST DELETE PUT<br>HEAD  OPTIONS TRACE CONNECT </p><ol><li>基于TCP/IP的应用层协议  </li><li>基于请求-响应的模式   由客户端发出请求，服务器接收请求后做出响应返回给客户端</li><li>无状态保存<br>对发送的状态不做持久化处理。</li></ol></li><li><p>排序算法</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">def bubbleSort(arr):</span><br><span class="line">    for i in range(1, len(arr)):</span><br><span class="line">        for j in range(0, len(arr)-i):</span><br><span class="line">            if arr[j] &gt; arr[j+1]:</span><br><span class="line">                arr[j], arr[j + 1] = arr[j + 1], arr[j]</span><br><span class="line">    return arr</span><br><span class="line">    </span><br><span class="line">def selectionSort(arr):</span><br><span class="line">    for i in range(len(arr) - 1):</span><br><span class="line">        # 记录最小数的索引</span><br><span class="line">        minIndex = i</span><br><span class="line">        for j in range(i + 1, len(arr)):</span><br><span class="line">            if arr[j] &lt; arr[minIndex]:</span><br><span class="line">                minIndex = j</span><br><span class="line">        # i 不是最小数时，将 i 和最小数进行交换</span><br><span class="line">        if i != minIndex:</span><br><span class="line">            arr[i], arr[minIndex] = arr[minIndex], arr[i]</span><br><span class="line">    return arr</span><br><span class="line"></span><br><span class="line">def insertionSort(arr):</span><br><span class="line">    for i in range(len(arr)):</span><br><span class="line">        preIndex = i-1</span><br><span class="line">        current = arr[i]</span><br><span class="line">        while preIndex &gt;= 0 and arr[preIndex] &gt; current:</span><br><span class="line">            arr[preIndex+1] = arr[preIndex]</span><br><span class="line">            preIndex-=1</span><br><span class="line">        arr[preIndex+1] = current</span><br><span class="line">    return arr</span><br><span class="line">    </span><br><span class="line">#快速排序复杂度nlog(n) 参考：https://blog.csdn.net/weixin_43250623/article/details/88931925    </span><br><span class="line">def quick_sort(li, start, end):</span><br><span class="line">    i=start</span><br><span class="line">    j=end</span><br><span class="line">    pivot=li[start]</span><br><span class="line">    if start&gt;=end:#注意结束条件</span><br><span class="line">        return</span><br><span class="line">    while(i&lt;j):</span><br><span class="line">         print(li,i,j)</span><br><span class="line">         while i&lt;j and li[i]&lt;pivot:#如果加等号pivot值就不换了</span><br><span class="line">             i+=1</span><br><span class="line">         li[j]=li[i]</span><br><span class="line">         while i&lt;j and li[j]&gt;=pivot:#必须加等号，不然遇到等于的情况，不往下走了</span><br><span class="line">             j-=1</span><br><span class="line">         li[i]=li[j]</span><br><span class="line">    li[i]=pivot</span><br><span class="line">    quick_sort(li, start, i-1)</span><br><span class="line">    quick_sort(li, i+1, end)</span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    alist = [54, 26, 93, 17, 77, 31, 44, 55, 20]</span><br><span class="line">    quick_sort(alist, 0, len(alist) - 1)</span><br><span class="line">    print(alist)</span><br></pre></td></tr></table></figure><p>找出字符串中所有回文：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">str = &quot;casacbc&quot;</span><br><span class="line">li=[]</span><br><span class="line">i = 1  </span><br><span class="line">while (i &lt; len(str)) :</span><br><span class="line">    for start in range(i+1):</span><br><span class="line">        str1 = str[start: i+1]</span><br><span class="line">        if str1 == str1[::-1] and len(str1)&gt;1:</span><br><span class="line">            li.append(str1)</span><br><span class="line">    i += 1</span><br><span class="line">print(li)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>TensorFlow实践</title>
      <link href="/2019/09/24/TensorFlow%E5%AE%9E%E8%B7%B5/"/>
      <url>/2019/09/24/TensorFlow%E5%AE%9E%E8%B7%B5/</url>
      
        <content type="html"><![CDATA[<ol><li>安装 TensorFlow<br>系统版本：mac 10.12.6 python版本：2.7<br>安装指南：TensorFlow中文社区<br><a href="http://www.tensorfly.cn/tfdoc/get_started/os_setup.html#virtualenv_install" target="_blank" rel="noopener">http://www.tensorfly.cn/tfdoc/get_started/os_setup.html#virtualenv_install</a><br>1）尝试了使用直接安装\homebrew，都会提示错误：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">There was a problem confirming the ssl certificate: [SSL: TLSV1_ALERT_PROTOCOL_VERSION] tlsv1 alert protocol version (_ssl.c:590) - skipping</span><br></pre></td></tr></table></figure><p>说是因为python社区已不支持TLS version 1.0 &amp; 1.1，可以通过升级pip实现，但是升级pip还会由于这个问题不能成功，后放弃。但是本机是Python2.7不愿因为安装这个升级python版本，毕竟是几个电脑里唯一一个2.x的版本，希望可以保留。<br>2）使用docker安装<br>参考：<br><a href="https://blog.csdn.net/qq_35624642/article/details/82910641" target="_blank" rel="noopener">https://blog.csdn.net/qq_35624642/article/details/82910641</a><br>报错：<br><img src="https://img-blog.csdnimg.cn/20190322173316121.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N1cGVyX2NoZW5seQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>于是试图更改用户名和用户组，查阅各种资料，mac操作用户和用户组跟linux不一样，使用dscl命令<a href="https://www.4455q.com/tech/mac-dscl-user-group-create-delete-append.html" target="_blank" rel="noopener">https://www.4455q.com/tech/mac-dscl-user-group-create-delete-append.html</a><br>查到用户名和用户组id后，使用后：<br><img src="https://img-blog.csdnimg.cn/20190322173457617.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N1cGVyX2NoZW5seQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>查看版本和安装路径<br>import tensorflow as tf</p><p>tf.<strong>version</strong></p><p>查询tensorflow安装路径为:</p><p>tf.<strong>path</strong></p><hr><p>docker打开容器运行tensorflow镜像：<br>    <strong>docker run –name xiaolei-tensortflow -it -p 8888:8888 -v ~/tensorflow:/notebooks/data  tensorflow/tensorflow</strong></p><p>docker run 运行镜像，<br>–name 为容器创建别名，<br>-it 保留命令行运行(之后可以输入命令)<br>-p 8888:8888 将本地的8888端口 <a href="http://localhost:8888/" target="_blank" rel="noopener">http://localhost:8888/</a> 映射（对应前面的端口），<br>-v <del>/tensorflow:/notebooks/data 将本地的</del>/tensorflow文件夹挂载到新建容器的/notebooks/data下（这样可是实现本地文件和docker文件互通）<br>tensorflow/tensorflow 为指定的镜像，默认标签为latest（即tensorflow/tensorflow:latest）</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>python读取文件的几种方式</title>
      <link href="/2019/09/24/python%E8%AF%BB%E5%8F%96%E6%96%87%E4%BB%B6%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/"/>
      <url>/2019/09/24/python%E8%AF%BB%E5%8F%96%E6%96%87%E4%BB%B6%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>1.python读取文件的几种方式</p><p><strong>read_csv 从文件，url，文件型对象中加载带分隔符的数据。默认分隔符为逗号<br>read_table 从文件，url，文件型对象中加载带分隔符的数据。默认分隔符为制表符（“\t”）<br>read_fwf 读取定宽列格式数据（也就是没有分隔符）<br>read_cliboard 读取剪切板中的数据，可以看做read_table的剪切板。在将网页转换为表格时很有用<br>np.loadtxt()用于从文本加载数据。常用：loadtxt(fname,  delimiter=None)</strong></p><p>2.pandas.read_csv参数整理</p><p>读取CSV（逗号分割）文件到DataFrame<br>也支持文件的部分导入和选择迭代<br>更多帮助参见：<a href="http://pandas.pydata.org/pandas-docs/stable/io.html" target="_blank" rel="noopener">http://pandas.pydata.org/pandas-docs/stable/io.html</a><br>参数：<br>filepath_or_buffer : str，pathlib。str, pathlib.Path, py._path.local.LocalPath or any object with a read() method (such as a file handle or StringIO)<br>可以是URL，可用URL类型包括：http, ftp, s3和文件。对于多文件正在准备中<br>本地文件读取实例：://localhost/path/to/table.csv</p><p>sep : str, default ‘,’<br>指定分隔符。如果不指定参数，则会尝试使用逗号分隔。分隔符长于一个字符并且不是‘\s+’,将使用python的语法分析器。并且忽略数据中的逗号。正则表达式例子：’\r\t’</p><p>delimiter : str, default None<br>定界符，备选分隔符（如果指定该参数，则sep参数失效）</p><p>delim_whitespace : boolean, default False.<br>指定空格(例如’ ‘或者’ ‘)是否作为分隔符使用，等效于设定sep=’\s+’。如果这个参数设定为Ture那么delimiter 参数失效。<br>在新版本0.18.1支持</p><p>header : int or list of ints, default ‘infer’<br>指定行数用来作为列名，数据开始行数。如果文件中没有列名，则默认为0，否则设置为None。如果明确设定header=0 就会替换掉原来存在列名。header参数可以是一个list例如：[0,1,3]，这个list表示将文件中的这些行作为列标题（意味着每一列有多个标题），介于中间的行将被忽略掉（例如本例中的2；本例中的数据1,2,4行将被作为多级标题出现，第3行数据将被丢弃，dataframe的数据从第5行开始。）。<br>注意：如果skip_blank_lines=True 那么header参数忽略注释行和空行，所以header=0表示第一行数据而不是文件的第一行。</p><p>names : array-like, default None<br>用于结果的列名列表，如果数据文件中没有列标题行，就需要执行header=None。默认列表中不能出现重复，除非设定参数mangle_dupe_cols=True。</p><p>index_col : int or sequence or False, default None<br>用作行索引的列编号或者列名，如果给定一个序列则有多个行索引。<br>如果文件不规则，行尾有分隔符，则可以设定index_col=False 来是的pandas不适用第一列作为行索引。</p><p>usecols : array-like, default None<br>返回一个数据子集，该列表中的值必须可以对应到文件中的位置（数字可以对应到指定的列）或者是字符传为文件中的列名。例如：usecols有效参数可能是 [0,1,2]或者是 [‘foo’, ‘bar’, ‘baz’]。使用这个参数可以加快加载速度并降低内存消耗。</p><p>as_recarray : boolean, default False<br>不赞成使用：该参数会在未来版本移除。请使用pd.read_csv(…).to_records()替代。<br>返回一个Numpy的recarray来替代DataFrame。如果该参数设定为True。将会优先squeeze参数使用。并且行索引将不再可用，索引列也将被忽略。</p><p>squeeze : boolean, default False<br>如果文件值包含一列，则返回一个Series</p><p>prefix : str, default None<br>在没有列标题时，给列添加前缀。例如：添加‘X’ 成为 X0, X1, …</p><p>mangle_dupe_cols : boolean, default True<br>重复的列，将‘X’…’X’表示为‘X.0’…’X.N’。如果设定为false则会将所有重名列覆盖。</p><p>dtype : Type name or dict of column -&gt; type, default None<br>每列数据的数据类型。例如 {‘a’: np.float64, ‘b’: np.int32}</p><p>engine : {‘c’, ‘python’}, optional<br>Parser engine to use. The C engine is faster while the python engine is currently more feature-complete.<br>使用的分析引擎。可以选择C或者是python。C引擎快但是Python引擎功能更加完备。</p><p>converters : dict, default None<br>列转换函数的字典。key可以是列名或者列的序号。</p><p>true_values : list, default None<br>Values to consider as True</p><p>false_values : list, default None<br>Values to consider as False</p><p>skipinitialspace : boolean, default False<br>忽略分隔符后的空白（默认为False，即不忽略）.</p><p>skiprows : list-like or integer, default None<br>需要忽略的行数（从文件开始处算起），或需要跳过的行号列表（从0开始）。</p><p>skipfooter : int, default 0<br>从文件尾部开始忽略。 (c引擎不支持)</p><p>skip_footer : int, default 0<br>不推荐使用：建议使用skipfooter ，功能一样。</p><p>nrows : int, default None<br>需要读取的行数（从文件头开始算起）。</p><p>na_values : scalar, str, list-like, or dict, default None<br>一组用于替换NA/NaN的值。如果传参，需要制定特定列的空值。默认为‘1.#IND’, ‘1.#QNAN’, ‘N/A’, ‘NA’, ‘NULL’, ‘NaN’, ‘nan’`.</p><p>keep_default_na : bool, default True<br>如果指定na_values参数，并且keep_default_na=False，那么默认的NaN将被覆盖，否则添加。</p><p>na_filter : boolean, default True<br>是否检查丢失值（空字符串或者是空值）。对于大文件来说数据集中没有空值，设定na_filter=False可以提升读取速度。</p><p>verbose : boolean, default False<br>是否打印各种解析器的输出信息，例如：“非数值列中缺失值的数量”等。</p><p>skip_blank_lines : boolean, default True<br>如果为True，则跳过空行；否则记为NaN。</p><p>parse_dates : boolean or list of ints or names or list of lists or dict, default False<br>boolean. True -&gt; 解析索引<br>list of ints or names. e.g. If [1, 2, 3] -&gt; 解析1,2,3列的值作为独立的日期列；<br>list of lists. e.g. If [[1, 3]] -&gt; 合并1,3列作为一个日期列使用<br>dict, e.g. {‘foo’ : [1, 3]} -&gt; 将1,3列合并，并给合并后的列起名为”foo”</p><p>infer_datetime_format : boolean, default False<br>如果设定为True并且parse_dates 可用，那么pandas将尝试转换为日期类型，如果可以转换，转换方法并解析。在某些情况下会快5~10倍。</p><p>keep_date_col : boolean, default False<br>如果连接多列解析日期，则保持参与连接的列。默认为False。</p><p>date_parser : function, default None<br>用于解析日期的函数，默认使用dateutil.parser.parser来做转换。Pandas尝试使用三种不同的方式解析，如果遇到问题则使用下一种方式。<br>1.使用一个或者多个arrays（由parse_dates指定）作为参数；<br>2.连接指定多列字符串作为一个列作为参数；<br>3.每行调用一次date_parser函数来解析一个或者多个字符串（由parse_dates指定）作为参数。</p><p>dayfirst : boolean, default False<br>DD/MM格式的日期类型</p><p>iterator : boolean, default False<br>返回一个TextFileReader 对象，以便逐块处理文件。</p><p>chunksize : int, default None<br>文件块的大小， See IO Tools docs for more informationon iterator and chunksize.</p><p>compression : {‘infer’, ‘gzip’, ‘bz2’, ‘zip’, ‘xz’, None}, default ‘infer’<br>直接使用磁盘上的压缩文件。如果使用infer参数，则使用 gzip, bz2, zip或者解压文件名中以‘.gz’, ‘.bz2’, ‘.zip’, or ‘xz’这些为后缀的文件，否则不解压。如果使用zip，那么ZIP包中国必须只包含一个文件。设置为None则不解压。<br>新版本0.18.1版本支持zip和xz解压</p><p>thousands : str, default None<br>千分位分割符，如“，”或者“.”</p><p>decimal : str, default ‘.’<br>字符中的小数点 (例如：欧洲数据使用’，‘).</p><p>float_precision : string, default None<br>Specifies which converter the C engine should use for floating-point values. The options are None for the ordinary converter, high for the high-precision converter, and round_trip for the round-trip converter.<br>指定</p><p>lineterminator : str (length 1), default None<br>行分割符，只在C解析器下使用。</p><p>quotechar : str (length 1), optional<br>引号，用作标识开始和解释的字符，引号内的分割符将被忽略。</p><p>quoting : int or csv.QUOTE_* instance, default 0<br>控制csv中的引号常量。可选 QUOTE_MINIMAL (0), QUOTE_ALL (1), QUOTE_NONNUMERIC (2) or QUOTE_NONE (3)</p><p>doublequote : boolean, default True<br>双引号，当单引号已经被定义，并且quoting 参数不是QUOTE_NONE的时候，使用双引号表示引号内的元素作为一个元素使用。</p><p>escapechar : str (length 1), default None<br>当quoting 为QUOTE_NONE时，指定一个字符使的不受分隔符限值。</p><p>comment : str, default None<br>标识着多余的行不被解析。如果该字符出现在行首，这一行将被全部忽略。这个参数只能是一个字符，空行（就像skip_blank_lines=True）注释行被header和skiprows忽略一样。例如如果指定comment=’#’ 解析‘#empty\na,b,c\n1,2,3’ 以header=0 那么返回结果将是以’a,b,c’作为header。</p><p>encoding : str, default None<br>指定字符集类型，通常指定为’utf-8’. List of Python standard encodings</p><p>dialect : str or csv.Dialect instance, default None<br>如果没有指定特定的语言，如果sep大于一个字符则忽略。具体查看csv.Dialect 文档</p><p>tupleize_cols : boolean, default False<br>Leave a list of tuples on columns as is (default is to convert to a Multi Index on the columns)</p><p>error_bad_lines : boolean, default True<br>如果一行包含太多的列，那么默认不会返回DataFrame ，如果设置成false，那么会将改行剔除（只能在C解析器下使用）。</p><p>warn_bad_lines : boolean, default True<br>如果error_bad_lines =False，并且warn_bad_lines =True 那么所有的“bad lines”将会被输出（只能在C解析器下使用）。</p><p>low_memory : boolean, default True<br>分块加载到内存，再低内存消耗中解析。但是可能出现类型混淆。确保类型不被混淆需要设置为False。或者使用dtype 参数指定类型。注意使用chunksize 或者iterator 参数分块读入会将整个文件读入到一个Dataframe，而忽略类型（只能在C解析器中有效）</p><p>buffer_lines : int, default None<br>不推荐使用，这个参数将会在未来版本移除，因为他的值在解析器中不推荐使用</p><p>compact_ints : boolean, default False<br>不推荐使用，这个参数将会在未来版本移除<br>如果设置compact_ints=True ，那么任何有整数类型构成的列将被按照最小的整数类型存储，是否有符号将取决于use_unsigned 参数</p><p>use_unsigned : boolean, default False<br>不推荐使用：这个参数将会在未来版本移除<br>如果整数列被压缩(i.e. compact_ints=True)，指定被压缩的列是有符号还是无符号的。<br>memory_map : boolean, default False<br>如果使用的文件在内存内，那么直接map文件使用。使用这种方式可以避免文件再次进行IO操作。</p><p>参考博文：<br><a href="https://www.cnblogs.com/datablog/p/6127000.html" target="_blank" rel="noopener">https://www.cnblogs.com/datablog/p/6127000.html</a><br><a href="https://www.cnblogs.com/heitaoq/p/7994842.html" target="_blank" rel="noopener">https://www.cnblogs.com/heitaoq/p/7994842.html</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>使用nc命令传输数据</title>
      <link href="/2019/09/24/%E4%BD%BF%E7%94%A8nc%E5%91%BD%E4%BB%A4%E4%BC%A0%E8%BE%93%E6%95%B0%E6%8D%AE/"/>
      <url>/2019/09/24/%E4%BD%BF%E7%94%A8nc%E5%91%BD%E4%BB%A4%E4%BC%A0%E8%BE%93%E6%95%B0%E6%8D%AE/</url>
      
        <content type="html"><![CDATA[<p>原文：<a href="https://www.cnblogs.com/nmap/p/6148306.html" target="_blank" rel="noopener">https://www.cnblogs.com/nmap/p/6148306.html</a><br>    nc是netcat的简写，有着网络界的瑞士军刀美誉。因为它短小精悍、功能实用，被设计为一个简单、可靠的网络工具</p><h2 id="使用ncp命令传送数据"><a href="#使用ncp命令传送数据" class="headerlink" title="使用ncp命令传送数据"></a>使用ncp命令传送数据</h2><p>需注意操作次序，receiver先侦听端口，sender向receiver所在机器的该端口发送数据。<br>步骤一：在接收端B侦听端口数据，并将数据写到file里<br>nc -l port &gt;file<br><img src="https://img-blog.csdnimg.cn/20190128143512804.png" alt="在接收端侦听端口数据，并将数据写到file里"><br>步骤二：在发送端A往接收端B的指定端口发送数据，把文件发送过去<br>nc ip port &lt; somefile<br>nc 10.0.1.162 9995 &lt; somefile<br><img src="https://img-blog.csdnimg.cn/20190128143444169.png" alt="在这里插入图片描述"></p><h2 id="安装nc"><a href="#安装nc" class="headerlink" title="安装nc"></a>安装nc</h2><p>1、先将已安装的nc删除</p><p>yum erase nc</p><p>2.下载较低版本的nc的.rpm文件</p><pre><code>wget   http://vault.centos.org/6.6/os/x86_64/Packages/nc-1.84-22.el6.x86_64.rpm</code></pre><p>3.安装.rpm文件</p><p>rpm   -iUv    nc-1.84-22.el6.x86_64.rpm</p><p>原文：<a href="https://blog.csdn.net/yctccg/article/details/52218055" target="_blank" rel="noopener">https://blog.csdn.net/yctccg/article/details/52218055</a> </p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>AI关键词</title>
      <link href="/2019/09/24/AI%E5%85%B3%E9%94%AE%E8%AF%8D/"/>
      <url>/2019/09/24/AI%E5%85%B3%E9%94%AE%E8%AF%8D/</url>
      
        <content type="html"><![CDATA[<p><strong>1. 常用名词缩写</strong><br>NLP：Natural Language Processing   自然语言处理<br>CNN:  Convolutional Neural Networks 卷积神经网络<br>LSTM:Long Short-Term Memory       长短期记忆网络<br>RNN:Recurrent Neural Network        循环神经网络<br>GPU:Graphics Processing Unit       图形处理器</p><p><strong>2.普遍的深度学习框架有：Tensorflow、Caffe、PyTorch、Theano、CNTK</strong><br>（1） Caffe：卷积神经网络框架，专注于卷积神经网络和图像处理，因为是基于C++语言，所以执行速度非常的快。</p><p>（2） PyTorch：动态computation graph！！！（笔者学习Tensorflow一段后，便会转学PyTorch试试看）</p><p>（3） Theano：因其定义复杂模型很容易，在研究中比较流行。</p><p>（4） CNTK：微软开发的，微软称其在语音和图像识别方面比其他框架更有优势。不过代码只支持C++.</p><p>（5）Tensorflow作为谷歌主持的开源项目，它的社区热度目前看来是旺盛的，而且现在也最为流行。听说，它是在谷歌总结了DistBelief的经验教训上形成的；它运行高效、可扩展性强，可以运行在手机、普通电脑、计算机群上。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>python3升级后不支持的2.x文件的操作</title>
      <link href="/2019/08/22/python3%E5%8D%87%E7%BA%A7%E5%90%8E%E4%B8%8D%E6%94%AF%E6%8C%81%E7%9A%842%E6%96%87%E4%BB%B6%E7%9A%84%E6%93%8D%E4%BD%9C/"/>
      <url>/2019/08/22/python3%E5%8D%87%E7%BA%A7%E5%90%8E%E4%B8%8D%E6%94%AF%E6%8C%81%E7%9A%842%E6%96%87%E4%BB%B6%E7%9A%84%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<ul><li><h5 id="range"><a href="#range" class="headerlink" title="range()"></a>range()</h5>Python3 range()函数返回的是一个<strong>可迭代对象（类型是对象）</strong>，而不是列表类型， 所以打印的时候不会打印列表。</li></ul><ul><li><h5 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h5></li></ul><p><strong>python 3.3.2报错：No module named ‘urllib2’ 解决方法</strong><br>在python3.3里面，用urllib.request代替urllib2<br> <strong>ImportError: No module named ‘ConfigParser</strong><br>from configparser import  ConfigParser#引用文件全部变成小写<br><strong>AttributeError: module ‘urllib’ has no attribute ‘quote’</strong><br>urllib.quote改成urllib.request.quote<br><strong>POST data should be bytes or an iterable of bytes. It cannot be of type str.</strong><br>  最后通过交流发现需要加在urlencode语句后加encode(encoding=’UTF8’)<br>同时，在输出时，再使用decode(“utf-8”)进行解码，往往更加能够取的理想的效果。</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> 1 from urllib import request</span><br><span class="line"> 2 from urllib import parse</span><br><span class="line"> 3 </span><br><span class="line"> 4 url = &quot;https://movie.douban.com/j/chart/top_list?type=11&amp;interval_id=100%3A90&amp;action=&quot;</span><br><span class="line"> 5 headers = &#123;&quot;User-Agent&quot;:&quot;Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.87 Safari/537.36&quot;&#125;</span><br><span class="line"> 6 formdata = &#123;</span><br><span class="line"> 7     &apos;start&apos;: &apos;0&apos;,</span><br><span class="line"> 8     &apos;limit&apos;: &apos;10&apos;</span><br><span class="line"> 9 &#125;</span><br><span class="line">10 </span><br><span class="line">11 data = parse.urlencode(formdata).encode(encoding=&quot;utf-8&quot;)</span><br><span class="line">12 req = request.Request(url=url,headers=headers)</span><br><span class="line">13 response = request.urlopen(req)</span><br><span class="line">14 print(response.read().decode(&quot;utf-8&quot;))</span><br></pre></td></tr></table></figure><p><strong>TypeError: Can‘t convert ‘bytes‘ object to str implicitly</strong><br>解决方法：使用字节码的decode()方法。</p><p>示例：</p><pre><code>str = ‘I am string‘byte = b‘ I am bytes‘s = str + byteprint(s)</code></pre><p>　　这时会报错：TypeError: Can‘t convert ‘bytes‘ object to str implicitly</p><p>解决方法：</p><pre><code>s = str + byte.decode()</code></pre><p><strong>python reload(sys)找不到，name ‘reload’ is not defined</strong><br>在3.x中已经被毙掉了被替换为</p><pre><code>import importlibimportlib.reload(sys) sys.setdefaultencoding(“utf-8”) 这种方式在3.x中被彻底遗</code></pre><p> <strong>关于 urllib.request.urlopen()的错误</strong><br> 这种错不常见，主要是由于我的文件名称含有http.py，这里应该是关键字敏感导致的错误。删除这个文件的子文件和修改文件名后就可以正常运行了！</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Python3内置函数</title>
      <link href="/2019/07/18/Python3%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0/"/>
      <url>/2019/07/18/Python3%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h3 id="1-内建模块collections"><a href="#1-内建模块collections" class="headerlink" title="1. 内建模块collections"></a>1. 内建模块collections</h3><p><strong>collections.Counter</strong>计数器，计算列表中每项出现的次数，并返回<strong>字典类型</strong>，其中元素作为key，其计数作为value。</p><p><img src="https://img-blog.csdnimg.cn/20190326145102507.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N1cGVyX2NoZW5seQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>当所访问的键不存在时，返回0，而不是KeyError；否则返回它的计数。</p><p><img src="https://img-blog.csdnimg.cn/20190526121803806.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N1cGVyX2NoZW5seQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="2-sort-与-sorted-区别："><a href="#2-sort-与-sorted-区别：" class="headerlink" title="2. sort 与 sorted 区别："></a>2. sort 与 sorted 区别：</h3><ul><li><p>sort 是应用在 list 上的<strong>方法</strong>。  sorted 是<strong>函数</strong>，可以对所有可迭代的对象（比如字典）进行排序操作。</p><p><strong>sorted 语法：</strong><br>sorted(iterable, key=None, reverse=False)<br>如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">array = [&#123;&quot;age&quot;:20,&quot;name&quot;:&quot;a&quot;&#125;,&#123;&quot;age&quot;:25,&quot;name&quot;:&quot;b&quot;&#125;,&#123;&quot;age&quot;:10,&quot;name&quot;:&quot;c&quot;&#125;]</span><br><span class="line">array = sorted(array,key=lambda x:-x[&quot;age&quot;])</span><br><span class="line">#其中负号表示降序（默认升序），与reverse=True相同</span><br></pre></td></tr></table></figure><p>以上是使用关键词对元组进行的排序，lambda是隐函数固定格式；x标识列表中的一个元素，在这里标识一个元组，x可以任意起名。<br>也可以对<strong>set集合</strong>进行排序，返回列表类型。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;sorted(&#123;&apos;mm&apos;,&apos;dd&apos;,&apos;aa&apos;&#125;)</span><br><span class="line">&gt;&gt;&gt;[&apos;aa&apos;, &apos;dd&apos;, &apos;mm&apos;]</span><br></pre></td></tr></table></figure></li></ul><ul><li>list 的 sort 方法返回的是对已经存在的列表进行操作；<br>而内建函数 sorted 方法返回的是一个新的 list，而不是在原来的基础上进行的操作。</li></ul><h3 id="3-zip-和zip"><a href="#3-zip-和zip" class="headerlink" title="3. zip()和zip(*)"></a>3. zip()和zip(*)</h3><p>zip() 函数用于将可迭代的对象作为参数，将对象中对应的元素打包成一个个元组，然后返回由这些元组组成的列表。<br>zip 方法在 Python 2 和 Python 3 中的不同：在 Python 2.x zip() 返回的是一个列表。在3.x中返回的是一个对象，需要使用list将其转换为列表。<br>zip(*) 可理解为解压，返回二维矩阵式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;a = [1,2,3]</span><br><span class="line">&gt;&gt;&gt; b = [4,5,6]</span><br><span class="line">&gt;&gt;&gt; c = [4,5,6,7,8]</span><br><span class="line">&gt;&gt;&gt; zipped = zip(a,b)     # 返回一个对象</span><br><span class="line">&gt;&gt;&gt; zipped</span><br><span class="line">&lt;zip object at 0x103abc288&gt;</span><br><span class="line">&gt;&gt;&gt; list(zipped)  # list() 转换为列表</span><br><span class="line">[(1, 4), (2, 5), (3, 6)]</span><br><span class="line">&gt;&gt;&gt; list(zip(a,c))              # 元素个数与最短的列表一致</span><br><span class="line">[(1, 4), (2, 5), (3, 6)]</span><br><span class="line"> </span><br><span class="line">&gt;&gt;&gt; a1, a2 = zip(*zip(a,b)) # 与 zip 相反，zip(*) 可理解为解压，返回二维矩阵式</span><br><span class="line">&gt;&gt;&gt; list(a1)</span><br><span class="line">[1, 2, 3]</span><br><span class="line">&gt;&gt;&gt; list(a2)</span><br><span class="line">[4, 5, 6]</span><br></pre></td></tr></table></figure><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ul><li>数值的除法包含两个运算符：/ 返回一个浮点数，// 返回一个整数。</li><li>列表中元素是元组，可以这样遍历<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">  list=[(1,3),(2,4)]</span><br><span class="line">  for i ,j in list:</span><br><span class="line">      print (&quot;first:&quot;,i)</span><br><span class="line">      print(&quot;second&quot;,j)</span><br><span class="line">结果：</span><br><span class="line">first: 1</span><br><span class="line">second 3</span><br><span class="line">first: 2</span><br><span class="line">second 4</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>必知的linux命令</title>
      <link href="/2019/07/15/%E5%BF%85%E7%9F%A5%E7%9A%84linux%E5%91%BD%E4%BB%A4/"/>
      <url>/2019/07/15/%E5%BF%85%E7%9F%A5%E7%9A%84linux%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h4 id="Linux文件有四种时间"><a href="#Linux文件有四种时间" class="headerlink" title="Linux文件有四种时间:"></a>Linux文件有四种时间:</h4><pre><code># stat /etc/hostname //查看文件详细信息包括时间访问时间:atime，查看内容 修改时间:mtime，修改内容 改变时间:ctime，文件属性，比如权限删除时间:dtime，文件被删除的时间</code></pre><h4 id="文件类型"><a href="#文件类型" class="headerlink" title="文件类型"></a>文件类型</h4><p>   ls -l 文件名 //看第一个字符</p><pre><code>- 普通文件(文本文件，二进制文件，压缩文件，电影，图片。。。) d 目录文件(蓝色)b 设备文件(块设备)存储设备硬盘，U盘 /dev/sda, /dev/sda1c 设备文件(字符设备)打印机，终端 /dev/tty1, /dev/zeros 套接字文件p 管道文件l 链接文件(淡蓝色)</code></pre><h4 id="type-stat-file"><a href="#type-stat-file" class="headerlink" title="type stat file"></a>type stat file</h4><p>type        查看命令类型  -a查看所有<br>stat        查看文件详细信息<br>file        查看文件类型 </p><h5 id="cat命令"><a href="#cat命令" class="headerlink" title="cat命令"></a>cat命令</h5><pre><code>-n 显示行号-A 包括控制字符(换行符/制表符)linux $ Windows ^M$ 可通过其他方式转换成unix文件</code></pre><h5 id="cut命令"><a href="#cut命令" class="headerlink" title="cut命令"></a>cut命令</h5><pre><code>-b 以字节为单位分割-c以字符为单位分割-d 自定义分隔符-f与-d一起使用，指定哪一列</code></pre><p>  如：以冒号为分隔符，取第四列相当于awk -F: ‘{print $4}’</p><pre><code>cat /etc/passwd|cut -d: -f4</code></pre><h5 id="etc-passwd字段"><a href="#etc-passwd字段" class="headerlink" title="/etc/passwd字段"></a>/etc/passwd字段</h5><p>/etc/passwd中一行记录对应着一个用户，每行记录又被冒号(分隔为7个字段，其格式和具体含义如下：</p><pre><code>/etc/passwd 用户名:口令:用户标识号:组标识号:注释性描述:主目录:登录Shell# cat /etc/group组名：加密密码：组ID：所有属于该组的用户。</code></pre><h5 id="替换sed"><a href="#替换sed" class="headerlink" title="替换sed"></a>替换sed</h5><p>  替换掉每行<br>  第一个原字符串 sed -i ‘s/原字符串/新字符串’ filename</p><p>  替换掉所有的字符串 sed -i ‘s/原字符串/新字符串/g’ filename</p><pre><code>-i 的作用是直接作用于(修改)文件，而不加-i只是在终端打印结果 # 对每行匹配到的第一个字符串进行替换sed -i &apos;s/原字符串/新字符串/&apos; ab.txt # 对全局匹配上的所有字符串进行替换sed -i &apos;s/原字符串/新字符串/g&apos; ab.txt # 删除所有匹配到字符串的行sed -i &apos;/匹配字符串/d&apos;  ab.txt  # 特定字符串的行后插入新行sed -i &apos;/特定字符串/a 新行字符串&apos; ab.txt # 特定字符串的行前插入新行sed -i &apos;/特定字符串/i 新行字符串&apos; ab.txt# 把匹配行中的某个字符串替换为目标字符串sed -i &apos;/匹配字符串/s/源字符串/目标字符串/g&apos; ab.txt# 在文件ab.txt中的末行之后，添加byesed -i &apos;$a bye&apos; ab.txt   # 对于文件第3行，把匹配上的所有字符串进行替换sed -i &apos;3s/原字符串/新字符串/g&apos; ab.txt# 显示文件的第二行到最后一行sed -n &apos;2, $p&apos; ab.txt        </code></pre><p>原文链接：<a href="https://blog.csdn.net/yjk13703623757/article/details/79548450" target="_blank" rel="noopener">https://blog.csdn.net/yjk13703623757/article/details/79548450</a></p><h5 id="awk-‘-print-1-’-fortest-php-sort-uniq-c-wc-l"><a href="#awk-‘-print-1-’-fortest-php-sort-uniq-c-wc-l" class="headerlink" title="awk ‘{print $1}’ fortest.php |sort|uniq -c|wc -l"></a>awk ‘{print $1}’ fortest.php |sort|uniq -c|wc -l</h5><pre><code>sort命令排序（默认安卓首字母ASCII排序）  uniq常与sort结合使用，去除重复行 -c 显示重复个数  </code></pre><h5 id="wc-命令"><a href="#wc-命令" class="headerlink" title="wc 命令"></a><strong>wc 命令</strong></h5><p>计算行数、单词数、字节数。只有三个参数：</p><p>  -l 只显示行数（lines）<br>  -w 只显示单词数(words)<br>  -c 只显示字节数(chars)</p><h5 id="查看网络连接状态-路由表"><a href="#查看网络连接状态-路由表" class="headerlink" title="查看网络连接状态(路由表)"></a>查看网络连接状态(路由表)</h5><p> 可以查端口号，而ps无端口号</p><pre><code>netstat -nlap |grep -i 6379</code></pre>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-n 拒绝显示别名，能显示数字的全部转化成数字。</span><br><span class="line">-l 仅列出有在 Listen (监听) 的服務状态</span><br><span class="line">-a (all)显示所有选项，默认不显示LISTEN相关</span><br><span class="line">-p 显示建立相关链接的程序名</span><br></pre></td></tr></table></figure><p>  nlap基本能满足一般的查找需求，记住这个组合即可 </p><h5 id="查看进程-ps"><a href="#查看进程-ps" class="headerlink" title="查看进程 ps"></a>查看进程 ps</h5><p>常用两个组合：</p><pre><code>ps -ef |grep -v grep |grep tomcatps -aux类似于lsof -i :8080       #lsof (list openfiles)  相当于 netstat  nlap |grep -i 8080</code></pre><ul><li><p>Linux 下命令有哪几种可使用的通配符？分别代表什么含义?</p><pre><code>?可替代单个字符。*可替代任意多个字符。方括号[charset]可替代 charset 集中的任何单个字符，如[a-z]，[abABC]</code></pre><p><img src="%5Cimages%5Cpasted-68.png" alt="upload successful"></p><h5 id="tar命令"><a href="#tar命令" class="headerlink" title="tar命令"></a>tar命令</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tar -czvf  test.tar.gz a.c  #将a.c文件压缩成test.tar.gz</span><br><span class="line">tar  -xzvf test.tar.gz      #解压缩</span><br></pre></td></tr></table></figure></li></ul><p>参数说明：<br>-t 查看内容<br>-c 建立压缩文档<br>-v 显示所有过程<br>-f 后面接要处理的文件,最后用<br>-x 解压缩<br>-z 有gzip属性  </p><h5 id="vim-常用命令"><a href="#vim-常用命令" class="headerlink" title="vim 常用命令"></a>vim 常用命令</h5><pre><code>- u撤销  - vim -b 用来查看二进制比如结束符 - :set num显示行号 ;  - :7,10d 清除7到10行的内容；- 行定位：G 定位到最后一行；      1G定位到第一行；      17G定位到第17行；- 复制粘贴：  yy 复制当前行  p 粘贴- 字符替换命令：    :s/old/new/g ==:%s/old/new/g 替换所有</code></pre><ul><li><p>|：   管道命令  如 cat note.conf |more<br>  其中Shift + PageUp 向上查看</p></li><li><p>grep：管道配合grep很好组合 如cat -n note.conf | grep head   -n显示行号    </p><ul><li>grep -i 不区分大小写</li></ul></li><li><p>ls ：  -a 所有（all）、-l 列显示(list)、ls -h（大小GB、KB显示,默认是按照字节显示大小的）、<br>ls -l=ll ll -ht  t标识按照时间倒序</p><h5 id="查找命令："><a href="#查找命令：" class="headerlink" title="查找命令："></a>查找命令：</h5><p>  find:</p><pre><code>-name 例：find /home -name  h?llo;   -size find /home -size +10k</code></pre><p> whereis: 二进制文件，说明文档，源文件等<br> which :可执行文件</p></li><li><p>重定向命令 &gt;  </p><ul><li>ls -l /etc  &gt; /home/myback.txt  (覆盖重定向)把显示的结果覆盖到/home/myback.txt中去   </li><li>ls -l /etc/  &gt;&gt;  /home/myback.txt   追加重定向</li></ul></li><li><p>清空文件三种方法</p><ol><li>》 log.txt   清空log.txt文件(单箭头)  </li><li>echo “” &gt;log.txt  </li><li>cat /dev/null &gt;log.txt</li></ol></li><li><p>创建用户以及查看当前用户</p><p>useradd redis<br>passwd  redis<br>/etc/group 查看所有组<br>/etc/shadow和/etc/passwd查看所有用户</p></li><li><p>查看内存使用情况</p><p>free -m(m为MB,g为GB)<br>查看磁盘使用情况(disk free)：df -lh<br>查看当前目录下所有文件大小  du -sh *   </p></li></ul><h5 id="chown-修改所属用户"><a href="#chown-修改所属用户" class="headerlink" title="chown  修改所属用户"></a>chown  修改所属用户</h5><p>chown -R tester:tester /var/www</p><h5 id="chmod-权限修改两种语法"><a href="#chmod-权限修改两种语法" class="headerlink" title="chmod  权限修改两种语法"></a>chmod  权限修改两种语法</h5><h6 id="一种是chmod-ugo-r-file-这种"><a href="#一种是chmod-ugo-r-file-这种" class="headerlink" title="一种是chmod ugo+r file 这种"></a>一种是chmod ugo+r file 这种</h6><pre><code>命令格式：chmod {u|g|o|a}{+|-|=}{r|w|x} filename  u (user)   表示用户本人。  g (group)  表示同组用户。  o (oher)   表示其他用户。  a (all)    表示所有用户。  +          用于给予指定用户的许可权限。  -          用于取消指定用户的许可权限。  =          将所许可的权限赋给文件。  r (read)   读许可，表示可以拷贝该文件或目录的内容。  w (write)  写许可，表示可以修改该文件或目录的内容。  x (execute)执行许可，表示可以执行该文件或进入目录。</code></pre><p>  例如：   </p><pre><code>      # chmod a+rx filename         让所有用户可以读和执行文件filename。       # chmod go-rx filename         取消同组和其他用户的读和执行文件filename的权限。       # chmod 741 filename         让本人可读写执行、同组用户可读、其他用户可执行文件filename。       # chmod -R 755 /home/oracle 递归更改目录权限，本人可读写执行、同组用户可读可执行、其他用户可读可执行 </code></pre><h6 id="一种是chmod-abc-file-其中abc是数字"><a href="#一种是chmod-abc-file-其中abc是数字" class="headerlink" title="一种是chmod abc file(其中abc是数字)"></a>一种是chmod abc file(其中abc是数字)</h6><p>   具体来说，abc分别表示User、Group、及Other的权限。其中r=4,w=2,x=1</p><pre><code>- 若要rwx属性则4+2+1=7- 若要rw-属性则4+2=6- 若要r-x属性则4+1=5- 若用chmod 4755（或755） filename可使其具有root权限</code></pre><ul><li>cp<br>cp -r 原文件  新文件名<br>-r目录复制</li><li>mv<br>对于当前路径下文件重命名，非当前路径移动</li><li>查看linux内核<br>结合使用uname -a 查看linux内核<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@tv6-hotelqa-newhotel-17 ~]# cat /etc/issue</span><br><span class="line">CentOS release 6.4 (Final</span><br></pre></td></tr></table></figure></li></ul><h5 id="ln-软连接和硬链接"><a href="#ln-软连接和硬链接" class="headerlink" title="ln 软连接和硬链接"></a>ln 软连接和硬链接</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">第一，ln命令会保持每一处链接文件的同步性，也就是说，不论你改动了哪一处，其它的文件都会发生相同的变化；</span><br><span class="line">第二，ln的链接又软链接 和硬链接两种，</span><br><span class="line"> 软链接就是ln -s src  dst,它只会在你选定的位置上生成一个文件的镜像，不会占用磁盘空间，</span><br><span class="line"> 硬链接ln src  dst,没有参数-s, 它会在你选定的位置上生成一个和源文件大小相同的文件，无论是软链接还是硬链接，文件都保持同步变化。 </span><br><span class="line">第三，指向一个文件的所有 硬链接都删掉的话文件的内容才会被删掉</span><br><span class="line">  软链接只要删掉了源链接文件，软链接也就失效了</span><br></pre></td></tr></table></figure><p>   若失败可添加-f参数即ln -sf强行添加试试</p><h5 id="查看linux系统版本"><a href="#查看linux系统版本" class="headerlink" title="查看linux系统版本"></a><strong>查看linux系统版本</strong></h5><p> cat /etc/issue  或者 uname -a</p><p><img src="%5Cimages%5Cpasted-65.png" alt="upload successful"></p><h5 id="三大操作系统关系"><a href="#三大操作系统关系" class="headerlink" title="三大操作系统关系"></a>三大操作系统关系</h5><p><img src="%5Cimages%5Cpasted-66.png" alt="upload successful"></p><ul><li><p>一般来说著名的<strong>linux系统</strong>基本上分两大类：</p><pre><code>1.RedHat系列：Redhat、Centos、Fedora等 2.Debian系列：Debian、Ubuntu等 RedHat 系列 1 常见的安装包格式 rpm包,安装rpm包的命令是“rpm -参数” 2 包管理工具 yum 3 支持tar包 Debian系列 1 常见的安装包格式 deb包,安装deb包的命令是“dpkg -参数” 2 包管理工具 apt-get 3支持tar包</code></pre></li></ul><h5 id="Ubuntu-命令行-访问网页"><a href="#Ubuntu-命令行-访问网页" class="headerlink" title="Ubuntu 命令行 访问网页"></a>Ubuntu 命令行 访问网页</h5><pre><code>apt-get install w3mw3m https://blog.csdn.net/x_xx_xxx_xxxx/article/details/92574331</code></pre><h5 id="linux上安装软件"><a href="#linux上安装软件" class="headerlink" title="linux上安装软件"></a>linux上安装软件</h5><pre><code>1）解压缩，如tar.gz格式的解压缩命令为tar -xzvf soft.tar.gz 2） 执行“./configure”命令为编译做好准备；3） 执行“make”命令进行软件编译；4） 执行“make install”完成安装；5） 执行“make clean”删除安装时产生的临时文件。</code></pre><ul><li><p><strong>安装Yum</strong><br>找了很多资料，什么简洁办法都不管用，还是需要下载很多依赖包安装才行。参考如下<br><a href="https://blog.csdn.net/zgege/article/details/82315110" target="_blank" rel="noopener">https://blog.csdn.net/zgege/article/details/82315110</a><br>但是由于yum的版本与当前python的版本不一致会报错？</p><p>  There was a problem importing one of the Python modules required to run yum. The error leading to this problem was:</p><pre><code>No module named yum</code></pre><p>  Please install a package which provides this module, or verify that the module is installed correctly.</p><p>  It’s possible that the <strong>above module doesn’t match the current version of Python</strong>, which is:<br>  。。。<br>解决办法：更改配置python引用指向低版本（更改yum配置，因为其要用到python2才能执行，否则会导致yum不能正常使用）。<a href="http://www.cnblogs.com/blueel/archive/2012/08/19/2646127.html" target="_blank" rel="noopener">http://www.cnblogs.com/blueel/archive/2012/08/19/2646127.html</a></p><p>  <code>vi /usr/bin/yum</code><br>  把#! /usr/bin/python修改为#! /usr/bin/python2</p></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Django站点admin</title>
      <link href="/2019/07/15/Django-admin/"/>
      <url>/2019/07/15/Django-admin/</url>
      
        <content type="html"><![CDATA[<h4 id="站点配置"><a href="#站点配置" class="headerlink" title="站点配置:"></a>站点配置:</h4><ol><li><p>配置admin应用，默认已添加</p></li><li><p>创建管理员用户<br>python manage.py createsuperuser</p></li><li><p>汉化：LANGUAGE_CODE = ‘zh-Hans’<br>TIME_ZONE = ‘Asia/Shanghai’</p></li><li><p>注册数据表（模型）admin.py</p><pre><code>from .models import  diffhsy,Runinfo#Register your models here.admin.site.register(diffhsy)admin.site.register(Runinfo)</code></pre></li><li><p>自定义管理页面</p><ol><li><p>在admin.py文件中创建类（继承ModelAdmin）</p></li><li><p>在对应表注册后添加此类：admin.site.register(Batchinfo,biAdmin) #记得加，不然类没引用白写,示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class biAdmin(admin.ModelAdmin):</span><br><span class="line">    list_display = [&apos;pk&apos;,&apos;createtime&apos;,&apos;other&apos;]</span><br><span class="line"></span><br><span class="line">admin.site.register(Batchinfo,biAdmin）</span><br><span class="line">admin.site.register(Diffhsy)</span><br></pre></td></tr></table></figure></li></ol></li></ol><p>列表页属性：</p><pre><code>list_display=[]   设置显示的字段  list_filter=[] 过滤字段  search_field=[] 按照某字段搜索  list_per_page=int 每几个一页  添加/修改页属性  field=[]  修改属性先后顺序  fieldsets  给属性分组，与field不可同时使用  示例：    fieldsets = [(&quot;condition&quot;, {&quot;fields&quot;: [&apos;servicename&apos;,&apos;rowkey&apos;,&apos;header_online&apos;]}), (&quot;result&quot;,{&quot;fields&quot;:[&apos;diff&apos;,&apos;run_no&apos;]})]</code></pre><p> 在主表里添加数据时，同时也可添加对应的子表数据：</p><pre><code>    class bitchTodf(admin.TabularInline):        model = Diffhsy#子表        extra = 2    class biAdmin(admin.ModelAdmin):#主表        inlines = [bitchTodf]布尔值显示难看？封装函数，然后列表显示时调用    class BatchinfoAdmin(admin.ModelAdmin):        def status(self):            if not self.iserror:                return &apos;错误&apos;            else:                return &apos;正确&apos;        status.short_description = &apos;状态&apos;#设置页面列名        list_display = [&apos;pk&apos;,&apos;servicename&apos;,&apos;rowkey&apos;,status]#引用该函数执行动作位置问题（删除的那个控件）    actions_on_bottom = True #执行动作改成下边    actions_on_top = False使用装饰器完成注册（使用模型类）：    @admin.register(Diffhsy)    class DiffhsyAdmin(admin.ModelAdmin):</code></pre><h4 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h4><p> 报错：[error] 13838#0: *1475 open() “/var/www/html/newworkbench/static/admin/css/responsive.css” failed<br> 参考：<a href="https://blog.csdn.net/a657941877/article/details/8953233" target="_blank" rel="noopener">https://blog.csdn.net/a657941877/article/details/8953233</a><br> 解决：将admin静态文件拷贝到nginx配置的static路径下。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Django表单form</title>
      <link href="/2019/07/15/Django%E8%A1%A8%E5%8D%95/"/>
      <url>/2019/07/15/Django%E8%A1%A8%E5%8D%95/</url>
      
        <content type="html"><![CDATA[<p>问题：<br>‘AddForm’ object has no attribute ‘cleaned_data’<br>由于么有调用is_valid，所以没有cleaned_data方法。</p><h5 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h5><ul><li>新建一个 forms.py 文件</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">from django import forms</span><br><span class="line"> </span><br><span class="line">class AddForm(forms.Form):</span><br><span class="line">    a = forms.IntegerField()</span><br><span class="line">    b = forms.IntegerField()</span><br></pre></td></tr></table></figure><p> 我们的视图函数 views.py 中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#coding:utf-8</span><br><span class="line">from django.shortcuts import render</span><br><span class="line">from django.http import HttpResponse</span><br><span class="line">#引入我们创建的表单类</span><br><span class="line">from .forms import AddForm </span><br><span class="line">def index(request):</span><br><span class="line">    if request.method == &apos;POST&apos;:# 当提交表单时</span><br><span class="line">        form = AddForm(request.POST) # form 包含提交的数据</span><br><span class="line">        if form.is_valid():# 如果提交的数据合法</span><br><span class="line">            a = form.cleaned_data[&apos;a&apos;]</span><br><span class="line">            b = form.cleaned_data[&apos;b&apos;]</span><br><span class="line">            return HttpResponse(str(int(a) + int(b)))</span><br><span class="line"></span><br><span class="line">    else:# 当正常访问时建表单视图</span><br><span class="line">        form = AddForm()</span><br><span class="line">    return render(request, &apos;index.html&apos;, &#123;&apos;form&apos;: form&#125;)</span><br></pre></td></tr></table></figure><p>对应的模板文件 index.html</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;form method=&apos;post&apos;&gt;</span><br><span class="line">&#123;% csrf_token %&#125;</span><br><span class="line">&#123;&#123; form &#125;&#125;</span><br><span class="line">&lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure><p>表单域同model，有CharField、IntegerField等，具体见官方文档：<br><a href="https://docs.djangoproject.com/en/2.2/ref/forms/fields/" target="_blank" rel="noopener">https://docs.djangoproject.com/en/2.2/ref/forms/fields/</a><br>参考：<a href="https://code.ziqiangxuetang.com/django/django-forms.html" target="_blank" rel="noopener">https://code.ziqiangxuetang.com/django/django-forms.html</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Django路由URL</title>
      <link href="/2019/07/14/Django%E8%B7%AF%E7%94%B1URL/"/>
      <url>/2019/07/14/Django%E8%B7%AF%E7%94%B1URL/</url>
      
        <content type="html"><![CDATA[<h4 id="配置URL"><a href="#配置URL" class="headerlink" title="配置URL"></a>配置URL</h4><ul><li>在myapp中创建urls.py文件，然后建立连接，从project的url中include到myapp中的urls文件<br>  re_path(r’^’,include(‘myapp.urls’))</li></ul><ul><li><p>path函数的第一个参数是URL模式字符串，用于匹配URL<br>第二个参数是用于处理URL请求的视图函数  </p></li><li><p>使用尖括号提取URL中的参数，如<a href="int:year" target="_blank" rel="noopener">int:year</a>  </p></li><li><p>URL模式字符串不需要以/开头  </p></li><li><p>url传参：在Django 2.0版本以后，这里不再使用正则，而是用<br>…/&lt;参数类型:传入函数的形参名&gt;/…如path(r’oldurl/<a href="str:a" target="_blank" rel="noopener">str:a</a>/<a href="str:b" target="_blank" rel="noopener">str:b</a>/‘, views.oldUrl)类型转化器对参数类型进行转换，如：  </p><pre><code>str：除了“/”以外的任意字符串，默认是它  int：匹配任意大于0的整数  slug:匹配任意slug字符串，可以包含任意ASCII字符、数字、-、_（汉字尝试没成功）</code></pre></li></ul><p>举例： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">urlpatterns = [</span><br><span class="line">    path(&apos;articles/2003/&apos;, views.special_case_2003),</span><br><span class="line">    path(&apos;articles/&lt;title&gt;/&apos;, views.year_archive),</span><br><span class="line">    path(&apos;articles/&lt;int:year&gt;/&lt;int:month&gt;/&apos;, views.month_archive),</span><br><span class="line">    path(&apos;articles/&lt;int:year&gt;/&lt;int:month&gt;/&lt;slug:slug&gt;/&apos;, views.article_detail),</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p><img src="/images/pasted-58.png" alt="upload successful"></p><h5 id="【其他】"><a href="#【其他】" class="headerlink" title="【其他】"></a>【其他】</h5><h6 id="urls与path区别"><a href="#urls与path区别" class="headerlink" title="urls与path区别"></a>urls与path区别</h6><p>   在使用Django的时候，多次遇到urls与path，不知道两者有什么区别。下面简单介绍一下两者</p><p>  在django&gt;=2.0的版本，urls.py中的django.conf.urls已经被django.urls所取代。</p><p>  django.urls的用法：</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">from django.urls import path</span><br><span class="line">from . import view</span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">    path(&apos;&apos;, view.hello),</span><br><span class="line">    path(&apos;world/&apos;, view.world)</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>  其中最大的改变如下： </p><ul><li><p>import urls被import path所取代</p></li><li><p>如果是路径需要在路径的后面加上一个斜杠  /</p><p>旧版本如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">from django.conf.urls import url</span><br><span class="line"></span><br><span class="line">from . import view</span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">    url(r&apos;^hello$&apos;, view.hello),</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>新版本如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">from django.urls import path</span><br><span class="line">from . import view</span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">    path(&apos;hello/&apos;, view.hello),</span><br></pre></td></tr></table></figure></li></ul><h6 id="可变参数就匹配不上-？"><a href="#可变参数就匹配不上-？" class="headerlink" title="可变参数就匹配不上 ？"></a>可变参数就匹配不上 ？</h6><p>Page not found (404)<br>The current path, getpapertextss, didn’t match any of these.<br>最后查跟url没关系，错误信息误导了我，原来是因为Views中从数据库获取数据时为空报了404<br>另外注意：<br>1）正则匹配django2.0需要用re_path<br>2）匹配的url后面有没有‘/’，与配置一致，除非设置中设置了默认加/</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Django模板template</title>
      <link href="/2019/07/14/Django%E6%A8%A1%E6%9D%BF/"/>
      <url>/2019/07/14/Django%E6%A8%A1%E6%9D%BF/</url>
      
        <content type="html"><![CDATA[<ol><li><p>模板标签</p><ul><li>循环标签（for标签）<br>这种适合返回的字典值是列表的情况<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;%for value in value_list %&#125;</span><br><span class="line">&#123;&#123;value&#125;&#125;</span><br><span class="line">&#123;%endfor%&#125;</span><br></pre></td></tr></table></figure></li></ul><p>for遍历<br>除了普通列表遍历还可以实现:  </p><ul><li><p>对列表进行翻转</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% for obj in list reversed%&#125;</span><br></pre></td></tr></table></figure></li><li><p>循环遍历字典</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;%for key ,value in data.items %&#125;</span><br><span class="line">&#123;&#123;key&#125;&#125;:&#123;&#123;value&#125;&#125;</span><br><span class="line">&#123;%endfor%&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li>条件控制标签<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">  &#123;% if condition1 %&#125;</span><br><span class="line">...</span><br><span class="line">&#123;% elif condition2 %&#125;</span><br><span class="line">...</span><br><span class="line">&#123;% else %&#125;</span><br><span class="line">...</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure></li></ul><ol start="2"><li>过滤器<br>在原来值后面加上过滤的关键字，起到过滤效果<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;somekeyname|upper|first|lower|length&#125;&#125;</span><br><span class="line">常用的过滤器：</span><br><span class="line">capfirst首字母大写</span><br><span class="line">cut：删除指定值，如&#123;&#123;value|cut:&quot;&quot;&#125;&#125;</span><br><span class="line">date:格式化日期，如&#123;&#123;value|date:&quot;D d M Y&quot;&#125;&#125;</span><br><span class="line">default</span><br><span class="line">join拼接如&#123;&#123;value|join:&quot;//&quot;&#125;&#125;</span><br><span class="line">truncatewords 缩短内容长度</span><br></pre></td></tr></table></figure></li></ol></li></ol><p>  【问题】  </p><ol><li>表单提交返回后，请求input中填写值不展示？<br>value中设置返回值：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">input type=&quot;text&quot; name=&quot;phone&quot; placeholder=&quot;手机号&quot; value=&#123;&#123; cardno &#125;&#125;&gt;&lt;/td&gt;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Django视图View</title>
      <link href="/2019/07/13/Django%E8%A7%86%E5%9B%BE/"/>
      <url>/2019/07/13/Django%E8%A7%86%E5%9B%BE/</url>
      
        <content type="html"><![CDATA[<ol><li><p>视图快捷方式shortcut  </p><ul><li><p>常用的是render函数，该函数主要3个参数，第一个参数固定是request,第二个参数是模板文件名，第三个参数是字典类型，其中key就是</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;...&#125;&#125;</span><br></pre></td></tr></table></figure><p>中所用的标识符，实际是双括号后返回的是key对应的值。如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#hello.html#</span><br><span class="line">&lt;h1&gt;&#123;&#123;hello&#125;&#125;&lt;/h1&gt;</span><br><span class="line">#views.py#</span><br><span class="line">def hello(request):</span><br><span class="line">values=&#123;&#125;</span><br><span class="line">values[&quot;hello&quot;]=&quot;hello world!&quot;</span><br><span class="line">return render(request,&apos;hello.html&apos;,values)</span><br></pre></td></tr></table></figure><p>【注】render()与render_to_response()均是django中用来显示模板页面的，但是在django1.3之后，render()便比render_to_response()更加招人待见！最明显的就是前者会自动使用RequestContext，而后者需要coding进去</p></li><li><p>render_to_string 返回字符串</p></li><li><p>redict（to,permanent=False,<em>args,*</em>kwargs）第一个参数常常为模板</p></li><li><p>get_object_or_404 提取数据不存在则抛出异常</p></li><li><p>get_list_or_404使用filter方法提取数据不存在抛出异常<br>最终浏览器测试，显示hello world!  </p></li></ul></li><li><p>HttpRequest对象即我们经常用的request<br>有很多属性和方法，比如body\path\method\encoding\META…<br>我们常用它的属性POST\GET，返回类似字典QueryDict的对象，包含表单中提交的数据。</p><p>```</p></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Django项目实践二(偏代码实现)</title>
      <link href="/2019/07/12/Django%E9%A1%B9%E7%9B%AE%E5%AE%9E%E8%B7%B5%E5%81%8F%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0/"/>
      <url>/2019/07/12/Django%E9%A1%B9%E7%9B%AE%E5%AE%9E%E8%B7%B5%E5%81%8F%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<ul><li><p>模板前端与后台交互方法 $.getJSON</p><pre><code>$(document).ready(function () {    $(&quot;#dl&quot;).click(function () {        var sid=$(&quot;#sid&quot;).val();        var pid=$(&quot;#pid&quot;).val();    $.getJSON(&quot;/download/&quot;,{&apos;sid&apos;:sid,&apos;pid&apos;:pid},)    });    $(&quot;#submit&quot;).click(function () {        var sd=$(&quot;#sid&quot;).val();        var pd=$(&quot;#pid&quot;).val();        $.getJSON(&quot;/getSchedule/&quot;,{&apos;sd&apos;:sd,&apos;pd&apos;:pd},function (ret) {            $(&quot;#result&quot;).html(&quot;&quot;);           for(var i =0;i&lt;ret.length;i++){               $(&apos;#result&apos;).append(ret[i]).append(&quot;&lt;br&gt;&quot;)           }        })    });});</code></pre></li><li><p>views返回几种方式<br> return render_to_response(“search.html”)<br> 属于shortcuts模块，常用需要2个参数，第一个是模板如hello.html，第二个是字典，其中字典key就是模板中的变量。<br> return HttpResponse(“success!”)<br> 常用于直接返回字符串</p><ul><li>静态文件的使用<br>settings.py 中两处注意：</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">-INSTALLED_APPS中 注册了‘django.contrib.staticfiles’，默认生成的文件已注册。 </span><br><span class="line">-指定STATIC_URL 与 STATICFILES_DIRS 的值.</span><br><span class="line"></span><br><span class="line">INSTALLED_APPS=[</span><br><span class="line">    &apos;...&apos;,</span><br><span class="line">    &apos;django.contrib.staticfiles&apos;,</span><br><span class="line">    &apos;...&apos;,</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">STATIC_URL=&apos;/static/&apos;</span><br><span class="line">STATICFILES_DIRS=(BASE_DIR,&apos;static&apos;)</span><br></pre></td></tr></table></figure><p>*.html中引用（常加在link前）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;% load staticfiles %&#125;</span><br><span class="line">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;&#123;% static &apos;css/main.css&apos; %&#125;&quot; /&gt;</span><br><span class="line">...</span><br><span class="line">&#123;% static &apos;/image/test.png&apos; %&#125;</span><br></pre></td></tr></table></figure><ul><li><p>打开text文件乱码且每次打开的时候会多出一行？</p><p>本地的ct.txt文件保存格式未必是utf-8，所以需要指定编码格式才更准确，使用newline防止在每次写入默认新添加一空行</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">file=open(&quot;templates/ct.txt&quot;,&quot;w&quot;,encoding=&quot;utf-8&quot;, newline=&apos;&apos;)</span><br></pre></td></tr></table></figure><ul><li>表单提交后不调view接口？<br>表单submit按钮类型写错，应该是submit类型，非button类型。</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Django模型models</title>
      <link href="/2019/07/12/Django-models/"/>
      <url>/2019/07/12/Django-models/</url>
      
        <content type="html"><![CDATA[<h4 id="定义模型model："><a href="#定义模型model：" class="headerlink" title="定义模型model："></a>定义模型model：</h4><ul><li><p>一个模型对应数据库一个表；继承model.Model类；</p></li><li><p>不需要定义主键，系统自动生成</p></li><li><p>外键关联：</p><pre><code>sgrade=models.ForeignKey(&quot;Grades&quot;) #意思是Grades的主键作为Student sgrade的外键</code></pre></li><li><p>数据库表生成两步走：</p></li></ul><ol><li>python manage.py makemigrations 创建迁移文件 </li><li>python manage.py migrate</li></ol><ul><li><p>测试数据操作：python manage.py shell</p></li><li><p>添加数据：本质是创建一个模型类的对象;示例:<br>  grade1=Grades()<br>  grade1.gname=”python”<br>  grade1.gtime=datetime(year=2017,month=12,day=17)<br>  grade1.save()  #注意保存</p></li><li><p>查询支持切片,但不支持负数Grades.objects.all()[:10]</p></li><li><p>条件查询：grade1=类名.objects.get(pk=2)#主键查找用关键字pk</p></li><li><p>修改数据：grade1.gname=”python22”   grade1.save()</p></li><li><p>删除数据：grade1.delete()</p></li><li><p>更新数据：update()  返回匹配的行数。唯一的限制是它只能作用在表记录上，不能直接作用在模型object上，返回执行行数。举例： </p><pre><code>&gt;&gt;&gt; Entry.objects.update(blog__name=&apos;foo&apos;) # Won&apos;t work!&gt;&gt;&gt;  Entry.objects.filter(blog__id=1).update(comments_on=True) # works!</code></pre><p>   若单个object更新，则跟添加数据方法一致。</p></li><li><p>如果只是检查 Entry 中是否有对象，应该用 Entry.objects.all().exists()</p></li><li><p>推荐用 Entry.objects.count()来查询数量</p></li><li><p>list(es) 可以强行将 QuerySet 变成 列表</p></li><li><p>关联：</p><ol><li>grade1.student_set.all()  #对象名.关联类小写_set.all()<br>#班级grades1里所有的学生</li><li>grade1.student_set.create(…)<br>#创建一条学生新数据 </li></ol></li><li><p>模型类中定义元信息Meta :</p><p>1.db_table定义数据表名，推荐小写，默认是项目表名_类名<br>2.ordering 排序 如ordering[-id] 加负号是倒序</p></li><li><p>自定义Manager类：</p><p>  模型管理器是Django的模型与数据库进行交互的接口，一个模型可以有多个模型管理器。object是manager类的一个对象；</p><p>作用： 向管理器中添加额外的方法；修改管理器返回的原始查询集（重写get_queryset）</p></li></ul><pre><code>class diffManager(models.Manager):    def get_queryset(self):#重写原函数        return super(diffManager,self).get_queryset().filter(isdelete=True)    #super参数，第一个是子类类名，第二个一般为selfclass  Diffhsy(models.Model):    dfhobj=diffManager() #调用自定义的Manager类，替代Django为模型默认生成的objects模型管理器 #在view.py中调用自定义模型管理器 Student.dfhobj.all()</code></pre><ul><li><p>创建对象</p><p>  作用:像数据库中添加数据</p><p>  方法：1. 模型中类中添加方法 2. 在自定义管理器里添加方法。</p><pre><code>class Batchinfo(models.Model):    @classmethod    def createbatch(cls,time,oth):        bt=cls(createtime=time,other=oth)    return bt</code></pre></li></ul><h4 id="模型查询："><a href="#模型查询：" class="headerlink" title="模型查询："></a>模型查询：</h4><p>  官方接口文档：<a href="https://docs.djangoproject.com/zh-hans/2.1/ref/models/querysets/#filter" target="_blank" rel="noopener">https://docs.djangoproject.com/zh-hans/2.1/ref/models/querysets/#filter</a><br>  自强学院：<a href="https://code.ziqiangxuetang.com/django/django-models.html" target="_blank" rel="noopener">https://code.ziqiangxuetang.com/django/django-models.html</a></p><h5 id="返回查询集-多个"><a href="#返回查询集-多个" class="headerlink" title="返回查询集(多个):"></a>返回查询集(多个):</h5><pre><code>filter(键=值，键=值)等价于 filter(键=值).filter(键=值)经过过滤器返回的仍然是查询集；可以有多个过滤器链式调用；exclude() 过滤掉符合条件的数据order_by()values()</code></pre><h5 id="返回单个对象"><a href="#返回单个对象" class="headerlink" title="返回单个对象:"></a>返回单个对象:</h5><pre><code>  get()  1.若没找到符合条件的对象，会引发DoesNotExits异常2.若返回多条，会引发MultipleObjectsReturned异常  count()  返回查询集对象的个数  first()  返回查询集第一个对象  last()   返回查询集最后一个对象  exist()  若有数据返回True比较运算符:字段名__运算符关键字=值：   isnull:Entry.objects.filter(pub_date__isnull=True)   in:Entry.objects.filter(headline__in=&apos;abc&apos;)   gt/gte/lt/lte   date/year/month/day/week/week_day:如pub_date__date=datetime.date(2005, 1, 1)区分大小写，若前面加i则不区分：  exact/iexact  : Entry.objects.get(id__exact=14)  contains/icontains  startswith/endswith/istartswith/iendswith pk：代表主键 聚合函数：aggregate方法：    Avg/Count/Max/Min:Student.object.aggregate(Max(&apos;sage&apos;))关联查询：    Grades.objects.filter(student__scontend__contains(&apos;李爱国&apos;)) F对象：使用模型的两个属性进行比较    from django.db.models import F,Q    Student.object.filter(num1__gt=F(&apos;num2&apos;)+20)#F对象也可以进行算术运算 Q对象：    Model.objects.filter(Q(x=1) | Q(y=2))    Model.objects.filter(~Q(x=1)) #非，即取反</code></pre><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><ol><li><p>创建模型</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">from django.db import models</span><br><span class="line">class ContentTable(models.Model):</span><br><span class="line">    title=models.CharField(default=&quot;&quot;,max_length=50)</span><br><span class="line">    content=models.CharField(default=&quot;&quot;,max_length=1000)</span><br></pre></td></tr></table></figure></li><li><p>views.py中使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">from wkbenchapp.models import ContentTable</span><br><span class="line">ct = ContentTable.objects.create(title=&quot;标题&quot;, content=&quot;内容&quot;)</span><br><span class="line">value = ContentTable.objects.filter(title=&quot;标题&quot;) #返回QuerySet object类型</span><br><span class="line">for v in value:#其中每个记录v都是个ContentTable object</span><br><span class="line">   print (&quot;v&quot;,v.content)</span><br></pre></td></tr></table></figure><h4 id="QuerySet-API"><a href="#QuerySet-API" class="headerlink" title="QuerySet API"></a>QuerySet API</h4><h4 id="常用字段类型"><a href="#常用字段类型" class="headerlink" title="常用字段类型"></a>常用字段类型</h4></li></ol><pre><code>·AutoField    ·一个根据实际ID自动增长的IntegerField，通常不指定如果不指定，一个主键字段将自动添加到模型中·CharField(max_length=字符长度)    ·字符串，默认的表单样式是 TextInput·TextField    ·大文本字段，一般超过4000使用，默认的表单控件是Textarea·IntegerField    ·整数·DecimalField(max_digits=None, decimal_places=None)    ·使用python的Decimal实例表示的十进制浮点数    ·参数说明        ·DecimalField.max_digits            ·位数总数        ·DecimalField.decimal_places            ·小数点后的数字位数·FloatField    ·用Python的float实例来表示的浮点数·BooleanField    ·true/false 字段，此字段的默认表单控制是CheckboxInput·NullBooleanField    ·支持null、true、false三种值·DateField([auto_now=False, auto_now_add=False]) --- 日期    ·使用Python的datetime.date实例表示的日期    ·参数说明        ·DateField.auto_now(最后更新时间)            ·每次保存对象时，自动设置该字段为当前时间，用于&quot;最后一次修改&quot;的时间戳，它总是使用当前日期，默认为false        ·DateField.auto_now_add（创建时间）            ·当对象第一次被创建时自动设置当前时间，用于创建的时间戳，它总是使用当前日期，默认为false    ·说明        ·该字段默认对应的表单控件是一个TextInput. 在管理员站点添加了一个JavaScript写的日历控件，和一个“Today&quot;的快捷按钮，包含了一个额外的invalid_date错误消息键    ·注意        ·auto_now_add, auto_now, and default 这些设置是相互排斥的，他们之间的任何组合将会发生错误的结果·TimeField                                 ------时间    ·使用Python的datetime.time实例表示的时间，参数同DateField·DateTimeField               -------------------日期+时间    ·使用Python的datetime.datetime实例表示的日期和时间，参数同DateField·FileField    ·一个上传文件的字段·ImageField    ·继承了FileField的所有属性和方法，但对上传的对象进行校验，确保它是个有效的image</code></pre><h4 id="字段选项"><a href="#字段选项" class="headerlink" title="字段选项"></a>字段选项</h4><pre><code>·概述    ·通过字段选项，可以实现对字段的约束    ·在字段对象时通过关键字参数指定·null    ·如果为True，Django 将空值以NULL 存储到数据库中，默认值是 False·blank    ·如果为True，则该字段允许为空白，默认值是 False·注意    ·null是数据库范畴的概念，blank是表单验证证范畴的·db_column    ·字段的名称，如果未指定，则使用属性的名称·db_index    ·若值为 True, 则在表中会为此字段创建索引·default    ·默认值·primary_key    ·若为 True, 则该字段会成为模型的主键字段·unique    ·如果为 True, 这个字段在表中必须有唯一值</code></pre><h4 id="错误调试"><a href="#错误调试" class="headerlink" title="错误调试"></a>错误调试</h4><ol><li>django.db.utils.IntegrityError: UNIQUE constraint failed: wkbenchapp_content.id…<br>migrate更新表的时候不知道怎么回事总是报这个错，怎么改都不行，最后删除migrations里除了初始化外的所有日志，重新从makemigrations来一遍就顺利的好了。</li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>出错排查和记录</title>
      <link href="/2019/07/11/%E5%87%A0%E5%A4%A7%E6%9C%AA%E8%A7%A3%E4%B9%8B%E8%B0%9C/"/>
      <url>/2019/07/11/%E5%87%A0%E5%A4%A7%E6%9C%AA%E8%A7%A3%E4%B9%8B%E8%B0%9C/</url>
      
        <content type="html"><![CDATA[<p>1、windows使用pycharm运行Django项目时，项目可以运行，但是就是不打印print内容，cmd窗口和ptcharm控制台都一样。<br>原来是加了这句坑爹的原意是解决问题，却没想到引出问题来了，气死。<br>import io<br>sys.stdout = io.TextIOWrapper(sys.stdout.buffer,encoding=’utf-8’)<br>2、本来是为了解决json转yaml后中文乱码的问题，才引出的问题1，经过调查原来是原来犯过的一个问题<br>没加allow_unicode=True 导致中文转换成unicode</p><pre><code></code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>一行python命令让手机读取电脑文件</title>
      <link href="/2019/07/02/%E4%B8%80%E8%A1%8Cpython%E5%91%BD%E4%BB%A4%E8%AE%A9%E6%89%8B%E6%9C%BA%E8%AF%BB%E5%8F%96%E7%94%B5%E8%84%91%E6%96%87%E4%BB%B6/"/>
      <url>/2019/07/02/%E4%B8%80%E8%A1%8Cpython%E5%91%BD%E4%BB%A4%E8%AE%A9%E6%89%8B%E6%9C%BA%E8%AF%BB%E5%8F%96%E7%94%B5%E8%84%91%E6%96%87%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/why19940926/article/details/62054757" target="_blank" rel="noopener">https://blog.csdn.net/why19940926/article/details/62054757</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">E:\workspace\newworkbench\static&gt;python -m http.server 8000</span><br><span class="line">Serving HTTP on 0.0.0.0 port 8000 ...</span><br><span class="line">10.160.84.95 - - [02/Jul/2019 20:41:29] &quot;GET /app.jpg HTTP/1.1&quot; 200 -</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Apache记录</title>
      <link href="/2019/06/26/Apache%E8%AE%B0%E5%BD%95/"/>
      <url>/2019/06/26/Apache%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<p>service httpd status<br>service httpd start/restart<br>service httpd  stop</p><p>查找httpd.conf配置文件的存放路径<br>find /etc/httpd/  -name *conf</p><p><img src="%5Cimages%5Cpasted-54.png" alt="upload successful"></p><p>更改端口号，在查找到的httpd.conf文件里找到Listen<br>可以看到默认是80，修改成你想换的不用端口就好啦，查询端口是否占用：<br>lsof -i :8080</p><p>然后原来的php网址在原来ip后加上8080端口就可以正常访问啦</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Django+uwsgi+supervisor+nginx环境部署</title>
      <link href="/2019/06/25/ceshi/"/>
      <url>/2019/06/25/ceshi/</url>
      
        <content type="html"><![CDATA[<h1 id="理论知识"><a href="#理论知识" class="headerlink" title="理论知识"></a>理论知识</h1><ol><li><p>Apache<br>Apache是世界使用排名第一的Web服务器软件。它可以运行在几乎所有广泛使用的计算机平台上，由于其跨平台和安全性被广泛使用，是最流行的Web服务器端软件之一。版本查看：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@tv6-hotelqa-newhotel-17 ~]# apachectl -v</span><br><span class="line">Server version: Apache/2.2.15 (Unix)</span><br><span class="line">Server built:   Oct 19 2017 16:43:38</span><br></pre></td></tr></table></figure></li><li><p>FQDN 是Fully Qualified Domain Name的简写，意思是完整的域名。 </p><p>FQDN=主机名（hostname）+域后缀<br>如 主机名是 fanyi 域名是 baidu.com<br>FQDN= fanyi.baidu.com<br>如何查看主机名？<br>设置主机名： vi /etc/hostname<br>第一个字段是该主机的IP地址, 第二个和第三个字段是你希望设置的主机名,最后是刚刚设置的FQDN（这两个顺序应该没关系）:<br><img src="%5Cimages%5Cpasted-45.png" alt="upload successful"><br>hostname -F /etc/hostname更新主机名<br>hostname -f看到主机名  </p></li></ol><ul><li><p>路径</p><p>centos6x  nginx默认一般在/etc/nginx路径下<br>httpd.conf 一般在/etc/httpd 文件夹下的子文件里 使用 (find  +地址 -name  +名称)查找即可</p></li><li><p><strong>流程</strong><br>1、    首先客户端请求服务资源，<br>2、    nginx作为直接对外的服务接口,接收到客户端发送过来的http请求,会解包、分析，<br>3、    如果是静态文件请求就根据nginx配置的静态文件目录，返回请求的资源，<br>4、    如果是动态的请求,nginx就通过配置文件,将请求传递给uWSGI；uWSGI 将接收到的包进行处理，并转发给wsgi，<br>5、    wsgi根据请求调用django工程的某个文件或函数，处理完后django将返回值交给wsgi，<br>6、    wsgi将返回值进行打包，转发给uWSGI，<br>7、    uWSGI接收后转发给nginx,nginx最终将返回值返回给客户端(如浏览器)。</p></li><li><p><strong>MVT架构图</strong></p></li></ul><p><img src="%5Cimages%5Cpasted-69.png" alt="upload successful"></p><h1 id="搭建过程"><a href="#搭建过程" class="headerlink" title="搭建过程"></a>搭建过程</h1><p>最后决定使用 nginx + uwsgi socket 的方式来部署 Django，因为听说是比 Apache mod_wsgi 要复杂一些，但这是目前主流的方法。<br>环境：Centos6<br>参考：<a href="https://code.ziqiangxuetang.com/django/django-nginx-deploy.html" target="_blank" rel="noopener">https://code.ziqiangxuetang.com/django/django-nginx-deploy.html</a><br>其他：<a href="https://www.jianshu.com/p/36ef6557c910" target="_blank" rel="noopener">https://www.jianshu.com/p/36ef6557c910</a>  </p><p>1、安装nginx<br>sudo yum install epel-release<br>sudo yum install python-devel nginx<br>ps -e | grep nginx查看是否已经启动了nginx<br>nginx -t 检查语法<br>nginx -s reload<br>nginx -c /etc/nginx/nginx.conf<br>nginx -V 版本</p><p>2、安装 supervisor, 一个专门用来管理进程的工具，我们用它来管理 uwsgi 进程<br>sudo pip install supervisor</p><p>3、将 SELinux 设置为宽容模式，方便调试：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo setenforce 0  </span><br><span class="line">service iptables stop</span><br></pre></td></tr></table></figure><p>getenforce 或者sestatus -v可以查防火墙状态   </p><p><img src="%5Cimages%5Cpasted-34.png" alt="upload successful"><br>4、安装 uwsgi<br>sudo pip install uwsgi –upgrade</p><p>5、使用 uwsgi 运行项目<br>uwsgi –http :8001 –chdir /var/www/html/newworkbench/pycharmpj –home=/path/to/env –module project.wsgi<br>这样就可以跑了，–home 指定virtualenv 路径，如果没有可以去掉。project.wsgi 指的是 project/wsgi.py 文件</p><p><img src="%5Cimages%5Cpasted-37.png" alt="upload successful"></p><p>6、使用supervisor来管理进程<br>安装 supervisor 软件包    (sudo) pip install supervisor<br>7、 新建一个 uwsgi.ini 编辑：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[uwsgi]</span><br><span class="line">socket =/tmp2/pycharmpj.sock</span><br><span class="line">chdir =  /var/www/html/newworkbench</span><br><span class="line">wsgi-file = pycharmpj/wsgi.py</span><br><span class="line">touch-reload = /var/www/html/reload</span><br><span class="line">processes = 2</span><br><span class="line">threads = 4</span><br><span class="line">chmod-socket = 664</span><br><span class="line">#chown-socket = tu:www-data</span><br><span class="line">vacuum = true#//退出、重启时清理文件</span><br></pre></td></tr></table></figure><p>在根目录/下新建tmp2替代原来的tmp(tmp目录可能找不到)<br>编辑 supervisor.conf，将原来的tmp目录都改成tmp2，然后在最底部添加（每一行前面不要有空格，防止报错）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[program:nwk]</span><br><span class="line">command=uwsgi --ini   /var/www/html/uwsgi.ini</span><br><span class="line">directory=/var/www/html/newworkbench/pycharmpj</span><br><span class="line">startsecs=0</span><br><span class="line">stopwaitsecs=0</span><br><span class="line">autostart=true</span><br><span class="line">autorestart=true</span><br></pre></td></tr></table></figure><p>启动 supervisor</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(sudo) supervisord -c /etc/supervisord.conf 重启 zqxt 程序（项目）：</span><br><span class="line">(sudo) supervisorctl -c /etc/supervisord.conf restart zqxt#启动，停止，或重启 supervisor 管理的某个程序 或 所有程序：</span><br><span class="line">(sudo) supervisorctl -c /etc/supervisord.conf [start|stop|restart] [program-name|all]</span><br><span class="line">ps -ef | grep supervisord #查看状态</span><br></pre></td></tr></table></figure><p>重启后提示unix:///tmp2/supervisor.sock no such file？原因是没有启动过，何谈重启，需要先启动：<br><img src="%5Cimages%5Cpasted-44.png" alt="upload successful"></p><p>8、出现问题：重启的时候报错</p><p><img src="%5Cimages%5Cpasted-41.png" alt="upload successful"><br>解决过程：<br>1）将socket目录改为原tmp同路径（怕因为是这个路径太长的缘故）<br>2）将touch-reload和uwsgi.ini路径都直接放在了/var里<br>都没解决，最后想到应该学会灵活的解决问题，于是从报错文件开始抓起，打开文件锁定代码后打印分别打印出self.socketfile和源头serverurl，发现从serverurl就错了（打印编辑时用到vim里查看空格问题，如后文记录）<br><img src="%5Cimages%5Cpasted-43.png" alt="upload successful"><br>本来还以为是系统定义的serverurl有问题，后来查看cat /etc/supervisord.conf，发现这里不知道什么时候多出来的这些东西。<br><img src="%5Cimages%5Cpasted-40.png" alt="upload successful"></p><p>9、 配置ng后测试不ok，待续<br>nginx  conf文件配置错误？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@tv6-hotelqa-xxxxx-17 newworkbench]# nginx  -s reload</span><br><span class="line">nginx: [error] invalid PID number &quot;&quot; in &quot;/var/run/nginx.pid&quot;</span><br></pre></td></tr></table></figure><p>查知先nginx -c，但</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@tv6-hotelqa-xxxxx-17 newworkbench]# nginx -c /etc/nginx/nginx.conf</span><br><span class="line">nginx: [emerg] bind() to 0.0.0.0:80 failed (98: Address already in use</span><br></pre></td></tr></table></figure><p>定位过程：</p><ul><li><p>使用service iptables status 查看防火墙的状态，果是开启的状态就使用service iptables stop来关闭。</p></li><li><p>查看占用进程</p><p>1.先使用ps -e | grep nginx查看是否已经启动了nginx</p><p>2.如果没有的话则按照提示，查看0.0.0.0:80端口谁占用了，使用netstat -ltunp（或 lsof -i :80）命令，可以看到</p><p>可以看到0.0.0.0:80端口被httpd这个进程占用了（也就是apcache占用），杀掉重复进程</p><p> <img src="%5Cimages%5Cpasted-46.png" alt="upload successful"><br>本来不想通过杀进程的方式来解决的，因为有个进程不太了解，怕误删，但是后来没有找到突破口，反正是测试机就暂时杀掉吧，后来发现这个进程跟我启动nginx相关，只要启动这个进程就有，所以就不管啦，把其他占用端口的httpd都杀掉果然奇迹般的好了。</p></li></ul><p><img src="%5Cimages%5Cpasted-47.png" alt="upload successful"></p><p><img src="%5Cimages%5Cpasted-48.png" alt="upload successful"><br>lsof -i :80 | grep httpd |grep -v grep |xargs kill -9<br>其中grep -v grep是去掉grep查找的进程，xargs意思是将前面获取到的进程作为后面的参数kill掉</p><p>10、运行时出错：  ** Nginx的Permission denied错误**  </p><ul><li><p>把user选项从nginx改成root<a href="https://www.cnblogs.com/zhangqunshi/p/6654866.html" target="_blank" rel="noopener">https://www.cnblogs.com/zhangqunshi/p/6654866.html</a><br>还是不行？</p></li><li><p>创建属于nginx组另外用户www-data:<br><img src="%5Cimages%5Cpasted-49.png" alt="upload successful">最后还是不行</p></li><li><p>创建一样的用户组和用户名<br>打算重新整理权限和路径，把pycharmpj.sock和reload、uwsgi.ini都放在了项目目录里，并且赋予了项目目录一个新用户组和权限（其中pycharmpj.sock权限最大，忘了自己给的还是uwsgi.ini生的效），当然相应的更改引用文件路径。最后在nginx里配置的user使用root</p><p><img src="%5Cimages%5Cpasted-53.png" alt="upload successful"><br>出现的问题：<br>【pycharmpj.sock出不来？】<br>这个文件是执行uwsgi命令自动生成的，而supervisor是用来管理它的，重启它就行啦，步骤：<br>1)停止 supervisorctl -c /etc/supervisord.conf stop all<br>查看ps -ef | grep supervisord若有重复，删除重复<br><img src="%5Cimages%5Cpasted-51.png" alt="upload successful"><br>2)清空（原路径tmp2下）用来存放supervisor.sock的文件夹<br>3)重启supervisor ：supervisorctl -c /etc/supervisord.conf restart  nwk<br>可见pycharmpj.sock和tmp2下的supervisor.sock等文件都出来了。</p><p>【nginx -t语法检测失败报错?】<br>nginx: [emerg] invalid host in upstream “/var/www/html/newworkbench/pycharmpj.sock” in /etc/nginx/conf.d/nwk.conf:15<br>解决：原因是在这少加了unix，真是一点都不能差啊<br><img src="%5Cimages%5Cpasted-52.png" alt="upload successful"></p></li></ul><p>11、终于出来Django的页面啦，虽然还是有错。<br>    You’re seeing this error because you have DEBUG = True in your Django settings file. Change that to False, and Django will display a standard 404 page.<br>    于是按照提示把setting文件改了，但是该页面无动于衷，还是报这个加上<br>    The current path, myworkbench/links.php, didn’t match any of these.<br>    后来醒悟到是我没有加路由，加上了之后果然出现啦，太开心啦<br>12、但是静态页面还没出来，需要配置一下。<br>刚开始稍微饶了一点弯路，不过还好，最后解决很简单，更改nginx配置文件增加，重启下nginx后就好了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">location /static &#123;</span><br><span class="line">       alias  /var/www/html/newworkbench/static;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>13、更改Django下路由url.py，更改链接后重启supervisorctl即生效。（记得改一个链接的时候要把所有它下一级的url都改全，否则部分还是会报错）。<br>14、static文件访问不了？<br><img src="%5Cimages%5Cpasted-55.png" alt="upload successful"><br>原因：原来动了setting里设置静态文件的路径，多了个斜杠，去掉还原就好了。<br><img src="%5Cimages%5Cpasted-56.png" alt="upload successful"><br>15、关于部署   </p><ul><li><p>. 直接覆盖安装相关文件或文件夹，更改所属人为已设角色和用户(后台登录后报500错误就是这个原因);再重新启动服务即可（setting文件debug:false）。<br>supervisorctl -c /etc/supervisord.conf restart nwk</p></li><li><p>数据库被覆盖？<br>尝试不覆盖migrations文件夹</p></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>mysql数据库</title>
      <link href="/2019/06/16/mysql%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
      <url>/2019/06/16/mysql%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<h5 id="linux安装mysql"><a href="#linux安装mysql" class="headerlink" title="linux安装mysql"></a>linux安装mysql</h5><p>使用pymysql的时候创建表不成功，提示连不到，于是才意识到本机没有安装Mysql服务，步骤：<br>1、下载<a href="https://dev.mysql.com/downloads/mysql/" target="_blank" rel="noopener">https://dev.mysql.com/downloads/mysql/</a><br>2、安装的时候设置root密码<br>3、设置环境变量<br>打开终端,根目录：open .bash_profile<br>直接输入如下语句：export PATH=${PATH}:/usr/local/mysql/bin<br>4、终端登录  mysql -u root -p<br>5、手动创建数据库 语句参考<a href="https://www.cnblogs.com/zhuyongzhe/p/7686105.html" target="_blank" rel="noopener">https://www.cnblogs.com/zhuyongzhe/p/7686105.html</a><br>6、执行创建表操作（本地写的create.py-连数据库和创建表操作）<br>执行后提示Warning: (3719, “‘utf8’ is currently an alias for the character set UTF8MB3, but will be an alias for UTF8MB4 in a future release. Please consider using UTF8MB4 in order to be unambiguous.”)<br>  result = self._query(query)<br>忽略即可，表已创建完毕</p><h4 id="数据库创建满足三大范式"><a href="#数据库创建满足三大范式" class="headerlink" title="数据库创建满足三大范式"></a>数据库创建满足三大范式</h4><h6 id="1-原子性"><a href="#1-原子性" class="headerlink" title="1.原子性"></a>1.原子性</h6><p>不可再拆分</p><h6 id="2-主键与其他列相关联"><a href="#2-主键与其他列相关联" class="headerlink" title="2.主键与其他列相关联"></a>2.主键与其他列相关联</h6><p>与主键无关的列需要去掉</p><h6 id="3-主键与其他列直接相关联"><a href="#3-主键与其他列直接相关联" class="headerlink" title="3.主键与其他列直接相关联"></a>3.主键与其他列直接相关联</h6><p>若间接相关不可以，可拆分成两个表</p><p>参考：<a href="https://blog.csdn.net/kenhins/article/details/51084815" target="_blank" rel="noopener">https://blog.csdn.net/kenhins/article/details/51084815</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>TensorFlow实践</title>
      <link href="/2019/06/15/Django%E5%AE%9E%E8%B7%B5/"/>
      <url>/2019/06/15/Django%E5%AE%9E%E8%B7%B5/</url>
      
        <content type="html"><![CDATA[<ol><li>创建隔离的python环境</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pip install virtualenv #安装</span><br><span class="line">virtualenv my_env#创建目录</span><br><span class="line">which python3  #找到python3目录</span><br><span class="line">virtualenv my_env -p /Library/Frameworks/Python.framework/Versions/3.7/bin/python3 </span><br><span class="line">#将python3作为解释器</span><br><span class="line">source my_env/bin/activate  #激活，开始使用</span><br><span class="line">deactivate 退出</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Flask+Django框架学习</title>
      <link href="/2019/06/15/Flask%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0/"/>
      <url>/2019/06/15/Flask%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">from flask import Flask</span><br><span class="line">app=Flask(__name__)</span><br><span class="line"></span><br><span class="line">@app.route(&apos;/&apos;)</span><br><span class="line">def hello_world():</span><br><span class="line">return &quot;hello_world&quot;</span><br><span class="line">if __name==&apos;__main__&apos;:</span><br><span class="line">app.run()</span><br></pre></td></tr></table></figure><p>环境：mac 10.12.6  pycharm +Flask</p><p>【问题1】找不到项目的Flask配置位置？debug模式怎么一直是off，即使run后面添加了debug=True？</p><p>Flask配置：点击项目名，在如下位置编辑</p><p><img src="/images/pasted-26.png" alt="upload successful"></p><p><img src="/images/pasted-27.png" alt="upload successful"></p><p>【问题2】执行创建数据库表的操作时提示Mysql Error 2003: Can’t connect to MySQL server on ‘127.0.0.1’ ([Errno 61] Connection refused)<br><img src="/images/pasted-28.png" alt="upload successful"><br>解决：没有安装Mysql服务，于是下载安装，具体见mysql那一篇</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>tensorflow环境安装实践2</title>
      <link href="/2019/06/15/tensorflow%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85%E5%AE%9E%E8%B7%B52/"/>
      <url>/2019/06/15/tensorflow%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85%E5%AE%9E%E8%B7%B52/</url>
      
        <content type="html"><![CDATA[<p>由于之前是在本机的python2.7基础上安装的本次希望安装个基于3.x的，为了兼容其他同学的环境代码。<br>方案：使用虚拟隔离环境构建<br>问题1：在本机安装py3.7的包，然后在已经有的virtualenv（之前在py2.7下安装的）下链接此pyh环境提示：<br>New python executable in /Users/cly/Documents/my_env/bin/python3  </p><p>没办法解决，愤然上课去，下课后心平气和的重新用新装的pip3.7重新装了一遍virtualenv，这个问题解决:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">MacBook-Pro:bin cly$ pip3 install -U virtualenv</span><br><span class="line">MacBook-Pro:workspace cly$ virtualenv -p /Library/Frameworks/Python.framework/Versions/3.7/bin/python3  my_env</span><br><span class="line">MacBook-Pro:workspace cly$ source my_env/bin/activate  #激活，开始使用</span><br><span class="line">(my_env)MacBook-Pro:workspace cly$ python -V#注意目录前面出现(my_env)</span><br><span class="line">Python 3.7.3</span><br><span class="line">(my_env)MacBook-Pro:workspace cly$ ：deactivate 退出</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>tensorflow学习实践二</title>
      <link href="/2019/06/09/tensorflow%E5%AD%A6%E4%B9%A0%E5%AE%9E%E8%B7%B5%E4%BA%8C/"/>
      <url>/2019/06/09/tensorflow%E5%AD%A6%E4%B9%A0%E5%AE%9E%E8%B7%B5%E4%BA%8C/</url>
      
        <content type="html"><![CDATA[<h4 id="可视化利器tensorboard"><a href="#可视化利器tensorboard" class="headerlink" title="可视化利器tensorboard"></a>可视化利器tensorboard</h4><p>待续  </p><h4 id="matplotlib"><a href="#matplotlib" class="headerlink" title="matplotlib"></a>matplotlib</h4><p>=matrix + plot  +library<br>常用子包<strong>pyplot</strong><br><a href="https://matplotlib.org" target="_blank" rel="noopener">https://matplotlib.org</a></p><p><img src="/images/pasted-15.png" alt="upload successful"></p><p><img src="/images/pasted-16.png" alt="upload successful"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>tensorflow学习实践一</title>
      <link href="/2019/06/08/tensorflow%E5%AD%A6%E4%B9%A0%E5%AE%9E%E8%B7%B5/"/>
      <url>/2019/06/08/tensorflow%E5%AD%A6%E4%B9%A0%E5%AE%9E%E8%B7%B5/</url>
      
        <content type="html"><![CDATA[<h5 id="查看已安装tf的版本和路径"><a href="#查看已安装tf的版本和路径" class="headerlink" title="查看已安装tf的版本和路径"></a>查看已安装tf的版本和路径</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tf.__version__</span><br><span class="line">tf.__path__</span><br></pre></td></tr></table></figure><p> 第一课:从helloword开始  </p><p><img src="/images/pasted-4.png" alt="upload successful"></p><p><img src="/images/pasted-5.png" alt="upload successful"></p><p><img src="/images/pasted-6.png" alt="upload successful"></p><p><img src="/images/pasted-7.png" alt="upload successful"></p><p><img src="/images/pasted-8.png" alt="upload successful"></p><h5 id="numpy"><a href="#numpy" class="headerlink" title="numpy"></a>numpy</h5><p>用于科学计算，速度很快，因为本身主要用C语言实现，还有一些其他的优化。<br>其他比较常用的库：IPython：Interactive python，新版本叫做jupyter<br>pandas\matplotlib<br>numpy：  </p><ul><li>ndarray：数组，相当于tensor，array是其缩写  </li><li>ndim:维度，阶数 ,秩</li><li>shape：各个维度的大小  </li><li>size:所有元素总和  </li><li>dtype:元素的类型，其中d是data的缩写</li></ul><p><img src="/images/pasted-9.png" alt="upload successful">  </p><p>什么是tensor(张量)？</p><p><img src="/images/pasted-10.png" alt="upload successful"></p><p><img src="/images/pasted-11.png" alt="upload successful"></p><p><img src="/images/pasted-12.png" alt="upload successful"></p><p>【注】</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; x=np.array([[1,3]])#双方括号是二维矩阵</span><br><span class="line">&gt;&gt;&gt; x.ndim</span><br><span class="line">2</span><br><span class="line">&gt;&gt;&gt; y=np.array([1,2,3])#单方括号是一维向量</span><br><span class="line">&gt;&gt;&gt; y.ndim</span><br><span class="line">1</span><br></pre></td></tr></table></figure><p><img src="/images/pasted-13.png" alt="upload successful"><br>四种tensor(注意大小写):  </p><ul><li>constant</li><li>Variable</li><li>Placeholder(占位符)</li><li>SparseTensor<h4 id="constant"><a href="#constant" class="headerlink" title="constant"></a>constant</h4>必须参数：value<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import tensorflow as tf</span><br><span class="line">&gt;&gt;&gt; const=tf.constant(3)</span><br><span class="line">&gt;&gt;&gt; const #【注】tensor里面只有通过session才能输出</span><br><span class="line">&lt;tf.Tensor &apos;Const:0&apos; shape=() dtype=int32&gt;</span><br><span class="line">&gt;&gt;&gt; print(const)</span><br><span class="line">Tensor(&quot;Const:0&quot;, shape=(), dtype=int32)</span><br></pre></td></tr></table></figure></li></ul><h4 id="Variable"><a href="#Variable" class="headerlink" title="Variable"></a>Variable</h4><p>必填：初始值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; var =tf.Variable(3)</span><br><span class="line">&gt;&gt;&gt; var</span><br><span class="line">&lt;tf.Variable &apos;Variable:0&apos; shape=() dtype=int32_ref&gt;</span><br><span class="line">&gt;&gt;&gt; var1=tf.Variable(3,dtype=tf.int64)</span><br><span class="line">&gt;&gt;&gt; var1</span><br><span class="line">&lt;tf.Variable &apos;Variable_1:0&apos; shape=() dtype=int64_ref&gt;</span><br></pre></td></tr></table></figure><h4 id="Placeholder"><a href="#Placeholder" class="headerlink" title="Placeholder"></a>Placeholder</h4><p>必填项：dtype  其他：(shape,name)<br>先占住一个固定的位置，等着你之后往里面添加的一种</p><h4 id="SparseTensor-稀疏张量"><a href="#SparseTensor-稀疏张量" class="headerlink" title="SparseTensor(稀疏张量)"></a>SparseTensor(稀疏张量)</h4><p>平时用的比较少</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import tensorflow as tf</span><br><span class="line">t&gt;&gt;&gt; c=tf.constant([[2,3],[4,5]],name=&quot;const1&quot;,dtype=tf.int64)</span><br><span class="line">&gt;&gt;&gt; c</span><br><span class="line">&lt;tf.Tensor &apos;const1:0&apos; shape=(2, 2) dtype=int64&gt;</span><br><span class="line">&gt;&gt;&gt; sess=tf.Session()</span><br><span class="line">&gt;&gt;&gt; sess</span><br><span class="line">&lt;tensorflow.python.client.session.Session object at 0x11dedcd10&gt;</span><br><span class="line">&gt;&gt;&gt; sess.run(c)#只有通过sess.run方法才会运行</span><br><span class="line">array([[2, 3],</span><br><span class="line">       [4, 5]])</span><br><span class="line">&gt;&gt;&gt; print sess.run(c)</span><br><span class="line">[[2 3]</span><br><span class="line"> [4 5]]</span><br><span class="line"> </span><br><span class="line">&gt;&gt;&gt; if c.graph is tf.get_default_graph():#默认图不用创建</span><br><span class="line">...     print &quot;the graph of c is the default graph of the context&quot;</span><br><span class="line">... </span><br><span class="line">the graph of c is the default graph of the context</span><br></pre></td></tr></table></figure><p>完整创建和关闭Session的两种方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">#_*_coding:UTF-8 _*_</span><br><span class="line">#引入tensorflow</span><br><span class="line">import tensorflow as tf</span><br><span class="line">#创建两个常量</span><br><span class="line">const1=tf.constant([[2,2]])</span><br><span class="line">const2=tf.constant([[4],[4]])</span><br><span class="line"></span><br><span class="line">multiple=tf.matmul(const1,const2)</span><br><span class="line">#创建Session会话对象并把操作执行的结果赋值给result</span><br><span class="line">sess=tf.Session()</span><br><span class="line">result=sess.run(multiple)</span><br><span class="line">print (result)</span><br><span class="line"></span><br><span class="line">if const1.graph is tf.get_default_graph():</span><br><span class="line">        print(&quot;const1所在的图是上下文默认的图&quot;)</span><br><span class="line">#关闭已用完的Session（会话）</span><br><span class="line">sess.close()</span><br><span class="line"></span><br><span class="line">#第二种方法来创建和关闭Session</span><br><span class="line">with tf.Session() as sess:</span><br><span class="line">        result2=sess.run(multiple)</span><br><span class="line">        print(&quot;multiple运行结果是：%s&quot; %result2)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>tensorflow环境安装实践</title>
      <link href="/2019/06/08/tensorflow%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85%E5%AE%9E%E8%B7%B5/"/>
      <url>/2019/06/08/tensorflow%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85%E5%AE%9E%E8%B7%B5/</url>
      
        <content type="html"><![CDATA[<p>环境选择：<br>python2.7、mac<br>原因：<br>1、有个县城的项目是基于python2写的，希望可以运行。<br>2、参考此网站说明支持2.7，未提及3.x(可能还没更新)</p><h5 id="弯路1："><a href="#弯路1：" class="headerlink" title="弯路1："></a>弯路1：</h5><p>参考tf中文社区下载和安装步骤：<a href="http://www.tensorfly.cn/tfdoc/get_started/os_setup.html" target="_blank" rel="noopener">http://www.tensorfly.cn/tfdoc/get_started/os_setup.html</a><br>一共提供了四种方式，最后选择了从源码安装</p><ul><li>二进制安装</li><li>基于 Docker 的安装：<br> <em>之前试了很久也没成功过，再加上没找到python2.7的镜像</em></li><li>基于 VirtualEnv 的安装</li><li>从源码安装<br>安装 Bazel、SWIG（依赖PCRE）、Numpy，然后安装，最后一步失败了。</li></ul><p><img src="/images/pasted-0.png" alt="upload successful"></p><h4 id="弯路2："><a href="#弯路2：" class="headerlink" title="弯路2："></a>弯路2：</h4><p>探索使用二进制安装中提供的这个命令直接使用（是virtualenv 中的）：<br>$ pip install <a href="https://storage.googleapis.com/tensorflow/mac/tensorflow-0.5.0-py2-none-any.whl" target="_blank" rel="noopener">https://storage.googleapis.com/tensorflow/mac/tensorflow-0.5.0-py2-none-any.whl</a><br>结果果然不行</p><p><img src="/images/pasted-1.png" alt="upload successful"></p><h3 id="成功案例"><a href="#成功案例" class="headerlink" title="成功案例"></a>成功案例</h3><p>于是更改方案，找tf官网：<a href="https://tensorflow.google.cn/" target="_blank" rel="noopener">https://tensorflow.google.cn/</a></p><p>选择pip安装方式</p><ol><li>在系统上安装 Python 开发环境</li><li>创建虚拟环境（推荐</li><li>安装 TensorFlow pip 软件包</li></ol><p>选的是3中按系统安装：<br> pip install –user –upgrade tensorflow  </p><p> 但是无论怎样，都提示pip版本有问题</p><p><img src="/images/pasted-2.png" alt="upload successful"></p><p>于是安装pip：<br>直接按照提示升级安装？结果不行<br>pip install pip? 还是不行<br>下载源码安装？OK，安装日志大概20页。。<br><img src="/images/pasted-3.png" alt="upload successful"></p><p>然后再次安装tensorflow，第一次超时，第二次成功了（很慢，需要耐心等待）</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>python版本升级和卸载</title>
      <link href="/2019/06/08/python%E7%89%88%E6%9C%AC%E5%8D%87%E7%BA%A7/"/>
      <url>/2019/06/08/python%E7%89%88%E6%9C%AC%E5%8D%87%E7%BA%A7/</url>
      
        <content type="html"><![CDATA[<p>Linux安装python2.7、pip和setuptools写的特别详细：<br><a href="https://www.jianshu.com/p/200c9b9dcac8" target="_blank" rel="noopener">https://www.jianshu.com/p/200c9b9dcac8</a></p><p> 由python2.7升级至python3.x<br> linux:<br> <a href="https://blog.csdn.net/qq_37342157/article/details/81244667" target="_blank" rel="noopener">https://blog.csdn.net/qq_37342157/article/details/81244667</a><br> mac:<br><a href="https://www.cnblogs.com/cynthia-wuqian/p/9303514.html" target="_blank" rel="noopener">https://www.cnblogs.com/cynthia-wuqian/p/9303514.html</a></p><p>卸载python3 for mac:<br><a href="https://www.jianshu.com/p/98383a7688a5" target="_blank" rel="noopener">https://www.jianshu.com/p/98383a7688a5</a></p><ol><li>经验：【软连接】</li></ol><p><strong>ln -s建立软链接；不带-s建立的是硬链接<br>建立软连接：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@tv6-hotelqa-newhotel-17 bin]# ln -s /usr/local/python2.7/bin/pip2  /usr/bin/pip</span><br></pre></td></tr></table></figure><p>建立后效果：<br>相当于windows的快捷方式，搜索pip的时候相当于直接访问的对应的软链接pip2</p><p>==<strong>ln   -s    跳转的目录     快捷键</strong>==<br><img src="https://img-blog.csdnimg.cn/20181227184924613.png" alt="在这里插入图片描述"><br><strong>删除软连接：</strong><br><img src="https://img-blog.csdnimg.cn/20181227185207357.png" alt="在这里插入图片描述"><br>==切记：后面不要加“/”==，尽管知道这个点，但是手一抖删除了其对应软件的所有内容，不长教训不长记性啊</p><p><strong>取消链接</strong></p><pre><code>[root@tv6-hotelqa-newhotel-17 bin]# unlink python</code></pre><ol start="2"><li>升级带来的版本问题</li></ol><p>==<em>由python2升级至python3.X,但是python -V(或–version)总还是2.7版本，改了/usr/bin下的python软连各种，都不行（搞了好几个小时，眼快瞎了）</em>==<br><img src="https://img-blog.csdnimg.cn/2019022815140256.png" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/2019022816031164.png" alt="在这里插入图片描述"><br>试着更改环境变量：<br>echo $PATH查看环境变量<br>/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin:/root/bin<br>vi /etc/profile   source  /etc/profile 更改环境变量</p><h4 id="Finally："><a href="#Finally：" class="headerlink" title="Finally："></a>Finally：</h4><p>觉悟到是不是在别的路径，于是在环境变量中的usr/local/bin中找到了有个同名的python，原来指向的就是2.7.于是删除此软链，果然提示在该目录（即usr/local/bin）目录找不到python,这下狐狸尾巴露出来了吧~~ 于是添加指向到python3的软链，测试终于OK了，功夫不负苦心人到底！<br><img src="https://img-blog.csdnimg.cn/20190228162706440.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N1cGVyX2NoZW5seQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>html/css/js问题记录</title>
      <link href="/2018/10/07/html%20css%20js%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2018/10/07/html%20css%20js%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>1、出现中文乱码<br>检查是否添加</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta charset=&quot;utf-8&quot;/&gt;</span><br></pre></td></tr></table></figure><p>2、html将h2块元素与超链接a元素同行<br>解决方案：h2中添加style=”display:inline” ，变成行内元素</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;p&gt;&lt;h2 align=&quot;center&quot; style=&quot;display:inline&quot; &gt;&lt;font color=&quot;red&quot;&gt;常用链接-线上灰度不要用真实酒店&lt;/font&gt;&lt;/h2&gt;&lt;a href=&quot;http://10.160.84.95:8000/index/&quot; target=&quot;_blank&quot;&gt;&gt;&gt;体验新版&lt;/a&gt;&lt;/h2&gt;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>git使用篇</title>
      <link href="/2018/10/07/git%E7%AF%87/"/>
      <url>/2018/10/07/git%E7%AF%87/</url>
      
        <content type="html"><![CDATA[<p>git命令基础操作这篇文章很清楚：<a href="https://www.cnblogs.com/tocy/p/git-command-line-manual.html" target="_blank" rel="noopener">https://www.cnblogs.com/tocy/p/git-command-line-manual.html</a></p><h2 id="常见出错和问题"><a href="#常见出错和问题" class="headerlink" title="常见出错和问题"></a>常见出错和问题</h2><h6 id="1-出现error-The-following-untracked-working-tree-files-would-be-overwritten-by-checkout"><a href="#1-出现error-The-following-untracked-working-tree-files-would-be-overwritten-by-checkout" class="headerlink" title="1.  出现error: The following untracked working tree files would be overwritten by checkout"></a>1.  出现error: The following untracked working tree files would be overwritten by checkout</h6><p>解决： $ git clean -d -fx “”<br>参考   <a href="http://blog.chinaunix.net/uid-23366077-id-3581375.html" target="_blank" rel="noopener">http://blog.chinaunix.net/uid-23366077-id-3581375.html</a></p><h6 id="2-Git冲突：commit-your-changes-or-stash-them-before-you-can-merge-解决办法"><a href="#2-Git冲突：commit-your-changes-or-stash-them-before-you-can-merge-解决办法" class="headerlink" title="2. Git冲突：commit your changes or stash them before you can merge. 解决办法"></a>2. Git冲突：commit your changes or stash them before you can merge. 解决办法</h6><p>出现这个问题的原因是其他人修改了xxx.php并提交到版本库中去了，而你本地也修改了xxx.php，这时候你进行git pull操作就好出现冲突了，解决方法，在上面的提示中也说的很明确了。<br><a href="https://www.cnblogs.com/wenlj/p/5866356.html" target="_blank" rel="noopener">https://www.cnblogs.com/wenlj/p/5866356.html</a><br>1）直接commit本地的修改 —-也一般不用这种方法<br>2）通过git stash  —- 通常用这种方法</p><pre><code>git stashgit pullgit stash pop</code></pre><p>通过git stash将工作区恢复到上次提交的内容，同时备份本地所做的修改，之后就可以正常git pull了，git pull完成后，执行git stash pop将之前本地做的修改应用到当前工作区。</p><h6 id="3-github多人协作"><a href="#3-github多人协作" class="headerlink" title="3. github多人协作"></a>3. github多人协作</h6><p>1、创建组织–创建库，创建Team(邀请成员，设置每人owner权限，保证每人都可写)</p><p>参考：<a href="https://www.cnblogs.com/zhaoyanjun/p/5882784.html" target="_blank" rel="noopener">https://www.cnblogs.com/zhaoyanjun/p/5882784.html</a></p><h6 id="4-为GitLab帐号添加SSH-keys并连接GitLab"><a href="#4-为GitLab帐号添加SSH-keys并连接GitLab" class="headerlink" title="4.为GitLab帐号添加SSH keys并连接GitLab"></a>4.为GitLab帐号添加SSH keys并连接GitLab</h6><p><a href="https://blog.csdn.net/qq_21916259/article/details/81000723" target="_blank" rel="noopener">https://blog.csdn.net/qq_21916259/article/details/81000723</a><br>密匙生成成功之后，复制 .ssh目录下的id_rsa.pub文件中的密匙，添加gitLab上后就可以使用git clone …了<br>可以设置多个设备的秘钥，实现多设备共享。</p><h6 id="5-删除内容"><a href="#5-删除内容" class="headerlink" title="5. 删除内容"></a>5. 删除内容</h6>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git rm test.txt</span><br><span class="line">rm &apos;test.txt&apos;</span><br><span class="line"></span><br><span class="line">$ git commit -m &quot;remove test.txt&quot;</span><br><span class="line">[master d46f35e] remove test.txt</span><br><span class="line"> 1 file changed, 1 deletion(-)</span><br><span class="line"> delete mode 100644 test.txt</span><br></pre></td></tr></table></figure><h6 id="6-git提交代码时，出现这个错误“error-The-requested-URL-returned-error-403-Forbidden-while-accessing-https”"><a href="#6-git提交代码时，出现这个错误“error-The-requested-URL-returned-error-403-Forbidden-while-accessing-https”" class="headerlink" title="6. git提交代码时，出现这个错误“error: The requested URL returned error: 403 Forbidden while accessing https”"></a>6. git提交代码时，出现这个错误“error: The requested URL returned error: 403 Forbidden while accessing https”</h6><p>   解决：编辑.git目录下的config文件即可。</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vim .git/config</span><br><span class="line">#修改对于的配置</span><br><span class="line">#原来的url = https://github.com/elitecodegroovy/PhoenixC.git</span><br><span class="line"></span><br><span class="line">url = https://elitecodegroovy@github.com/elitecodegroovy/PhoenixC.git</span><br></pre></td></tr></table></figure><h6 id="7-git别人提交的时候冲突了，需要回退到之前某版本"><a href="#7-git别人提交的时候冲突了，需要回退到之前某版本" class="headerlink" title="7. git别人提交的时候冲突了，需要回退到之前某版本"></a>7. git别人提交的时候冲突了，需要回退到之前某版本</h6><p>   首先要git pull 否则直接按照以下的操作，最后还会提示pull</p><ol><li><p>查找历史版本<br>  使用git log命令查看所有的历史版本，获取你git的某个历史版本的id</p><p>  假设查到历史版本的id是fae6966548e3ae76cfa7f38a461c438cf75ba965。</p></li><li><p>恢复到历史版本<br>   $ git reset –hard fae6966548e3ae76cfa7f38a461c438cf75ba965</p></li><li><p>把修改推到远程服务器</p><pre><code>$ git push -f -u origin master  </code></pre><p>出错：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">remote: GitLab: You are not allowed to force push code to a protected branch on this project.</span><br><span class="line">To git.17usoft.com:app_test/doc.git</span><br><span class="line"> ! [remote rejected] master -&gt; master (pre-receive hook declined)</span><br><span class="line">error: failed to push some refs to &apos;git@git.17usoft.com:app_test/doc.git&apos;</span><br></pre></td></tr></table></figure></li></ol><p>原因：一般默认会开启保护模式，保护模式下不允许任何人push<br><img src="https://img-blog.csdnimg.cn/2019041712030931.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N1cGVyX2NoZW5seQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>解决：去掉保护模式<br><img src="https://img-blog.csdnimg.cn/20190417120340626.png" alt="在这里插入图片描述"></p><h6 id="8-GIT-warning-LF-will-be-replaced-by-CRLF问题解决方法"><a href="#8-GIT-warning-LF-will-be-replaced-by-CRLF问题解决方法" class="headerlink" title="8. [GIT] warning: LF will be replaced by CRLF问题解决方法"></a>8. [GIT] warning: LF will be replaced by CRLF问题解决方法</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git config --gobal core.autocrlf false</span><br></pre></td></tr></table></figure><h6 id="9-由于某配置项错误配置导致push失败，解决：删除配置项目"><a href="#9-由于某配置项错误配置导致push失败，解决：删除配置项目" class="headerlink" title="9. 由于某配置项错误配置导致push失败，解决：删除配置项目"></a>9. 由于某配置项错误配置导致push失败，解决：删除配置项目</h6><pre><code>1) git config --list 或者git config -l查看配置项2) git  config --global unset +配置项全名</code></pre><h6 id="10-、git-分支拉取"><a href="#10-、git-分支拉取" class="headerlink" title="10. 、git 分支拉取"></a>10. 、git 分支拉取</h6><p>   <a href="https://blog.51cto.com/13893093/2175764?source=dra" target="_blank" rel="noopener">https://blog.51cto.com/13893093/2175764?source=dra</a></p><ol><li>查看本地分支<br>$ git branch</li><li>查看远程分支<br>$ git branch -r</li><li>查看所有分支<br>$ git branch -a</li><li>拉取远程分支<br>新建一个空文件<br>初始化 git init<br>自己要与origin master建立连接（下划线远程仓库链接）<br>git remote add origin <a href="http://192.168.9.10:8888/root/game-of-life.git" target="_blank" rel="noopener">http://192.168.9.10:8888/root/game-of-life.git</a><br>把远程分支拉到本地（game-of-live-first_branch为远程仓库的分支名）<br>git fetch origin game-of-live-first_branch<br>在本地创建分支game-of-live-first_branch并切换到该分支<br>git checkout -b game-of-live-first_branch origin/game-of-live-first_branch<br>把game-of-live-first_branch远程分支上的内容都拉取到本地<br>git pull origin game-of-live-first_branch</li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Python--类成员</title>
      <link href="/2018/10/07/Python--%E7%B1%BB%E6%88%90%E5%91%98%E5%AD%A6%E4%B9%A0/"/>
      <url>/2018/10/07/Python--%E7%B1%BB%E6%88%90%E5%91%98%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<p><img src="https://img-blog.csdnimg.cn/20190218115154175.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N1cGVyX2NoZW5seQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/python</span><br><span class="line"># -*- coding: UTF-8 -*-</span><br><span class="line">#!/usr/bin/python</span><br><span class="line"># -*- coding: UTF-8 -*-</span><br><span class="line">class Foo():</span><br><span class="line">    #静态字段</span><br><span class="line">    country=&quot;公有静态字段&quot;</span><br><span class="line">    __name=&quot;私有静态字段&quot;#带有__开头属于私有</span><br><span class="line">    def __init__(self):</span><br><span class="line">    #普通字段</span><br><span class="line">        print (self.country)</span><br><span class="line">        print ( self.__name)#类内部可以访问私有</span><br><span class="line">    @staticmethod</span><br><span class="line">    def static_func():</span><br><span class="line">        &quot;&quot;&quot;定义静态方法，无默认参数&quot;&quot;&quot;</span><br><span class="line">        print (&apos;这个是静态方法&apos;)</span><br><span class="line">    @classmethod</span><br><span class="line">    def  class_func(cls):</span><br><span class="line">        print(&quot;这个是类方法&quot;)</span><br><span class="line">    def ord_func(self):</span><br><span class="line">        &quot;&quot;&quot;定义普通方法，至少有一个self参数&quot;&quot;&quot;</span><br><span class="line">        print(&quot;这个是普通方法&quot;)</span><br><span class="line">    @property</span><br><span class="line">    def price(self):</span><br><span class="line">        &quot;&quot;&quot;定义一个属性，有返回&quot;&quot;&quot;</span><br><span class="line">        return &quot;cheap&quot;</span><br><span class="line">class Foo_son(Foo):</span><br><span class="line">    def showcountry(self):</span><br><span class="line">        print (self.country)</span><br><span class="line">    def showname(self):</span><br><span class="line">        print (self.__name)</span><br><span class="line">Foo.static_func()#调用静态方法</span><br><span class="line">Foo.class_func()#调用类方法</span><br><span class="line">f=Foo()</span><br><span class="line">f.ord_func()#调用普通方法</span><br><span class="line">f.price#调用属性</span><br><span class="line">###################################################</span><br><span class="line">Foo.country #类可以访问公有字段</span><br><span class="line">f.country #对象可以访问公有字段</span><br><span class="line">#f.__name #错误，私有字段，类无法访问，只能；类内部使用</span><br><span class="line">####################################################</span><br><span class="line">f1=Foo_son()#创建派生类对象</span><br><span class="line">f1.showcountry()#派生类可以访问公有字段</span><br><span class="line">#f1.showname()# 错误,派生类无法访问私有字段</span><br></pre></td></tr></table></figure><p>*<em>私有属性是否可以被外部访问？ *</em></p><p>可以，但是需要使用_ClassName_methodName的形式如._Person__country(前面一条下划线，后面两条)</p><pre><code>class Person(object):    __country = &apos;China&apos; #私有属性    def __init__(self,name,age):        self.__query()    def __query(self):         print(&quot;country:%s&quot; % self.__country)gf = Person(&apos;林小花&apos;,18)print(gf.__country)#报错，不能直接访问gf.__country = &apos;America&apos; #非原来的私有属性，另外一个新字段了print(gf.__country)print(gf._Person__country)#原来字段没有变gf._Person__country = &apos;America2&apos; #使用类名可以访问私有属性print(gf.__country)print(gf._Person__country)#被改变成America2</code></pre><p> <strong>类方法和静态方法</strong></p><p> 类方法：将类本身作为对象进行操作的方法，第一个参数是cls，代表当前类对象，使用装饰器@classmethod。</p><p> 静态方法:是个独立的单纯的函数，不含有类或实例的任何属性和方法。</p><p> <strong>类变量和实例变量定义</strong></p><p>在类中声明的变量我们称之为类变量[静态成员变量]，</p><p>在init()函数中声明的变量并且绑定在实例上的变量我们称之为成员变量[实例变量]。</p><p>类变量直接可以通过类名来调用。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class Dog:</span><br><span class="line"></span><br><span class="line">   kind = &apos;canine&apos;         # class variable shared by all instances</span><br><span class="line"></span><br><span class="line">   def __init__(self, name):</span><br><span class="line">       self.name = name    # instance variable unique to each instance</span><br></pre></td></tr></table></figure><p><strong>类方法与成员方法</strong></p><p>类方法：使用类名来调用的方法</p><p>成员方法：使用对象来调用的方法</p><p>参考：<a href="https://www.jb51.net/article/159611.htm" target="_blank" rel="noopener">https://www.jb51.net/article/159611.htm</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>python3 HTTP请求</title>
      <link href="/2018/09/25/python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2018/09/25/python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>利用python作HTTP请求，主要分为以下两种方法</p><ol><li><p>** 使用urllib  **</p><p>在Python 3以后的版本中，urllib2这个模块已经不单独存在（也就是说当你import urllib2时，系统提示你没这个模块），urllib2被合并到了urllib中，叫做urllib.request 和 urllib.error 。</p><p>urllib整个模块分为urllib.request, urllib.parse, urllib.error。</p><p>例：<br>其中urllib2.urlopen()变成了urllib.request.urlopen()<br>urllib2.Request()变成了urllib.request.Request()<br>官网地址：<br><a href="https://docs.python.org/3.5/library/urllib.html" target="_blank" rel="noopener">https://docs.python.org/3.5/library/urllib.html</a></p></li></ol>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"># coding:utf-8</span><br><span class="line">from urllib import request</span><br><span class="line">from urllib import parse</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">url = &quot;http://10.1.2.151/ctower-mall-c/sys/login/login.do&quot;</span><br><span class="line">data = &#123;&quot;id&quot;:&quot;wdb&quot;,&quot;pwd&quot;:&quot;wdb&quot;&#125;</span><br><span class="line"></span><br><span class="line">params=&quot;?&quot;</span><br><span class="line">for key in data:</span><br><span class="line">    params = params + key + &quot;=&quot; + data[key] + &quot;&amp;&quot;</span><br><span class="line">print(&quot;Get方法参数：&quot;+params)</span><br><span class="line"></span><br><span class="line">headers = &#123;</span><br><span class="line">    #heard部分直接通过chrome部分request header部分</span><br><span class="line">    &apos;Accept&apos;:&apos;application/json, text/plain, */*&apos;,</span><br><span class="line">    &apos;Accept-Encoding&apos;:&apos;gzip, deflate&apos;,</span><br><span class="line">    &apos;Accept-Language&apos;:&apos;zh-CN,zh;q=0.8&apos;,</span><br><span class="line">    &apos;Connection&apos;:&apos;keep-alive&apos;,</span><br><span class="line">    &apos;Content-Length&apos;:&apos;14&apos;, #get方式提交的数据长度，如果是post方式，转成get方式：【id=wdb&amp;pwd=wdb】</span><br><span class="line">    &apos;Content-Type&apos;:&apos;application/x-www-form-urlencoded&apos;,</span><br><span class="line">    &apos;Referer&apos;:&apos;http://10.1.2.151/&apos;,</span><br><span class="line">    &apos;User-Agent&apos;:&apos;Mozilla/5.0 (Linux; Android 6.0; Nexus 5 Build/MRA58N) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/48.0.2564.23 Mobile Safari/537.36&apos;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">data = parse.urlencode(data).encode(&apos;utf-8&apos;)</span><br><span class="line">req = request.Request(url, headers=headers, data=data)  #POST方法</span><br><span class="line">#req = request.Request(url+params)  # GET方法</span><br><span class="line">page = request.urlopen(req).read()</span><br><span class="line">page = page.decode(&apos;utf-8&apos;)</span><br></pre></td></tr></table></figure><p>  【报错】<br>  python3 raise HTTPError(req.full_url, code, msg, hdrs, fp) urllib.error.HTTPError: HTTP Error 403: Forbid<br>  1.分析:</p><p>  如果用 urllib.request.urlopen 方式打开一个URL,服务器端只会收到一个单纯的对于该页面访问的请求,但是服务器并不知道发送这个请求使用的浏览器,操作系统,硬件平台等信息,而缺失这些信息的请求往往都是非正常的访问,例如爬虫.<br>  有些网站验证请求信息中的UserAgent(它的信息包括硬件平台、系统软件、应用软件和用户个人偏好),如果UserAgent存在异常或者是不存在,那么这次请求将会被拒绝(如上错误信息所示)<br>  所以可以尝试在请求中加入UserAgent的信息<br>  方案:<br>  对于Python 3.x来说,在请求中添加UserAgent的信息非常简单,代码如下:<br>  可以在请求加上头信息，伪装成浏览器访问User-Agent,具体的信息可以通过火狐的FireBug插件查询<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">headers = &#123;&apos;User-Agent&apos;:&apos;Mozilla/5.0 (Windows NT 6.1; WOW64; rv:23.0) Gecko/20100101 Firefox/23.0&apos;&#125;  </span><br><span class="line">req = request.Request(url=chaper_url, headers=headers)  </span><br><span class="line">page  = request.urlopen(req).read()</span><br></pre></td></tr></table></figure></p><p>   但是没有解决问题，我用的python3.4不知道是不是不支持，于是改用requests</p><ol start="2"><li>urllib.quote  </li></ol><p>参考：<a href="https://www.cnblogs.com/lyxdw/p/9935137.html" target="_blank" rel="noopener">https://www.cnblogs.com/lyxdw/p/9935137.html</a><br>最近在抓请求有个这样的get参数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%22pageIndex%22:0,%22pageSize%22:50,%22preference%22:%221563432582190%22,%22from%22:0%7D</span><br></pre></td></tr></table></figure><p>本来以为用urllib的urlencode结果死活不行，最后发现应该直接用quote。<br>再观察得知其中:/,这几个特殊字符没有转，所以safe中需要忽略处理。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">param=&apos;&#123;&quot;condition&quot;:&#123;&quot;servicename&quot;:&quot;/hotel/someinterface_POST&quot;&#125;,&quot;startTime&quot;:1563431682190,&quot;endTime&quot;:1563432582190,&quot;pageIndex&quot;:0,&quot;pageSize&quot;:50,&quot;preference&quot;:&quot;1563432582190&quot;,&quot;from&quot;:0&#125;)&apos;</span><br><span class="line">param=parse.quote(param.encode(&apos;utf-8&apos;),,safe=&apos;:/,&apos;)</span><br><span class="line">print (param)</span><br></pre></td></tr></table></figure><p>quote 和 urlencode 的区别:urlencode 需要用字典  quote单个字符就行了，因为quote只需要字符串就行了    </p><p>quote和quote_plus的区别：前者默认safe=’/‘；后者会将“空格”转换成“加号”，默认safe为空。</p><ol start="2"><li><p>requests模块 </p><p>参考<br><a href="https://blog.csdn.net/xuezhangjun0121/article/details/82024075" target="_blank" rel="noopener">https://blog.csdn.net/xuezhangjun0121/article/details/82024075</a><br>因为传入的参数是以json形式传入所以headers={‘Content-Type’:’application/json’}</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">url=&quot;http://127.0.0.1:5555/member/grade/query&quot;</span><br><span class="line">r=requests.post(url,headers=&#123;&apos;Content-Type&apos;:&apos;application/json&apos;&#125;,data=json.dumps(params))</span><br><span class="line">print (r.text)</span><br></pre></td></tr></table></figure></li></ol><p>或</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; payload = &#123;&apos;key1&apos;: &apos;value1&apos;, &apos;key2&apos;: [&apos;value2&apos;, &apos;value3&apos;]&#125;</span><br><span class="line">&gt;&gt;&gt; r = requests.get(&apos;http://httpbin.org/get&apos;, params=payload)</span><br><span class="line">&gt;&gt;&gt; print(r.url)</span><br><span class="line">http://httpbin.org/get?key1=value1&amp;key2=value2&amp;key2=value3#已被正确编码</span><br></pre></td></tr></table></figure><p>返回：   </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">r.encoding                       #获取当前的编码</span><br><span class="line">r.encoding = &apos;utf-8&apos;             #设置编码</span><br><span class="line">r.text                           #以encoding解析返回内容。字符串方式的响应体，会自动根据响应头部的字符编码进行解码。</span><br><span class="line">r.content                        #以字节形式（二进制）返回。字节方式的响应体，会自动为你解码 gzip 和 deflate 压缩。</span><br><span class="line"></span><br><span class="line">r.headers                        #以字典对象存储服务器响应头，但是这个字典比较特殊，字典键不区分大小写，若键不存在则返回None</span><br><span class="line"></span><br><span class="line">r.status_code                     #响应状态码</span><br><span class="line">r.raw                             #返回原始响应体，也就是 urllib 的 response 对象，使用 r.raw.read()   </span><br><span class="line">r.ok                              # 查看r.ok的布尔值便可以知道是否登陆成功</span><br><span class="line"> #*特殊方法*#</span><br><span class="line">r.json()                         #Requests中内置的JSON解码器，以json形式返回,前提返回的内容确保是json格式的，不然解析出错会抛异常</span><br><span class="line">r.raise_for_status()             #失败请求(非200响应)抛出异常</span><br></pre></td></tr></table></figure><p>待总结：<a href="https://2.python-requests.org//zh_CN/latest/user/quickstart.html" target="_blank" rel="noopener">https://2.python-requests.org//zh_CN/latest/user/quickstart.html</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>selenium实现web自动化</title>
      <link href="/2018/09/24/selenium/"/>
      <url>/2018/09/24/selenium/</url>
      
        <content type="html"><![CDATA[<h4 id="web自动化"><a href="#web自动化" class="headerlink" title="web自动化"></a>web自动化</h4><ul><li><p>pom模式：pageobjectmodel我理解是底层逻辑用例的分层</p><pre><code>1.底层封装：即driver层的封装如常用的定位元素方法、输入、键盘鼠标、切换frame以及测试报告HTMLTestRunner模板等2.page层：根据页面，写页面测试用例如输入登录名，输入密码，点击登录，获取信息后断言3.用例层：利用unittest框架，结合page页面功能结合生成一条条case继承TestCase基类创建用例，方法名均以test开头</code></pre></li><li><p>每个测试的关键是：调用assertEqual()来检查预期的输出；assertTure或assertFalse()来验证一个条件，调用assertRaise()抛出特定异常。从而产生最终结果报告。</p></li><li><p>unittest.main()提供了一个命令行接口</p></li><li><p>setUp()方法前置方法，teatDown()方法用于最后的清理工作。每个测试用例(方法)运行时这两个方法以及<strong>init</strong>()都会被调用一次，setUpclass()和tearDownClass()在所有用例执行前后分别执行。 </p></li><li><p>跳过测试：@unittest.skip(reason)</p><p>跳过被此装饰器装饰的测试。 reason 为测试被跳过的原因。</p></li></ul><h4 id="1-环境搭建"><a href="#1-环境搭建" class="headerlink" title="1.环境搭建"></a>1.环境搭建</h4><p>安装python环境，使用</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pip install selenium  </span><br><span class="line">pip show selenium   #验证</span><br></pre></td></tr></table></figure><p>下载对应浏览器版本驱动 <a href="http://npm.taobao.org/，" target="_blank" rel="noopener">http://npm.taobao.org/，</a><br>配置该驱动（可执行文件）到环境变量。完成后执行代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#coding=utf-8 </span><br><span class="line">from selenium import webdriver</span><br><span class="line">driver = webdriver.Chrome() </span><br><span class="line">driver.get(&quot;http://www.baidu.com&quot;)</span><br><span class="line">driver.find_element_by_id(&quot;kw&quot;).send_keys(&quot;Selenium2&quot;) </span><br><span class="line">driver.find_element_by_id(&quot;su&quot;).click() </span><br><span class="line">driver.quit()</span><br></pre></td></tr></table></figure><p>若正常运行则成功。  </p><h4 id="2-主要语法"><a href="#2-主要语法" class="headerlink" title="2.主要语法"></a>2.主要语法</h4><h5 id="2-1-定位页面元素的方法"><a href="#2-1-定位页面元素的方法" class="headerlink" title="2.1  定位页面元素的方法"></a>2.1  定位页面元素的方法</h5><pre><code>find_element_by_id() 通过元素的id来查找元素find_element_by_name() – 通过元素的name来查找元素find_element_by_class_name() – 通过class 来查找find_element_by_tag_name() – 通过元素的类型来查找，一般不用这种方式find_element_by_link_text() – 通过链接地址来查找元素find_element_by_partial_link_text()find_element_by_xpath() – 通过xpath来查找元素find_element_by_css_selector() – 通过css样式来查找元素</code></pre><p> 若需定位一组元素:</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> #coding=utf-8 </span><br><span class="line"> from selenium import webdriver </span><br><span class="line"> import os</span><br><span class="line">driver = webdriver.Firefox() </span><br><span class="line">file_path = &apos;file:///&apos; + os.path.abspath(&apos;checkbox.html&apos;) </span><br><span class="line">driver.get(file_path)</span><br><span class="line">#通过XPath找到type=checkbox的元素 </span><br><span class="line">#checkboxes = driver.find_elements_by_xpath(&quot;//input[@type=&apos;checkbox&apos;]&quot;)</span><br><span class="line">#通过CSS找到type=checkbox的元素 </span><br><span class="line">checkboxes = driver.find_elements_by_css_selector(&apos;input[type=checkbox]&apos;) </span><br><span class="line">for checkbox in checkboxes: </span><br><span class="line">checkbox.click()</span><br><span class="line"># 打印当前页面上type为checkbox的个数 </span><br><span class="line">print len(checkboxes)</span><br><span class="line"># 把页面上最后1个checkbox的勾给去掉 driver.find_elements_by_css_selector(&apos;input[type=checkbox]&apos;).pop().click()</span><br><span class="line">driver.quit()</span><br></pre></td></tr></table></figure><p>【注意点】  </p><ol><li>查找元素的两种方式对比   </li><li>pop使用，pop(1)是第二个</li></ol><h5 id="2-2-元素常用操作"><a href="#2-2-元素常用操作" class="headerlink" title="2.2  元素常用操作"></a>2.2  元素常用操作</h5><pre><code>clear() – 清除元素内容，一般是清除输入框中的数据send_keys() – 在元素中模拟按键输入click() – 点击元素submit()  -- 提交表单</code></pre><h5 id="2-3-获取元素信息"><a href="#2-3-获取元素信息" class="headerlink" title="2.3 获取元素信息"></a>2.3 获取元素信息</h5><pre><code>size：元素的大小text：元素内文本is_displayed( )  ：元素是否可见is_enabled()： 元素是否可用（一般用于判断按钮是否置灰）is_selected( ) ： 元素是否被选中（一般用于表单中的单选框和复选框）get_attribute ( ) ： 元素的属性（可以获取到所选标签内的属性信息）</code></pre><h5 id="2-4-浏览器操作和属性"><a href="#2-4-浏览器操作和属性" class="headerlink" title="2.4 浏览器操作和属性"></a>2.4 浏览器操作和属性</h5><pre><code>操作方法：    back（） 返回上一个页面forward（）进入下一个页面close（）关闭当前标签页quit（）关闭浏览器set_window_size(480,800) 设置浏览器大小（传参输入浏览器长、宽）maximize_window()  最大化浏览器refresh()  刷新页面属性：  current_url :当前页面的URL路径  title：当前页面的title名称  name：当前浏览器名称  page_source：当前html页面源码</code></pre><p><img src="%5Cimages%5Cpasted-71.png" alt="upload successful"><br>参考：<a href="https://blog.csdn.net/CCGGAAG/article/details/75309315" target="_blank" rel="noopener">https://blog.csdn.net/CCGGAAG/article/details/75309315</a></p><h5 id="2-4-鼠标事件-ActionChains"><a href="#2-4-鼠标事件-ActionChains" class="headerlink" title="2.4 鼠标事件  ActionChains"></a>2.4 鼠标事件  ActionChains</h5><p>使用前引入模块：from selenium.webdriver.common.action_chains import ActionChains</p><pre><code>ActionChains 类提供的鼠标操作的常用方法： perform() 执行所有 ActionChains 中存储的行为   context_click() 右击  double_click() 双击  drag_and_drop() 拖动  move_to_element() 鼠标悬停</code></pre><p>举例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#引入ActionChains类 from selenium.webdriver.common.action_chains import ActionChains</span><br><span class="line">...</span><br><span class="line">#定位到要右击的元素 </span><br><span class="line">right_click =driver.find_element_by_id(&quot;xx&quot;) #对定位到的元素执行鼠标右键操作 </span><br><span class="line">ActionChains(driver).context_click(right_click).perform()</span><br></pre></td></tr></table></figure><h5 id="2-5-键盘事件"><a href="#2-5-键盘事件" class="headerlink" title="2.5 键盘事件"></a>2.5 键盘事件</h5><p>   引入模块 from selenium.webdriver.common.keys import Keys</p><pre><code>fromselenium.webdriver.common.keys importKeys在使用键盘按键方法前需要先导入 keys 类包。下面经常使用到的键盘操作：send_keys(Keys.BACK_SPACE) 删除键（BackSpace）send_keys(Keys.SPACE) 空格键(Space)send_keys(Keys.TAB) 制表键(Tab)send_keys(Keys.ESCAPE) 回退键（Esc）send_keys(Keys.ENTER) 回车键（Enter）《Selenium2Python 自动化测试实战》样张81send_keys(Keys.CONTROL,&apos;a&apos;) 全选（Ctrl+A）send_keys(Keys.CONTROL,&apos;c&apos;) 复制（Ctrl+C）send_keys(Keys.CONTROL,&apos;x&apos;) 剪切（Ctrl+X）send_keys(Keys.CONTROL,&apos;v&apos;) 粘贴（Ctrl+V）send_keys(Keys.F1) 键盘 F1……send_keys(Keys.F12) 键盘 F12</code></pre><h5 id="2-6-切换frame"><a href="#2-6-切换frame" class="headerlink" title="2.6 切换frame"></a>2.6 切换frame</h5><ul><li><p>切换到一个frame中</p><pre><code>switch_to_frame(frame_reference)其中frame_reference：id、name、element(定位的某个元素)、索引</code></pre></li></ul><p>常用实例 ：   </p><pre><code># 定位父类层级iframeele_framest = driver.find_element_by_css_selector(&quot;#result &gt; iframe&quot;)# 切换到父类层级iframe-通过元素切换driver.switch_to_frame(ele_framest)或 driver.switch_to_frame(1)</code></pre><ul><li><p>切换到主界面</p><pre><code>switch_to_default_content()：</code></pre><p>  注：driver.switch_to_frame(None)等同于driver.switch_to_default_content()</p><h4 id="2-7-下拉框"><a href="#2-7-下拉框" class="headerlink" title="2.7 下拉框"></a>2.7 下拉框</h4><p>需引用：from selenium.webdriver.support.ui import Select</p></li></ul><p><img src="%5Cimages%5Cpasted-72.png" alt="upload successful"></p><p>select包内的方法详解</p><p>1.获取option元素</p><pre><code>options：获取包含select下拉框内所有option项element的列表all_selected_options: 获取当前选中项element的列表first_selected_option:获取所有下拉选项中的第一个选项的element（或者获取当前选中的这一项）</code></pre><p>2.选择option</p><pre><code>select_by_value(values)：选择option标签中value属性为：values的选项select_by_index(index_number)：选择索引为index_number的选项（索引从0开始）select_by_visible_text(text)：选择option选项内容为：text的选项</code></pre><p>3.复选select的情况（select标签中，multiple=”multiple”时，即可多选的select选择框）</p><pre><code>deselect_all: 取消所有已选择的选项deselect_by_value(values):取消选择option标签中value属性为：values的选项deselect_by_index(index_number)：取消选择索引为index_number的选项（索引从0开始）deselect_by_visible_text(text)：取消选择option选项内容为：text的选项</code></pre><p>实例片段：</p><pre><code>options=Select(ele_select).options #定位select元素for option in options:    print(option.text)Select(ele_select).select_by_value(&quot;2&quot;) #选择值是2的项sleep(1)first_selected_option=Select(ele_select).first_selected_optionprint(first_selected_option.text)#输出第一个选中项文案</code></pre><h5 id="2-8-等待"><a href="#2-8-等待" class="headerlink" title="2.8 等待"></a>2.8 等待</h5><p>具体参考原文：<a href="https://blog.csdn.net/CCGGAAG/article/details/86763952" target="_blank" rel="noopener">https://blog.csdn.net/CCGGAAG/article/details/86763952</a></p><ul><li><p>sleep是强制等待   </p></li><li><p>implicitly_wait()隐形等待 也称为全局等待 </p><p>隐形等待是设置了一个最长等待时间，如果在规定时间内网页加载完成，则执行下一步，否则一直等到时间截止，然后执行下一步。注意这里有一个弊端，那就是程序会一直等待整个页面加载完成，也就是一般情况下你看到浏览器标签栏那个小圈不再转，才会执行下一步</p><pre><code>driver.implicitly_wait(30)  # 隐性等待，最长等30秒</code></pre></li></ul><ul><li><p>WebDriverWait() 显示等待 </p><p>满足条件后继续执行，否则在设置时间过后抛出异常，一般由 until()（或 until_not()）方法配合使用。具体格式如下： </p><pre><code>WebDriverWait(driver, timeout, poll_frequency=POLL_FREQUENCY, ignored_exceptions=None)</code></pre><ul><li><p>driver 所创建的浏览器driver</p></li><li><p>timeout 最长时间长度（默认单位：秒）</p></li><li><p>poll_frequency 间隔检测时长（每）默认0.5秒</p></li><li><p>ignored_exceptions  方法调用中忽略的异常，默认只抛出：找不到元素的异常</p></li></ul><p>大部分返回True/False，极少数返回元素:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#需导入库</span><br><span class="line">from selenium.webdriver.support.ui import WebDriverWait</span><br><span class="line">...</span><br><span class="line">#部分关于元素定位的判断返回类型为：元素</span><br><span class="line">assert_ele = WebDriverWait(driver, 15, 0.5).until(Expect.presence_of_element_located((&quot;id&quot;, &quot;wd1&quot;)))</span><br><span class="line">print(&quot;返回类型 %s&quot; % assert_ele)</span><br></pre></td></tr></table></figure></li></ul><h4 id="2-9-until-until-not"><a href="#2-9-until-until-not" class="headerlink" title="2.9 until / until_not"></a>2.9 until / until_not</h4><p>直到调用的方法返回值为True</p><p>until(method, message=’’)</p><ul><li>method：expected_conditions库中定义的方法</li><li>message ：自定义报错信息<br>直到调用的方法返回值为False</li></ul><p>until_not(method, message=’’)</p><ul><li>method：expected_conditions库中定义的方法</li><li>message ：自定义报错信息</li></ul><h4 id="2-10-expected-conditions库title-is-title"><a href="#2-10-expected-conditions库title-is-title" class="headerlink" title="2.10 expected_conditions库title_is(title)"></a>2.10 expected_conditions库title_is(title)</h4><pre><code>title：期望的页面标题判断当前页面标题是否包含titletitle_contains(title)title：期望的页面标题判断此定位的元素是否存在presence_of_element_located(locator)locator：元素的定位信息判断页面网址中是否包含urlurl_contains(url)url：期望的页面网址判断页面网址是否为urlurl_to_be(url)url：期望的页面网址判断页面网址不是urlurl_changes(url)url：期望的页面网址判断此定位的元素是否可见visibility_of_element_located(locator)locator：元素的定位信息判断此元素是否可见visibility_of(element)element：所获得的元素判断此定位的一组元素是否至少存在一个presence_of_all_elements_located(locator)locator：元素的定位信息判断此定位的一组元素至少有一个可见visibility_of_any_elements_located(locator)locator：元素的定位信息判断此定位的一组元素全部可见visibility_of_all_elements_located(locator)locator：元素的定位信息判断此定位中是否包含text_的内容text_to_be_present_in_element(locator, text_)locator：元素的定位信息text_：期望的文本信息判断此定位中的value属性中是否包含text_的内容text_to_be_present_in_element_value(locator, text_)locator：元素的定位信息text_：期望的文本信息判断定位的元素是否为frame，并直接切换到这个frame中frame_to_be_available_and_switch_to_it(locator)locator：元素的定位信息判断定位的元素是否不可见invisibility_of_element_located(locator)locator：元素的定位信息判断此元素是否不可见invisibility_of_element(element)element：所获得的元素判断所定位的元素是否可见且可点击element_to_be_clickable(locator)locator：元素的定位信息判断此元素是否不可用staleness_of(element)element：所获得的元素判断该元素是否被选中element_to_be_selected(element)element：所获得的元素判断定位的元素是否被选中element_located_to_be_selected(locator)locator：元素的定位信息判断该元素被选中状态是否和期望状态相同element_selection_state_to_be(element,Boolean)element：所获得的元素Boolean：期望的状态（True/False）判断定位的元素被选中状态是否和期望状态相同element_located_selection_state_to_be(locator,Boolean)locator：元素的定位信息Boolean：期望的状态（True/False）判断当前浏览器页签数量是否为numnumber_of_windows_to_be(num)num：期望的页签数量判断此handles页签不是唯一打开的页签new_window_is_opened(handles)handles：页签判断是否会出现alert窗口警报alert_is_present()</code></pre><p> 示例：</p><pre><code> # WebDriverWait大部分方法返回类型为True\Falseassert_judge = WebDriverWait(driver, 15, 0.5).until_not(Expect.title_is(&quot;网易&quot;))print(&quot;返回类型 %s&quot; % assert_judge)# 判断失败后会报错assert_judge = WebDriverWait(driver, 5, 0.5).until(Expect.title_is(&quot;网易&quot;), &quot;错误信息：网页标题不是网易&quot;)</code></pre><ul><li><p>截图</p><pre><code>except :     driver.get_screenshot_as_file(&quot;D:\\baidu_error.jpg&quot;) </code></pre></li><li><p>基础api汇总</p><pre><code>#导入seleniumfrom selenium import webdriver#创建chrome驱动实例,打开浏览器driver=webdriver.Chrome()#浏览器最大化driver.maximize_window()#浏览器最小化driver.minimize_window()#获取浏览器当前窗口大小size=driver.get_window_size()#设置浏览器窗口大小driver.set_window_size(400,400)#打开指定网页driver.get(&quot;http://www.so.com&quot;)#获取当前页面的链接地址url=driver.current_urldriver.get(&quot;http://baike.so.com&quot;)#后退driver.back()#前进driver.forward()#浏览器退出driver.close()driver.quit()#截图driver.get_screenshot_as_png()driver.get_screenshot_as_base64()driver.get_screenshot_as_file(&quot;filename&quot;)driver.save_screenshot(&quot;filename&quot;)#切换到当前被操作元素ele=driver.switch_to.active_element#切换alert、confirm、prompt框alert = driver.switch_to.alert#切换到默认页面driver.switch_to.default_content()#切换iframedriver.switch_to.frame(&apos;frame_name&apos;)driver.switch_to.frame(1)driver.switch_to.frame(driver.find_elements_by_tag_name(&quot;iframe&quot;)[0])driver.switch_to.parent_frame()#获取浏览器所有句柄handles=driver.window_handles#获取当前句柄current_handle=driver.current_window_handledriver.switch_to.window()#执行js脚本driver.execute_script(&apos;script&apos;)</code></pre></li><li><p>什么是Page Object模型</p><p>创建一个PO模型对应创建页面上一个应用，该页面上的操作和熟悉可以基于这个模型创建对应的页面模型，这样可以减少代码冗余，增强代码的可读性和可维护性。</p></li></ul><h4 id="3-常见问题"><a href="#3-常见问题" class="headerlink" title="3. 常见问题"></a>3. 常见问题</h4><h6 id="3-1-定位元素时候报错or无法正确定位？"><a href="#3-1-定位元素时候报错or无法正确定位？" class="headerlink" title="3.1. 定位元素时候报错or无法正确定位？"></a>3.1. 定位元素时候报错or无法正确定位？</h6><p>解决：</p><ul><li><p>由于新页面没加载出来导致元素定位不到，可以加等待时间，推荐用try catch添加隐式等待。</p></li><li><p>查看元素外边是否被frame包围，若有则先切换到该frame下再定位元素</p><h6 id="3-2-css定位class元素报错？"><a href="#3-2-css定位class元素报错？" class="headerlink" title="3.2. css定位class元素报错？"></a>3.2. css定位class元素报错？</h6><p>需要注意的是：如果 class属性值 里带空格，用.来代替空格(下例中第二个点)</p><pre><code>driver.find_element_by_css_selector(&quot;.search-btn.tjclick&quot;).click()</code></pre><h6 id="3-3-element-click-intercepted-Element-…-is-not-clickable-at-point-453-328-Other-element-would-receive-the-click-……"><a href="#3-3-element-click-intercepted-Element-…-is-not-clickable-at-point-453-328-Other-element-would-receive-the-click-……" class="headerlink" title="3.3. element click intercepted: Element … is not clickable at point (453, 328). Other element would receive the click: ……"></a>3.3. element click intercepted: Element <span class="textC">…</span> is not clickable at point (453, 328). Other element would receive the click: ……</h6><p>意思是有其他的元素掩盖了需要点击的元素<br>解决：</p><pre><code>element = driver.find_element_by_css(&apos;div[class*=&quot;loadingWhiteBox&quot;]&apos;)driver.execute_script(&quot;arguments[0].click();&quot;, element)element = driver.find_element_by_css(&apos;div[class*=&quot;loadingWhiteBox&quot;]&apos;)webdriver.ActionChains(driver).move_to_element(element ).click(element ).perform()</code></pre></li></ul><p>原文链接：<a href="https://blog.csdn.net/WanYu_Lss/article/details/84137519" target="_blank" rel="noopener">https://blog.csdn.net/WanYu_Lss/article/details/84137519</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Vim命令及常见问题</title>
      <link href="/2018/09/16/Vim%E5%91%BD%E4%BB%A4%E5%8F%8A%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"/>
      <url>/2018/09/16/Vim%E5%91%BD%E4%BB%A4%E5%8F%8A%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>以:和/开头的命令都有历史纪录，可以首先键入:或/然后按上下箭头来选择某个历史命令。</p><h5 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h5><ol><li><p>光标定位 </p><pre><code>hjkl 上下左右移动0$  行首尾gg G   文首尾3G 进入第三行/string (n N 可以循环的) 快速定位到某一行 /^d   按照行搜索（注意）/txt$</code></pre></li><li><p>文本编辑(少量)</p><pre><code>复制 yy 3yy ygg(复制到行首) yG(复制到行尾) 删除 dd 3dd dgg(删除到行首) dG(删除到行尾) 粘贴 删除光标所在的字符x 删除光标后的字符D 删除这行光标后的所有字符r 可以用来修改一个字符u 撤销CTRL+r 反撤销</code></pre></li><li><p>进入其它模式   </p><pre><code>i 进入插入模式  当前字符前o 进入插入模式  另起一行A 进入插入模式  本行最后面</code></pre></li></ol><ul><li><p>可视化模式</p><pre><code>V   进可视块模式ctrl+v  进可视行模式R进替换模式块插入（在指定快前加入字符） 选择快，I 在块前插入字符，按esc一会就实现块替换：选择快，r输入替换的字符块删除：选择块，d|x块赋值，选择块，y</code></pre><p>   例子：多行剪切和粘贴</p><pre><code>定位鼠标到剪切的开始位置输入v键开始选择剪切的字符，或者V键是为了选择 整行移动方向键到结束的地方d键是剪切，y键是复制  x是删除移动鼠标到粘贴的位置输入P是在鼠标位置前粘贴，输入p键是在鼠标的位置后粘贴</code></pre></li><li><p>扩展命令模式</p><ul><li><p>保存退出</p><pre><code>:10 进入第10行:w 保存:q 退出:wq 保存并退出 :w! 强制保存:q! 不保存并退出 :wq! 强制保存退出选择块，r 输入替换的字符 选择块，d | x选择块，y:x保存并退出 ZZ</code></pre></li><li><p>查找替换</p><pre><code>:范围 s/old/new/选项:1,5 s/root/yang/:5,$ s/root/yang/ :1,$ s/root/yang/g:% s#/dev/sda#/var/ccc#g :,8 s/root/yang/:4,9 s/^#// :5,10 s/.*/#&amp;/=从1-5行的root 替换为yang$表示最后一行:% s/root/yang/g %表示全文 g表示全局从当前行到第8行 4-9行的开头#替换为空</code></pre></li><li><p>读入文件/写文件(另存为) :w</p><pre><code>:w /tmp/aaa.txt 另存为:1,3 w /tmp/2.txt :r /etc/hosts:5 r /etc/hosts</code></pre></li><li><p>设置环境 临时设置:</p><pre><code>:set nu    设置行号:set ic   ignore case不区分大小写:set ai    auto indent 自动缩进:set list   显示控制字符 :set nonu   取消操作:set noic   取消操作</code></pre></li><li><p>永久的环境:</p><pre><code>/etc/vimrc ~/.vimrc 修改vim环境配置文件 影响所有系统用户# vim ~/.vimrc 影响某一个用户</code></pre></li><li><p>其他</p><pre><code>  # vim -O /etc/hosts /etc/hostname ^ww切换   :qall退出# cp /etc/hosts hosts1# vimdiff /etc/hosts hosts1</code></pre></li></ul></li></ul><h5 id="详细命令"><a href="#详细命令" class="headerlink" title="详细命令"></a>详细命令</h5><p>一、光标控制命令</p><pre><code>命令                   移动 k                   向上移一行 j                   向下移一行 h                   向左移一个字符 l                   向右移一个字符 gg                  移到文件的首行 G                   移到文件的末行     H                   移到屏幕的第一行 w                   移到下一个字的开头 W                   移到下一个字的开头，忽略标点符号 e                   移到下一个字的结尾 E                   移到下一个字的结尾，忽略标点符号 ^                   移到当前行首 $                   移到当前行尾 {                   移到上一段开头 }                   移到上一段结尾 Enter               移到下一行行首</code></pre><p>二、在 vim 中添加文本</p><pre><code>命令                   插入 i                   在光标前插入文本 I                   在当前行首插入文本 a                   在光标后插入文本 A                   在当前行末插入文本 o                   在当前行的下边插入新行 O                   在当前行的上边插入新行 s                   删除光标所在处字符，并进入插入模式 S                   删除光标所在的行，并进入插入模式 :r filename         读入指定文件内容，并插在当前行后 :nr file            读入文件 file 内容，并插在第 n 行后 Esc                 回到命令模式</code></pre><p>三、在 vim 中删除文本</p><pre><code>命令                   删除 x                   删除光标处的字符 db                  删除光标前面的字 dw                  删至下一个字的开头 dd                  删除整行 :n,md               从第 m 行开始往前删除 n 行 d$                  从光标处删除到行尾 d^                  从光标处删除到行首</code></pre><p>四、在 vim 中查找与替换</p><pre><code>  命令                  查找与替换 /target               在文件中向前查找 target ?target               在文件中向后查找 target   n                    查找下一个   N                    查找上一个:set ic                查找时忽略大小写:set noic              查找时对大小写敏感  %s/text1/text2/g         在整个文件中查找text1并且替换为text2</code></pre><p>【注】其中s是查找search的意思，%是全文所有行，g全局即所有列</p><p>五、在 vim 中复制文本</p><pre><code>命令                      复制 yy                   复制当前行 nyy                  从当前开始复制n行  p                   粘贴至光标前  P                   粘贴至光标后  u                   撤消上一次修改  U                   撤消所有修改</code></pre><p>六、保存与退出vim</p><pre><code>命令                      保存或退出 :w                   保存文件但不退出 :w file              将修改保存在 file 中但不退出:wq 或 ZZ 或 :x         保存文件并退出   :q!                  不保存文件,强制退出   :e!                   放弃所有修改，从上次保存文件开始再编辑</code></pre><p>七、其他选项</p><pre><code> 选项                      作用 :set all             查看所有选项 :set nu              设置行号 :set showmode        显示是输入模式还是替换模式 :set ts=4            为文本输入设置 tab stops :set nonumber        取消显示行数：set number  显示行数 :.=                  查看当前行的行号 :=                   查看总行数 ctrl+g             显示文件名、当前的行号、文件的总行数和文件位置的百分比</code></pre><p>这篇文章主要介绍了linux中快速清空文件内容的几种方法,需要的朋友可以参考下</p><pre><code>$ : &gt; filename $ &gt; filename $ echo &quot;&quot; &gt; filename $ echo &gt; filename $ cat /dev/null &gt; filename</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Android命令篇</title>
      <link href="/2018/09/16/Linux%E5%91%BD%E4%BB%A4%E7%AF%87/"/>
      <url>/2018/09/16/Linux%E5%91%BD%E4%BB%A4%E7%AF%87/</url>
      
        <content type="html"><![CDATA[<ul><li>adb shell pm   <a href="https://www.cnblogs.com/FlyToDream/p/10419755.html" target="_blank" rel="noopener">https://www.cnblogs.com/FlyToDream/p/10419755.html</a><br>adb pm  enable com.android.systemui</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Django项目实例精讲</title>
      <link href="/2018/09/09/Django%E9%A1%B9%E7%9B%AE%E5%AE%9E%E4%BE%8B%E7%B2%BE%E8%AE%B2/"/>
      <url>/2018/09/09/Django%E9%A1%B9%E7%9B%AE%E5%AE%9E%E4%BE%8B%E7%B2%BE%E8%AE%B2/</url>
      
        <content type="html"><![CDATA[<h4 id="认识Django"><a href="#认识Django" class="headerlink" title="认识Django"></a>认识Django</h4><ol><li><p>Python下有许多款不同的 Web 框架。Django是<strong>重量级</strong>选手中最有代表性的一位。许多成功的网站和APP都基于Django。</p></li><li><p>Django是一个<strong>开放源代码</strong>的Web应用框架，由<strong>Python</strong>写成。</p></li><li><p>Django采用了MVC的软件设计模式，即模型M，视图V和控制器C</p></li></ol><h4 id="1-创建隔离的python环境"><a href="#1-创建隔离的python环境" class="headerlink" title="1. 创建隔离的python环境"></a>1. 创建隔离的python环境</h4><p>推荐文章：<a href="https://www.cnblogs.com/jasmine-Jobs/p/7045016.html" target="_blank" rel="noopener">https://www.cnblogs.com/jasmine-Jobs/p/7045016.html</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pip install virtualenv #安装</span><br><span class="line">virtualenv my_env#创建目录</span><br><span class="line">which python3  #找到python3目录</span><br><span class="line">virtualenv my_env -p /Library/Frameworks/Python.framework/Versions/3.7/bin/python3 </span><br><span class="line">#将python3作为解释器</span><br><span class="line">source my_env/bin/activate  #激活，开始使用</span><br><span class="line">deactivate 退出</span><br></pre></td></tr></table></figure><h4 id="2-安装Django"><a href="#2-安装Django" class="headerlink" title="2. 安装Django"></a>2. 安装Django</h4><p> pip install Django==2.0.5</p><h4 id="3-创建项目"><a href="#3-创建项目" class="headerlink" title="3. 创建项目"></a>3. 创建项目</h4><p>  Django-admin startproject mysite<br>    mysite/项目结构：<br>        manage.py<br>        mysite/<br>              &nbsp;<em>&nbsp;<strong>init</strong>.py<br>              &nbsp;</em>&nbsp;<em>setting.py<br>             &nbsp;</em> &nbsp;<em>url.py<br>              &nbsp;</em>&nbsp;_wsgi.py<br>python manage.py migrate  #通过数据库迁移，初始状态下的应用程序表将在数据库中被创建。<br>创建完成后，根目录里应该多了个db.sqlite3</p><h4 id="4-运行开发服务器"><a href="#4-运行开发服务器" class="headerlink" title="4.  运行开发服务器"></a>4.  运行开发服务器</h4><pre><code>python manage.py runserver- 认识项目设置setting.py    DEBUG在生产环境下应该置为False. - 项目和应用程序 “项目”我理解为所有应用程序基于某些设置项的安装结果。 “应用程序”（即app，也就是下文中的blog）是模型+试图+模板+url 的组合 应用程序与框架进行交互，提供特定的功能。</code></pre><h4 id="5-创建应用程序"><a href="#5-创建应用程序" class="headerlink" title="5.  创建应用程序"></a>5.  创建应用程序</h4><p> 继续在虚拟环境里执行 python manage.py  startapp blog<br>此时多了个blog/目录 和下面文件如下：<br>admin.py 可在该文件中注册模型<br>app.py 包含了blog这个应用程序主要配置内容（之后在激活app时候用到）<br>migrations包含了应用程序(app)的数据库迁移。迁移可以使Django跟踪模块 变化内容，并相应的同步数据库。<br>model.py 包含了应用程序的数据模型，但是也可以被置空。<br>test.py 用来测试的<br>views.py包含逻辑内容  </p><h4 id="6-数据模型"><a href="#6-数据模型" class="headerlink" title="6. 数据模型"></a>6. 数据模型</h4><p> 每个模型是一个python类，为django.db.models.Model的子类，每个属性视为数据库的一个字段。  </p><ul><li>创建model.py文件中的数据表（即各python类）</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">from django.db import models</span><br><span class="line">from django.utils import timezone</span><br><span class="line">from  django.contrib.auth.models import User</span><br><span class="line"># Create your models here.</span><br><span class="line"></span><br><span class="line">class Post(models.Model):</span><br><span class="line">    STATUS_CHOICE=((&apos;draft&apos;,&apos;Draft&apos;),(&apos;published&apos;,&apos;Published&apos;))</span><br><span class="line">    title=models.CharField(max_length=250)</span><br><span class="line">    slug=models.SlugField(max_length=250,unique_for_date=&apos;publish&apos;)</span><br><span class="line">    author=models.ForeignKey(User,on_delete=models.CASCADE,related_name=&apos;blog_posts&apos;,default=&quot;&quot;)</span><br><span class="line">    body=models.TextField(default=&quot;&quot;)</span><br><span class="line">    publish=models.DateTimeField(default=timezone.now)</span><br><span class="line">    created=models.DateTimeField(auto_now_add=True)</span><br><span class="line">    #auto_now_add=True：实例在第一次保存的时候自动保存当前时间，不能手动修改(但相对于auto_now，auto_now_add下次是可以的)。</span><br><span class="line">    status=models.CharField(max_length=10,choices=STATUS_CHOICE,default=&apos;draft&apos;)</span><br><span class="line">    class Meta:</span><br><span class="line">        ordering=(&apos;-publish&apos;,)</span><br><span class="line">    def __str__(self):</span><br><span class="line">        return self.title</span><br></pre></td></tr></table></figure><p>其中ForeignKey 的用法，待总结。。</p><ul><li><p>为了使Django跟踪应用程序并针对模型创建数据表，我们需要激活：<br>&nbsp; &nbsp;编辑setting.py文件，像INSTALLED_APPS设置中加入app.py中所用到的类BlogConfig。格式为’blog.apps.BlogConfig’（若使用pycharm等IDE可能会给自动创建，可省略此步）</p></li><li><p>迁移两步走<br>创建了数据模型，我们最终需要的是定义<strong>数据库</strong>表，所以我们需要迁移：<br>1）python manage.py makemigrations blog  #让 Django 知道我们在我们的模型有一些变更，此时生成了0001_initial.py文件</p><pre><code>python manage.py sqlmigrate blog 0001 #命令可以查看某次迁移的SQL语句。</code></pre><p>2） python manage.py migrate  #将数据库与模型最终同步。</p><h4 id="7-站点管理"><a href="#7-站点管理" class="headerlink" title="7. 站点管理"></a>7. 站点管理</h4></li><li><h6 id="登录"><a href="#登录" class="headerlink" title="登录"></a>登录</h6><p>什么是站点？<br>对应的是之前说的admin.py应用。只要启动项目后，打开/admin/路径即可。<br>但是前提是需要创建超级用户（不然也登不进去呀）<br>python manage.py createsuperuser</p></li><li><h5 id="向站点添加模型"><a href="#向站点添加模型" class="headerlink" title="向站点添加模型"></a>向站点添加模型</h5><p>重点来啦<del>~</del> 怎么把模型添加到站点，以后方便我们维护呢？<br>编辑admin.py文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">from django.contrib import admin</span><br><span class="line">from .models import Post.</span><br><span class="line">admin.site.register(Post)  # 注册模型</span><br></pre></td></tr></table></figure></li></ul><p>之后打开站点就可以看到我们的模型啦，打开后就可以进行维护啦</p><h4 id="8-定制模型的显示方式"><a href="#8-定制模型的显示方式" class="headerlink" title="8.  定制模型的显示方式"></a>8.  定制模型的显示方式</h4><p>待整理</p><h4 id="9-QuerySet和管理器"><a href="#9-QuerySet和管理器" class="headerlink" title="9. QuerySet和管理器"></a>9. QuerySet和管理器</h4><ul><li><h6 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h6><p>方法一：两步走</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">post=Post(title=&quot;tile&quot;,slug=&quot;sss&quot;,body=&quot;post body&quot;,suthor=user)</span><br><span class="line">#未插入到数据库</span><br><span class="line">post.save()</span><br><span class="line">#真正执行Insert操作</span><br></pre></td></tr></table></figure><p>方法二：一步到位<br>创建对象，并将其持久化至数据库中</p></li></ul><p><code>Post.objects.create(title=&quot;tile&quot;,slug=&quot;sss&quot;,body=&quot;post body&quot;,suthor=user)</code></p><ul><li><h6 id="更新对象"><a href="#更新对象" class="headerlink" title="更新对象"></a>更新对象</h6>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">post.title=&quot;new title&quot;</span><br><span class="line">post.save()</span><br></pre></td></tr></table></figure><ul><li><h6 id="获取对象"><a href="#获取对象" class="headerlink" title="获取对象"></a>获取对象</h6>Django默认管理器objects。通过该管理器得到一个QuerySet对象,常用的方法有<br>Post.objects.all()<br>Post.objects.get(username=’admin’)<br>Post.objects.filter(publish__year=2017)<br>Post.objects.exclude(publish__year=2017)#排除<br>Post.objects.order_by(‘title’)默认升序，降序改为’-title’</li></ul><p>其他方法可参考官网：<a href="https://docs.djangoproject.com/en/2.0/ref/models" target="_blank" rel="noopener">https://docs.djangoproject.com/en/2.0/ref/models</a></p></li><li><h6 id="删除对象"><a href="#删除对象" class="headerlink" title="删除对象"></a>删除对象</h6><p>post=Post.objects.get(username=’admin’)<br>post.delete()</p><h4 id="10-创建视图"><a href="#10-创建视图" class="headerlink" title="10. 创建视图"></a>10. 创建视图</h4></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">from django.shortcuts import render,get_object_or_404</span><br><span class="line">#get_object_or_404 若结果不存在则抛出404异常</span><br><span class="line"></span><br><span class="line">from .models import Post</span><br><span class="line"></span><br><span class="line">def blog_list(request):</span><br><span class="line">    post_result=Post.objects.all()</span><br><span class="line">    return  render(request,&apos;post/list.html&apos;,&#123;&apos;post_value&apos;:post_result&#125;)</span><br><span class="line">    #这里返回的字段中的Key即post_value用于在模板中引用</span><br><span class="line">def blog_detail(request,year,month,day,slug):</span><br><span class="line">    post_result=get_object_or_404(Post,slug=slug,publish__year=year,publish__month=month,publish__day=day)</span><br><span class="line">    return  render(request,&apos;post/detail.html&apos;,&#123;&apos;post_value&apos;:post_result&#125;)</span><br></pre></td></tr></table></figure><h4 id="11-URL"><a href="#11-URL" class="headerlink" title="11. URL"></a>11. URL</h4><p>这里分为两部分（当然也可以直接在项目url中一步到位，但是在有多个APP的情况下结构清晰，推荐两步）：<br>第一步：创建应用程序的url ：<br>blog/urls.py:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">from django.urls import path</span><br><span class="line">from . import  views</span><br><span class="line"></span><br><span class="line">app_name=&apos;blog&apos;  #本url的命名空间，被引用时使用</span><br><span class="line"></span><br><span class="line">urlpatterns=[</span><br><span class="line">    path(&apos;&apos;,views.blog_list,name=&apos;list_name&apos;),</span><br><span class="line">    path(&apos;&lt;int:year&gt;/&lt;int:month&gt;/&lt;int:day&gt;/&lt;slug:slug&gt;/&apos;,views.blog_detail,name=&apos;detail_name&apos;)</span><br><span class="line">#路径中变量由上一级传参，动态</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>项目urls.py:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">from django.contrib import admin</span><br><span class="line">from django.urls import path,include</span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">    path(&apos;admin/&apos;, admin.site.urls),</span><br><span class="line">    path(&apos;post/&apos;,include(&apos;blog.urls&apos;,namespace=&apos;blog&apos;))#引用用应用程序，使用命名空间</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>为了获取url路径需要使用reverse方法，在models.py中添加此函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">def get_absolute_url(self):</span><br><span class="line">    return reverse(&apos;blog:detail_name&apos;,args=[self.publish.year,self.publish.month,self.publish.day ,self.slug])</span><br></pre></td></tr></table></figure><h4 id="12-创建模板文件"><a href="#12-创建模板文件" class="headerlink" title="12. 创建模板文件"></a>12. 创建模板文件</h4><p>一个基文件base.html和两个继承文件，目录：<br>base.html<br>post/<br>&nbsp;&nbsp;&nbsp;list.html<br>&nbsp;&nbsp;&nbsp;detail.html<br>base.html:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#123;% load static %&#125;  # 加载静态文件</span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;&#123;% block title %&#125;&#123;% endblock %&#125;&lt;/title&gt;</span><br><span class="line">    &lt;link href=&quot;&#123;% static &quot;css/blog.css&quot; %&#125;&quot; rel=&quot;stylesheet&quot;&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;div id=&quot;content&quot;&gt;</span><br><span class="line">    &#123;% block content %&#125;</span><br><span class="line">    &#123;% endblock %&#125;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;div id=&quot;sidebar&quot;&gt;</span><br><span class="line">    &lt;h2&gt;My base blog&lt;/h2&gt;</span><br><span class="line">    &lt;p&gt;this is my base blog;&lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>list.html：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;% extends &quot;base.html&quot; %&#125;  #继承</span><br><span class="line">&#123;% block title %&#125;My Blog&#123;% endblock %&#125;</span><br><span class="line">&#123;% block content %&#125;</span><br><span class="line">&lt;h1&gt;MY BLOG FOR LIST&lt;/h1&gt;</span><br><span class="line">    &#123;% for p in post_value %&#125;</span><br><span class="line">    &lt;h2&gt;</span><br><span class="line">    &lt;a href=&quot;&#123;&#123; p.get_absolute_url&#125;&#125;&quot;&gt;  #使用此方法获取url</span><br><span class="line">        &#123;&#123; p.title&#125;&#125;&lt;/a&gt;</span><br><span class="line">    &lt;/h2&gt;</span><br><span class="line"></span><br><span class="line">    &lt;p class=&quot;date&quot;&gt;Published&#123;&#123; p.publish &#125;&#125;by &#123;&#123; p.author &#125;&#125;&lt;/p&gt;</span><br><span class="line">    &#123;&#123; p.body|truncatewords:30|linebreaks &#125;&#125;</span><br><span class="line">    &#123;% endfor %&#125;</span><br><span class="line">&#123;% endblock %&#125;</span><br></pre></td></tr></table></figure><p>detail.html:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;% extends &quot;base.html&quot; %&#125;</span><br><span class="line">&#123;% block title %&#125;&#123;&#123;post.title&#125;&#125;&#123;% endblock %&#125;</span><br><span class="line">&#123;% block content %&#125;</span><br><span class="line">    &lt;h1&gt;&#123;&#123;post_value.title&#125;&#125;&lt;/h1&gt;</span><br><span class="line">    &lt;p id =&quot;date&quot;&gt;</span><br><span class="line">    published &#123;&#123; post_value.publish&#125;&#125;by&#123;&#123; post_value.author &#125;&#125;</span><br><span class="line">    &lt;/p&gt;</span><br><span class="line">    &#123;&#123; post_value.body|linebreaks &#125;&#125;</span><br><span class="line">&#123;% endblock %&#125;</span><br></pre></td></tr></table></figure><h2 id="【问题汇总】："><a href="#【问题汇总】：" class="headerlink" title="【问题汇总】："></a>【问题汇总】：</h2><ul><li>[1 ]  <code>File &quot;manage.py&quot;, line 14) from exc^SyntaxError: invalid syntax</code></li></ul><p>解决：使用virtualenv来做环境，更改pycharm中设置的编译器地址。</p><ul><li><p>[ 2] <code>You are trying to add a non-nullable field &#39;author&#39; to post without a default; we can&#39;t do that (the database needs something to populate existing rows)</code><br>解决：在每个报错字段的后面加一个default=””即可</p></li><li><p>[ 3]<code>blog.Post.created: (fields.E160) The options auto_now, auto_now_add, and default are mutually exclusive. Only one of these options may be present</code><br>经过：因为后面追加上默认值default=timezone.now，提示auto_now_add=Ture与其不能共存，在网上一时也没找到更加合适的办法<br>解决：第一次就只加默认值，指定两步迁移到数据库表；之后去掉default再次修改为auto_now_add=Ture，迁移成功。其中：<br>DateTimeField、DateField和TimeField三种类型可以用来创建日期字段，其值分别对应着datetime()、date()、time()三中对象。这三个field有着相同的参数auto_now和auto_now_add，</p></li></ul><p>-[ 4]pycharm添加env python编译环境</p><p>setting-project中可添加和删除编译环境选项<br><img src="/images/pasted-19.png" alt="upload successful"><br>使用Pycharm给其配置编译器,提示pycharm配置虚拟环境    Envirement  location directory is not empty<br>解决办法：将原来的代码里错误环境的目录找到，然后将venv删掉，再重新进来进行如下配置就没问题了<br><img src="/images/pasted-20.png" alt="upload successful"></p><p>配置完成后，还是不对<br><img src="/images/pasted-21.png" alt="upload successful"></p><p><img src="/images/pasted-22.png" alt="upload successful"><br>换成下面的Existing environment成功<br><img src="/images/pasted-23.png" alt="upload successful"><br>配置项目，编译器改成刚才Pycharm设置好的那个</p><p><img src="/images/pasted-25.png" alt="upload successful"></p><p><img src="/images/pasted-24.png" alt="upload successful"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>awk知识点汇总</title>
      <link href="/2018/08/22/awk%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/"/>
      <url>/2018/08/22/awk%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/</url>
      
        <content type="html"><![CDATA[<p>参考原文：<a href="https://blog.csdn.net/liang5603/article/details/80855426" target="_blank" rel="noopener">https://blog.csdn.net/liang5603/article/details/80855426</a></p><p>grep sed awk 被称为linux中的“三剑客”<br>grep更适合单纯的查找或匹配文本<br>sed更适合编辑匹配到的文本<br>awk更适合格式化文本，对文本进行较复杂格式处理</p><h5 id="awk语法："><a href="#awk语法：" class="headerlink" title="awk语法："></a>awk语法：</h5><pre><code>awk [options] &apos;commands&apos; filenames- options:-F 定义输入字段分隔符，默认的分隔符是空格或制表符(tab)- command:    BEGIN{} {} END{}    行处理前 行处理 行处理后</code></pre><p>  例：      </p><pre><code>$ awk &apos;BEGIN{print &quot;begin:&quot;1/2}{print &quot;ok&quot;}END{print&quot;--ending-&quot;}&apos; vimtest.txt begin:0.5okok--ending-    </code></pre><h5 id="awk执行原理"><a href="#awk执行原理" class="headerlink" title="awk执行原理"></a>awk执行原理</h5><ol><li>awk 使用一行作为输入，并将这一行赋给内部变量$0，每一行也可称为一个记录，以换行符结束</li></ol><ul><li>(2)然后，行被: (默认为空格或制表符)分解成字段(或域)，每个字段存储在已编号的变量中，从$1 开始，最多达 100 个字段</li><li>(3)awk 如何知道用空格来分隔字段的呢? 因为有一个内部变量 FS 来确定字段分隔符。初始 时，FS 赋为空格</li><li>(4)awk 打印字段时，将以设置的方法使用 print 函数打印，打印时逗号映射为OFS默认为空格</li></ul><h5 id="字段解释"><a href="#字段解释" class="headerlink" title="字段解释"></a>字段解释</h5><pre><code>$0: awk 变量$0 保存当前记录的内容 # awk -F: &apos;{print $0}&apos; /etc/passwdNR: The total number of input records seen so far. # awk -F: &apos;{print NR, $0}&apos; /etc/passwd /etc/hosts  （序号值）FNR: The input record number in the current input file # awk -F: &apos;{print FNR, $0}&apos; /etc/passwd /etc/hostsNF: 保存记录的字段数，$1,$2...$100 # awk -F: &apos;{print $0,NF}&apos; /etc/passwd$NF:因为NF是数字，这个就是最大数的变量值即最后一个字段值FS: 输入字段分隔符，默认空格 # awk -F: &apos;/alice/{print $1, $3}&apos; /etc/passwd# awk -F&apos;[ :\t]&apos; &apos;{print $1,$2,$3}&apos; /etc/passwd# awk &apos;BEGIN{FS=&quot;:&quot;} {print $1,$3}&apos; /etc/passwdOFS: 输出字段分隔符 # awk -F: &apos;/alice/{print $1,$2,$3,$4}&apos; /etc/passwd# awk &apos;BEGIN{FS=&quot;:&quot;; OFS=&quot;+++&quot;} /^root/{print $1,$2,$3,$4}&apos; /etc/passwdRS The input record separator, by default a newline. # awk -F: &apos;BEGIN{RS=&quot; &quot;} {print $0}&apos; a.txtORS The output record separator, by default a newline. # awk -F: &apos;BEGIN{ORS=&quot;&quot;} {print $0}&apos; passwd</code></pre><ul><li><p>awk是<strong>逐行</strong>处理的，处理完一行再处理下一行，默认以“换行符”为标记，识别每一行。   </p></li><li><p><strong>awk可用于拼接</strong>。被拼接字符串用双引号括起来 如：awk’{print “column1:”$1,”column2:”$2}’,注意$1这种内置变了不能使用双引号，否则被当做普通文本输出。</p></li><li><p><strong>awk变量</strong>: 分为<strong>内置变量</strong>和自定义变量</p></li><li><p><strong>过滤操作</strong> ：结合运算符在action中判断如awk ‘$1&gt;20’ log.txt 输出第一列值大于2的记录</p></li></ul><blockquote><p>细心如你一定注意到了一个细节，就是在打印 $0 , $1, $2 这些内置变量的时候，都有使用到”$”符号，但是在调用 NR , NF 这些内置变量的时候，就没有使用”$”，如果你有点不习惯，那么可能是因为你已经习惯了使用bash的语法去使用变量，在bash中，我们在引用变量时，都会使用$符进行引用，但是在awk中，只有在引用$0、$1等内置变量的值的时候才会用到”$”,引用其他变量时，不管是内置变量，还是自定义变量，都不使用”$”,而是直接使用变量名。</p></blockquote><h6 id="匹配记录"><a href="#匹配记录" class="headerlink" title="匹配记录"></a>匹配记录</h6><pre><code># awk -F: &apos;$1 ~ /^alice/&apos; /etc/passwd# awk -F: &apos;$NF !~ /bash$/&apos; /etc/passwd</code></pre><h6 id="比较表达式"><a href="#比较表达式" class="headerlink" title="比较表达式"></a>比较表达式</h6><p>条件表达式</p><pre><code># awk -F: &apos;$3&gt;300 {print $0}&apos; /etc/passwd# awk -F: &apos;{ if($3&gt;300) print $0 }&apos; /etc/passwd# awk -F: &apos;{ if($3&gt;300) {print $0} }&apos; /etc/passwd# awk -F: &apos;{ if($3&gt;300) {print $3} else{print $1} }&apos; /etc/passwd</code></pre><p>算数运算</p><pre><code># awk -F: &apos;$3 * 10 &gt; 500&apos; /etc/passwd# awk -F: &apos;{ if($3*10&gt;500){print $0} }&apos; /etc/passwd</code></pre><p>逻辑运算</p><pre><code># awk -F: &apos;$1~/root/ &amp;&amp; $3&lt;=15&apos; /etc/passwd # awk -F: &apos;$1~/root/ || $3&lt;=15&apos; /etc/passwd# awk -F: &apos;!($1~/root/ || $3&lt;=15)&apos; /etc/passwd</code></pre><h6 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h6><pre><code>awk -F: &apos;{if($3==0){i++} else if($3&gt;999){k++} else{j++}} END{print i; print k; print j}&apos; /etc/passwd[root@tianyun ~]# awk -F: &apos;{i=1; while(i&lt;=10) {print $0; i++}}&apos; /etc/passwd //将每行打印 10 次[root@tianyun ~]# awk -F: &apos;{ for(i=1;i&lt;=10;i++) {print $0} }&apos; /etc/passwd //将每行打印 10 次</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>常用的web服务器</title>
      <link href="/2018/08/12/%E5%B8%B8%E7%94%A8%E7%9A%84web%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
      <url>/2018/08/12/%E5%B8%B8%E7%94%A8%E7%9A%84web%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<p>参考：<a href="http://www.coozhi.com/youxishuma/g4/63698.html" target="_blank" rel="noopener">http://www.coozhi.com/youxishuma/g4/63698.html</a></p><ol><li>Apache<br>也被叫做httpd服务器，是目前使用<strong>最广泛的</strong>web服务器。<br>优点：小巧，灵活，可扩展，稳定<br>缺点：软件开源，漏洞易被发现</li><li>Nginx<br>是<strong>Linux</strong>平台下优秀的web服务器.不仅是HTTP服务器而且也是负载均衡的反向代理。<br>优点：压缩率高，支持负载均衡，<strong>速度快</strong></li><li>IIS<br>IIS是微软平台的web服务器，是针对windows平台的服务器。和NET非常搭配<br>优点：安装配置简单，学起来容易<br>缺点：平台适用性单一，安全性有待提高</li><li>Tomcat<br>免费，深受java开发者喜爱。<br>优点：简单易掌握，部署容易，应用广泛<br>缺点：扩展性不强，可配置性弱，大并发能力不强</li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>语法_python3记录</title>
      <link href="/2018/08/09/python%E8%AF%AD%E6%B3%95/"/>
      <url>/2018/08/09/python%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h4 id="矩阵乘法"><a href="#矩阵乘法" class="headerlink" title="矩阵乘法"></a>矩阵乘法</h4><p>分为两种方式</p><p>1.np.dot(A,B)</p><ul><li>对于多维矩阵，计算真正意义上的矩阵乘积(数学线性运算)</li><li>对于一维矩阵，计算内积</li></ul><p>2.np.multiply()或*</p><p>实现对应元素直接相乘，即mn和m<em>n相乘得到的还是m</em>n的矩阵</p><p><a href="https://www.cnblogs.com/hezhiyao/p/8177832.html" target="_blank" rel="noopener">https://www.cnblogs.com/hezhiyao/p/8177832.html</a></p><pre><code>import numpy as npxx =np.array([[-1, 0, 1],[-2, 0, 2]])yy =np.array([[-1, 0, 1],[-2, 0, 2]])rt=xx*yycount=sum(rt) #每列相加print(rt)print(count)print(sum(count))返回值[[1 0 1][4 0 4]][5 0 5]10</code></pre><h4 id="字符串判定"><a href="#字符串判定" class="headerlink" title="字符串判定"></a>字符串判定</h4><pre><code>isalnum()数字或字母isalpha()字母isdigit()数字isupper()大写istitle()首字母大写isspace()所有字母都是空白字符、\t、\n、\r</code></pre><h4 id="max函数"><a href="#max函数" class="headerlink" title="max函数"></a>max函数</h4><p>1)除了数值类型，字符串取字母表最靠后的字母</p><p>2）可以添加参数key，指定方法，入参即为比较的元素</p><pre><code>sample=[40,53,12,5,5,9,9]print(max(set(sample), key=sample.count))</code></pre><h4 id="yield和斐波那契数列"><a href="#yield和斐波那契数列" class="headerlink" title="yield和斐波那契数列"></a>yield和斐波那契数列</h4><p>比如爬楼梯和生兔子问题都是斐波那契数列问题。我的理解比如爬楼梯要么从下两层爬上来，要么就是从下1层爬上来，一共两种方式，肯定就是这两种方法的总和，兔子问题需要推出来符合斐波那契数列数列规律。</p><pre><code>def fab(max):a,b,n=0,1,0while(n&lt;max):    yield b    print(&quot;aaa&quot;)    a,b=b,a+b    n+=1f=fab(5)print(f.__next__())#1print(f.__next__())#aaa 1print(f.__next__())#aaa 2</code></pre><p> yield：返回值b；每次调用<strong>next</strong>()的时候执行到此关键字处。下次<strong>next</strong>()再继续执行yeild后面的语句。</p><p> 因为是迭代器，所以可以改成遍历获取：</p><pre><code>for i in fab(5):   print (i)</code></pre><p> 对于斐波那契数列还可以使用装饰器进行优化：</p><pre><code> def cache(fun):    fibdict = {}    print (&quot;cache begin..&quot;)    def wrapper(n):        if n in fibdict:            return fibdict[n]        fibdict[n]=fun(n)        return fibdict[n]    return wrapper@cachedef fib(n):    return 1 if n &lt;2 else fib(n-1)+fib(n-2)print(fib(7))</code></pre><h4 id="re-search和re-match"><a href="#re-search和re-match" class="headerlink" title="re.search和re.match"></a>re.search和re.match</h4><p>前者从整个字符串中寻找一个匹配，后者只匹配字符串的开始。</p><pre><code>import rea=&quot;worldhellodfddjhello&quot;print(re.match(&quot;hello&quot;,a).group())#Noneprint(re.search(&quot;hello&quot;,a).group())#hello</code></pre><h4 id="dict-fromkeys-seq-value"><a href="#dict-fromkeys-seq-value" class="headerlink" title="dict.fromkeys(seq,value)"></a>dict.fromkeys(seq,value)</h4><p>或{}.fromkeys(seq,value)</p><p>取序列元素作为key，value作为默认值(无value就是None)</p><p>【注意】：这个方法因为是创建字典，所以会自动去重</p><pre><code>a = [1,5,5,7]print(dict.fromkeys(a,&quot;defaultvalue&quot;))#输出{1: &apos;defaultvalue&apos;, 5: &apos;defaultvalue&apos;, 7: &apos;defaultvalue&apos;} list({}.fromkeys(plist).keys())</code></pre><h4 id="文件读取"><a href="#文件读取" class="headerlink" title="文件读取"></a>文件读取</h4><pre><code>read():读取整个文件，内容为字符串readline()：返回下一行，内容为字符串；readlines():返回list,保存有每行的数据。</code></pre><h4 id="下划线命名"><a href="#下划线命名" class="headerlink" title="下划线命名"></a>下划线命名</h4><p>python中主要存在四种命名方式：</p><p>1、object #无下划线：公用方法</p><p>2、_object #单下划线：半保护</p><pre><code>被看作是“protect”，意思是只有类对象和子类对象自己能访问到这些变量， 在模块或类外不可以使用，不能用’from module import *’导入。__object 是为了避免与子类的方法名称冲突， 对于该标识符描述的方法，父类的方法不能轻易地被子类的方法覆盖，他们的名字实际上是_classname__methodname。</code></pre><p>3、__object  #双下划线：全私有，全保护</p><pre><code>私有成员“private”，意思是只有类对象自己能访问，连子类对象也不能访问到这个数据，不能用’from module import *’导入。</code></pre><p>4、_ _ object_ _     #前后都有双下划线：内建方法，用户不要这样定义</p><h4 id="jsonpath模块"><a href="#jsonpath模块" class="headerlink" title="jsonpath模块"></a>jsonpath模块</h4><p>安装pip install jsonpath</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">from jsonpath import jsonpath</span><br><span class="line"></span><br><span class="line">testdict=&#123;</span><br><span class="line">    &quot;config&quot;: &#123;</span><br><span class="line">        &quot;host_huidu&quot;: &quot;10.39.34.70:8080&quot;,</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;name&quot;: &quot;hotel&quot;,</span><br><span class="line">    &quot;groups&quot;: &#123;</span><br><span class="line">        &quot;order&quot; : [</span><br><span class="line">            &quot;/hotel/getHomepageOrderList&quot;,</span><br><span class="line">            &quot;/myelong/getHotelOrder&quot;,</span><br><span class="line">            &quot;/myelong/getHotellist&quot;</span><br><span class="line">        ]        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">ret=jsonpath(testdict,&quot;$.name&quot;)</span><br><span class="line">ret=jsonpath(testdict,&quot;$.groups.order[1]&quot;)</span><br><span class="line">ret=jsonpath(testdict,&quot;$..order[1:3]&quot;)</span><br><span class="line">print(ret)</span><br></pre></td></tr></table></figure><h4 id="单例（Singleton）"><a href="#单例（Singleton）" class="headerlink" title="单例（Singleton）"></a>单例（Singleton）</h4><p>单例是一种设计模式，应用该模式的类只会生成一个实例</p><p>在 Python 中，我们可以用多种方法来实现单例模式：</p><ul><li><p>使用模块</p></li><li><p>使用 <strong>new</strong></p></li><li><p>使用装饰器（decorator）</p></li><li><p>使用元类（metaclass）</p></li></ul><p>重写new函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># 实例化一个单例</span><br><span class="line">class Singleton():</span><br><span class="line">    __instance = None</span><br><span class="line"> </span><br><span class="line">    def __new__(cls, age, name):</span><br><span class="line">        #如果类属性__instance的值为None，</span><br><span class="line">        #那么就创建一个对象，并且赋值为这个对象的引用，保证下次调用这个方法时</span><br><span class="line">        #能够知道之前已经创建过对象了，这样就保证了只有1个对象</span><br><span class="line">        if not cls.__instance:</span><br><span class="line">            cls.__instance = super().__new__(cls)</span><br><span class="line">        return cls.__instance</span><br><span class="line"> </span><br><span class="line">a = Singleton(18, &quot;dongGe&quot;)</span><br><span class="line">b = Singleton(8, &quot;dongGe&quot;)</span><br><span class="line"> </span><br><span class="line">print(id(a))</span><br><span class="line">print(id(b))</span><br></pre></td></tr></table></figure><p>【注】 区别:cls是类本身的一个对象,self是类实例的一个对象</p><p>参考：<a href="https://segmentfault.com/a/1190000008141049" target="_blank" rel="noopener">https://segmentfault.com/a/1190000008141049</a></p><h4 id="python-赋值-深拷贝-浅拷贝"><a href="#python-赋值-深拷贝-浅拷贝" class="headerlink" title="python 赋值 深拷贝    浅拷贝"></a>python 赋值 深拷贝    浅拷贝</h4><pre><code>浅拷贝：即引用，共用一个地址，互相受影响。  深拷贝：完全独立的地址，互相不受影响。  赋值：字典，列表等对象赋值相当于浅拷贝，而int,str,float,bool在值改变后新增了内存地址存放新值，与原来不共用一个地址，相当于深拷贝。  </code></pre><p>一般默认是浅拷贝，有速度快，占用内存小等特点</p><h4 id="yaml模块"><a href="#yaml模块" class="headerlink" title="yaml模块"></a>yaml模块</h4><ol><li>安装：pip install pyyaml  </li></ol><p>  *<em>语法 *</em>：  </p><ol><li><p>大小写敏感 </p></li><li><p>使用缩进表示层级关系</p></li><li><p>缩进时不允许使用Tab，只允许使用空格</p></li><li><p>缩进的空格数目不重要，只要相同层级的元素左对齐即可</p></li><li><p>‘#’表示注释，从它开始到行尾都被忽略</p><p>yaml模块常用的两个方法时yaml.load和yaml.dump</p><ol start="2"><li>yaml.load<br>返回一个对象dict</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import yaml</span><br><span class="line">f = open(r&apos;E:\AutomaticTest\Test_Framework\config\config.yml&apos;)</span><br><span class="line">y = yaml.load(f)</span><br><span class="line">print (y)</span><br></pre></td></tr></table></figure><ol start="3"><li><p>yaml.dump 将一个python对象生成为yaml文档,除此还有safe_dump等<br>若有中文，必须添加<strong>allow_unicode</strong>参数<br>第二个参数，是要写进的文件</p><p> dump(data, stream=None, Dumper=Dumper,<br>   default_style=None,<br>   default_flow_style=None,<br>   encoding=’utf-8’, # encoding=None (Python 3)<br>   explicit_start=None,<br>   explicit_end=None,<br>   version=None,<br>   tags=None,<br>   canonical=None,<br>   indent=None,<br>   width=None,<br>   allow_unicode=None,<br>   line_break=None)<br> dump_all(data, stream=None, Dumper=Dumper, …)  </p><p> safe_dump(data, stream=None, …)  </p><p> safe_dump_all(data, stream=None, …)  </p></li></ol></li></ol><p>举例：<br>      import yaml<br>      with open(‘abc.conf’,’w’)as f:<br>         yaml.dump(self.config, f, default_flow_style=False,<br>         indent=2, allow_unicode=True)<br>      <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">JSON转YAML</span><br></pre></td></tr></table></figure></p><pre><code>import json,yamlstr = &apos;{ &quot;foo&quot;: &quot;bar&quot; }&apos;data = json.loads(str)yml = yaml.safe_dump(data,allow_unicode=True)print(yml)</code></pre><p>  参考：<a href="http://www.361way.com/python-pyyaml-module/4271.html" target="_blank" rel="noopener">http://www.361way.com/python-pyyaml-module/4271.html</a><br>  参考：<a href="https://www.cnblogs.com/klb561/p/9326677.html" target="_blank" rel="noopener">https://www.cnblogs.com/klb561/p/9326677.html</a></p><h4 id="json模块"><a href="#json模块" class="headerlink" title="json模块"></a>json模块</h4><ol><li><p>json.dumps[卸载掉对象]   </p><p> 把一个Python对象编码转换成—&gt;json<strong>字符串</strong></p></li><li><p>json.loads[装上对象]    </p><p>   把json字符串解码转换成—&gt;python<strong>对象dict</strong></p><p>   其中 json 有下面三种样式：</p><p> 字典样式 ‘{“name”:”gzj”, “age”:”23”, “sex”:”man”}’<br> 列表样式 ‘[“gzj”, 23, “man”]’<br> 字典和列表相互嵌套的样式 “””[“gzj”, “{‘age’:’23’}”]”””<br> 特别注意 JSON 字符串中的内容用双引号，而非单引号。</p></li><li><p>json.dump和json.load均是针对文件的。<br>json.dump<br>我理解为两个动作，一个动作是将”obj“转换为JSON格式的字符串，还有一个动作是将字符串写入到文件中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">a = &#123;&quot;name&quot;:&quot;Tom&quot;, &quot;age&quot;:23&#125;</span><br><span class="line">with open(&quot;test.json&quot;, &quot;w&quot;, encoding=&apos;utf-8&apos;) as f:</span><br><span class="line">  ... # Parameter sort_keys    是否按照字母排序</span><br><span class="line">   ... # Parameter indent       缩进的空格数</span><br><span class="line">   ... # Parameter separators   分割符号形式</span><br><span class="line">     json.dump(a,f,indent=4) </span><br><span class="line">   # indent 超级好用，格式化保存字典，默认为None，小于0为零个空格</span><br><span class="line">   # f.write(json.dumps(a, indent=4))</span><br><span class="line">   # 和上面的效果一样！！！</span><br></pre></td></tr></table></figure><p>json.load<br>一个动作是将一个包含JSON格式数据从文件中取出来，还有一个动作是将其序列化为一个python对象dict</p><p><strong>当打开文件的时候，注意加上encoding否则会因为中文报错！</strong></p><p>import json<br>with open(“test.json”, “r”, encoding=’utf-8’) as f:<br>   aa = json.loads(f.read())<br>   f.seek(0)<br>   bb = json.load(f)    # 与 json.loads(f.read())</p></li></ol><h4 id="encode-和decode"><a href="#encode-和decode" class="headerlink" title="encode 和decode"></a>encode 和decode</h4><p>这里只说python3,不谈python2</p><pre><code>- 字符串通过编码转换为字节码，字节码通过解码转换为字符串   </code></pre><p>   str（unicode）—&gt;(encode)—&gt;bytes，bytes—&gt;(decode)—&gt;str </p><p>   python3默认编码是unicode编码，非utf8,需要经过encode才可能到utf8.</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">name=&quot;小明&quot;   #类型：&lt;class &apos;str&apos;&gt;</span><br><span class="line">name1=name.encode(&quot;utf-8&quot;)  #加密输出：b&apos;\xe5\xb0\x8f\xe6\x98\x8e&apos;</span><br><span class="line">name2=name1.decode(&quot;utf-8&quot;) #解密还原：&apos;小明&apos;</span><br></pre></td></tr></table></figure><p>   u’\u7b80’ 是unicode, ‘\xe7\xae\x80’是byte , byte和unicode之间一一对应, 可以相互转换, 转换规则如下:<br>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;b&apos;\xe7\xae\x80&apos;.decode(&apos;utf-8&apos;)   #字节转unicode（str）</span><br><span class="line">&apos;简&apos;</span><br><span class="line">&gt;&gt;&gt;u&apos;\u7b80&apos;.encode(&apos;utf-8&apos;)    #unicode转字节</span><br><span class="line">b&apos;\xe7\xae\x80&apos;</span><br></pre></td></tr></table></figure></p><p>   参考：<a href="https://www.jianshu.com/p/4ced2bbc9334" target="_blank" rel="noopener">https://www.jianshu.com/p/4ced2bbc9334</a><br>   <a href="https://blog.csdn.net/qq_29053519/article/details/79170519" target="_blank" rel="noopener">https://blog.csdn.net/qq_29053519/article/details/79170519</a></p><h4 id="装饰器和闭包"><a href="#装饰器和闭包" class="headerlink" title="装饰器和闭包"></a>装饰器和闭包</h4><p>  自定义装饰器，常用作打日志和运行时间</p><pre><code>import timedef logger(func):    #如果原函数有参数，那闭包函数必须保持参数个数一致    def mywrapper(x,y):#将函数外面包一层        print(x,y)#添加的额外功能,打印日志(1,2)        t1=time.time()        func(x,y)#原函数add(a,b)        t2=time.time()        cost=t2-t1#额外功能：计算时间        print(&quot;共计花费时间{}&quot;.format(cost))    return mywrapper@loggerdef add(a,b):    print(&quot;a+b={}&quot;.format(a+b))    time.sleep(1)add(1,2) #相当于logger(add)</code></pre><p>  装饰器属于闭包函数：什么是闭包函数？</p><h5 id="闭包函数"><a href="#闭包函数" class="headerlink" title="闭包函数"></a>闭包函数</h5><pre><code>1.函数内部定义的函数  2.包含对外部变量而非全局变量的引用，如：def outer():    x = 1    def inner():      print(&quot;x=%s&quot; %x)      print(&quot;inner func excuted&quot;)    inner()#也可以return  print(&quot;outer func excuted&quot;)outer()#####输出结果#########x=1inner func excutedouter func excuted</code></pre><p>   闭包函数,它必须包含自己的函数以及一个外部变量才能真正称得上是一个闭包函数。如果没有一个外部变量与其绑定,那么這个函数不能算得上是闭包函数.</p><p>   有了以上基础,对于装饰器就好理解了. </p><h5 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h5><p>   外部函数传入被装饰函数名，内部函数返回装饰函数名。</p><pre><code>  特点：       1.不修改被装饰函数的调用方式        2.不修改被装饰函数的源代码import timeimport randomdef timmer(func):    def wrapper():        start_time = time.time()        func()        stop_time=time.time()        print(&apos;run time is %s&apos; %(stop_time-start_time))    return wrapperdef auth(func):    def deco():        name=input(&apos;name: &apos;)        password=input(&apos;password: &apos;)        if name == &apos;egon&apos; and password == &apos;123&apos;:            print(&apos;login successful&apos;)            func() #wrapper()        else:            print(&apos;login err&apos;)    return deco@auth   # index = auth(timmer(index))                 @timmer # index = timmer(index)def index():  time.sleep(3)  print(&apos;welecome to index page&apos;)index()</code></pre><p>   如果有多个引用如上面的@auth,@timmer,顺序是从下至上。</p><p>   参考：<a href="https://www.cnblogs.com/huchong/p/7725564.html#_label1" target="_blank" rel="noopener">https://www.cnblogs.com/huchong/p/7725564.html#_label1</a></p><h4 id="格式化"><a href="#格式化" class="headerlink" title="格式化"></a>格式化</h4><pre><code>https://www.cnblogs.com/lvcm/p/8859225.html这篇文章总结的很好</code></pre><h4 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h4><p> python3常用的两个模块为：</p><ul><li>_thread</li><li>threading(推荐使用)</li></ul><p>线程中参数传递方法：</p><pre><code>1、仅使用元组传递初始化    threading.Thread(target=song,args=(1,2,3)).start()2、仅使用字典传递 threading.Thread(target=方法名, kwargs={&quot;参数名&quot;: 参数1, &quot;参数名&quot;: 参数2, ...})threading.Thread(target=song,kwargs={&quot;a&quot;:1,&quot;c&quot;:3,&quot;b&quot;:2}).start() #参数顺序可以变3、混合使用元组和字典 threading.Thread(target=方法名，args=（参数1, 参数2, ...）, kwargs={&quot;参数名&quot;: 参数1,&quot;参数名&quot;: 参数2, ...})threading.Thread(target=song,args=(1,),kwargs={&quot;c&quot;:3,&quot;b&quot;:2}).start()</code></pre><p>   主要参数：</p><pre><code>target表示调用对象 , 即子进程要执行的任务  args表示调用对象的位置参数,元组类型。  </code></pre><p>  方法介绍：    </p><pre><code>p.start() : 启动进程,并调用子进程中的p.run ()  p.is_alive () : 如果p仍然运行 , 返回True</code></pre><p>threading参考：<a href="https://www.jb51.net/article/161728.htm" target="_blank" rel="noopener">https://www.jb51.net/article/161728.htm</a></p><h4 id="处理小数"><a href="#处理小数" class="headerlink" title="处理小数"></a>处理小数</h4><p>参考：<a href="https://www.jb51.net/article/102248.htm" target="_blank" rel="noopener">https://www.jb51.net/article/102248.htm</a></p><ul><li><p>向下取整 int()</p></li><li><p>四舍五入 round()</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; round(3.25); round(4.85)</span><br><span class="line">3.0</span><br><span class="line">5.0</span><br></pre></td></tr></table></figure></li><li><p>向上取整 ceil()</p></li><li><p>分别取整数部分和小数部分</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import math</span><br><span class="line">&gt;&gt;&gt; math.modf(3.25)</span><br><span class="line">(0.25, 3.0)</span><br><span class="line">&gt;&gt;&gt; math.modf(4.2)</span><br><span class="line">(0.20000000000000018, 4.0)</span><br><span class="line">&gt;&gt;&gt;b = math.modf(123.34)#分开两部分</span><br><span class="line">&gt;&gt;&gt;print(b)                </span><br><span class="line">&gt;&gt;&gt;print(&apos;%.2f&apos; % b[0]) #保留两位小数0.34</span><br></pre></td></tr></table></figure></li></ul><h4 id="string模块"><a href="#string模块" class="headerlink" title="string模块"></a>string模块</h4><pre><code>import stringstring.ascii_lowercase  #打印所有的小写字母string.ascii_uppercase  #打印所有的大写字母string.ascii_letters #打印所有的大小写字母string.digits  #打印0-9的数字string.punctuation  #打印所有的特殊字符string.hexdigits #打印十六进制的字符string.printable  #打印所有的大小写，数字，特殊字符</code></pre><h4 id="hashlib模块"><a href="#hashlib模块" class="headerlink" title="hashlib模块"></a>hashlib模块</h4><pre><code>python的hashlib库的md5摘要是不可反解的，非常安全  hash.update(arg)  更新hash对象。连续的调用该方法相当于连续的追加更新。例如m.update(a); m.update(b)相当于m.update(a+b)。    hash.digest() 返回摘要，作为二进制数据字符串值,    hash.hexdigest() 返回摘要，作为十六进制数据字符串值,    hash.copy() 复制  </code></pre><p>示例：加盐</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">def my_md5(s:str,salt=None):</span><br><span class="line">s=str(s)</span><br><span class="line">if salt:</span><br><span class="line">  s=s+salt</span><br><span class="line">m=hashlib.md5(s.encode())</span><br><span class="line">return m.hexdigest()</span><br></pre></td></tr></table></figure><p> 或</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> import hashlib</span><br><span class="line">obj=hashlib.md5(b&apos;12334&apos;)                #实例化md5的时候可以给传个参数，这叫加盐</span><br><span class="line">obj.update(&quot;admin&quot;.encode(&quot;utf-8&quot;))      #是再加密的时候传入自己的一块字节，</span><br><span class="line">secret=obj.hexdigest()</span><br><span class="line">print(secret)</span><br></pre></td></tr></table></figure><h4 id="局部变量和全局变量"><a href="#局部变量和全局变量" class="headerlink" title="局部变量和全局变量"></a>局部变量和全局变量</h4><h6 id="列表-字典-集合-类-—-局部变量可以改全局变量，除了整数和字符串"><a href="#列表-字典-集合-类-—-局部变量可以改全局变量，除了整数和字符串" class="headerlink" title="列表 字典 集合 类 —-局部变量可以改全局变量，除了整数和字符串"></a>列表 字典 集合 类 —-局部变量可以改全局变量，除了整数和字符串</h6>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">d = &#123;&#125;</span><br><span class="line">def test():</span><br><span class="line">    d[&apos;url&apos;]=&apos;https://www.cnblogs.com/uncleyong/p/10530261.html&apos;</span><br><span class="line">def test2():</span><br><span class="line">    d[&apos;url&apos;]=&apos;https://www.cnblogs.com/uncleyong/&apos;</span><br><span class="line">test()</span><br><span class="line">test2()</span><br><span class="line">print(d)</span><br><span class="line">#&#123;&apos;url&apos;: &apos;https://www.cnblogs.com/uncleyong/&apos;&#125;</span><br></pre></td></tr></table></figure><p>但是如果重新创建则不是一回事</p>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">info =&#123;&apos;age&apos;:18,  &apos;url&apos;:&apos;https://www.cnblogs.com/uncleyong/p/10530261.html&apos;&#125;</span><br><span class="line">def test():</span><br><span class="line">    #重新创建了一个区别全局info的变量（地址变了，可用id函数验证）</span><br><span class="line">    info=&#123;&#125;</span><br><span class="line">    info[&apos;name&apos;] = &apos;qzcsbj&apos;</span><br><span class="line">test()</span><br><span class="line">print(info)</span><br><span class="line">#&#123;&apos;age&apos;: 18, &apos;url&apos;: &apos;https://www.cnblogs.com/uncleyong/p/10530261.html&apos;&#125;</span><br></pre></td></tr></table></figure><h6 id="global"><a href="#global" class="headerlink" title="global"></a>global</h6><p>  global需要在局部变量定义之前声明，否则报错</p><pre><code>res = Nonedef calc(a,b):    res = 0    global res    res = a+bcalc(1,2)print(res)#报错:SyntaxError: name &apos;res&apos; is assigned to before global declaration</code></pre><p>　　</p><h4 id="random模块"><a href="#random模块" class="headerlink" title="random模块"></a>random模块</h4><p> random中的一些重要函数的用法：</p><pre><code>random.random()函数是这个模块中最常用的方法了，它会生成一个随机的浮点数，范围是在0.0~1.0之间。random.uniform()正好弥补了上面函数的不足，它可以设定浮点数的范围，一个是上限，一个是下限。random.randint()随机生一个整数int类型，可以指定这个整数的范围，同样有上限和下限值，如random.randint（0，4）包括0和4中的随机整数。random.choice()可以从任何序列，比如list列表中，选取一个随机的元素返回，可以用于字符串、列表、元组等。random.sample()可以从指定的序列中，随机的截取指定长度的片断，不作原地修改。</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Django问题记录</title>
      <link href="/2018/08/08/Django%E9%A1%B9%E7%9B%AE%E5%AE%9E%E8%B7%B5%E4%B8%80/"/>
      <url>/2018/08/08/Django%E9%A1%B9%E7%9B%AE%E5%AE%9E%E8%B7%B5%E4%B8%80/</url>
      
        <content type="html"><![CDATA[<h4 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h4><p>本机之前一直装的是2.7，但是现在3.x已然成为趋势，准备更新3.7</p><p>   windows:</p><p>  下载python最新版本逐步进行安装（一定要选中pip）<br>     安装requests，直接pip install requests即可。<br>    Python 下载地址：<a href="https://www.python.org/downloads/" target="_blank" rel="noopener">https://www.python.org/downloads/</a></p><p>  Linux(centos 6.4):<br> 参考： <a href="https://www.cnblogs.com/dukuan/p/8252019.html" target="_blank" rel="noopener">https://www.cnblogs.com/dukuan/p/8252019.html</a><br>    wget <a href="https://www.python.org/ftp/python/3.4.4/Python-3.4.4.tgz" target="_blank" rel="noopener">https://www.python.org/ftp/python/3.4.4/Python-3.4.4.tgz</a></p><pre><code>lstar xf Python-3.4.4.tgz mkdir /usr/local/python3cd Python-3.4.4ls./configure --prefix=/usr/local/python3make allmake install</code></pre><ul><li><p>下载Django，并安装<br>Django 下载地址：<a href="https://www.djangoproject.com/download/" target="_blank" rel="noopener">https://www.djangoproject.com/download/</a><br>解压缩后安装：<br>   D:\下载\Django-2.1.7\Django-2.1.7&gt;python setup.py install<br>   将这几个目录添加到系统环境变量中如： C:\Python33\Lib\site-packages\django;C:\Python33\Scripts。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import django    #检查</span><br><span class="line">&gt;&gt;&gt; django.get_version()</span><br></pre></td></tr></table></figure></li><li><p>下载 安装pycharm专业版<br> 打开 <a href="http://idea.lanyus.com/" target="_blank" rel="noopener">http://idea.lanyus.com/</a></p><h4 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h4></li><li><p>创建项目，使用自己机器上的python编译器。添加app名称，IDE会默认创建app相关文件和配置。<br><img src="https://img-blog.csdnimg.cn/2019022014425410.png" alt="在这里插入图片描述"></p></li><li><p>启动服务<br>在开发阶段，为了能够快速预览到开发的效果，django提供了一个纯python编写的轻量级web服务器，仅在开发阶段使用<br>可以在Terminal运行如下命令启动服务器：<br>python manage.py runserver（默认127.0.0.1:8000 也可以使用0.0.0.0:8888这样可以再其他机器访问此端口的这个服务）<br><img src="https://img-blog.csdnimg.cn/20190220145321590.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N1cGVyX2NoZW5seQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>如果增加、修改、删除python文件，服务器会自动重启<br>如果想关闭服务器可以使用ctrl+c或点击run窗口的红色方块按钮<br>当然可以直接在目录上启动服务，以上是为了方便开发使用。</p></li></ul><ul><li>提交表单 MultiValueDictKeyError<br><img src="https://img-blog.csdnimg.cn/20190220182153159.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N1cGVyX2NoZW5seQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述">原因：<br>找了好久原因，不是语法的错误，而是逻辑错误。不应该在matrix.html页面传参，matrix是接收参数跳转的页面。解决方法就是新起了一个search.html的页面，进行传参。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">def getSchedule(request):</span><br><span class="line">    context=&#123;&#125;</span><br><span class="line">    pid=request.GET[&apos;pid&apos;]</span><br><span class="line">    sid=request.GET[&apos;sid&apos;]</span><br><span class="line">    context[&quot;list&quot;]=task(pid,sid)</span><br><span class="line">    return render(request,&quot;matrix.html&quot;,context)</span><br></pre></td></tr></table></figure><ul><li>使用openpyxl<br><a href="https://www.cnblogs.com/anpengapple/p/6399304.html" target="_blank" rel="noopener">https://www.cnblogs.com/anpengapple/p/6399304.html</a><br>eg:行添加,直接用sheet.append(rowlist)</li><li>AJAX的四种异步请求方式<br>简单理解jQuery中$.getJSON、$.get、$.post、$.ajax用法<br><a href="https://www.cnblogs.com/dongsh/p/3235487.html" target="_blank" rel="noopener">https://www.cnblogs.com/dongsh/p/3235487.html</a></li></ul><ul><li><p>模板前端与后台交互方法 $.getJSON</p><pre><code>$(document).ready(function () {    $(&quot;#dl&quot;).click(function () {        var sid=$(&quot;#sid&quot;).val();        var pid=$(&quot;#pid&quot;).val();    $.getJSON(&quot;/download/&quot;,{&apos;sid&apos;:sid,&apos;pid&apos;:pid},)    });    $(&quot;#submit&quot;).click(function () {        var sd=$(&quot;#sid&quot;).val();        var pd=$(&quot;#pid&quot;).val();        $.getJSON(&quot;/getSchedule/&quot;,{&apos;sd&apos;:sd,&apos;pd&apos;:pd},function (ret) {            $(&quot;#result&quot;).html(&quot;&quot;);           for(var i =0;i&lt;ret.length;i++){               $(&apos;#result&apos;).append(ret[i]).append(&quot;&lt;br&gt;&quot;)           }        })    });});</code></pre><ul><li>由于用 jQuery 实现 ajax 比较简单，所以我们用 jQuery库来实现</li><li>js调试  console.log</li><li>Django 后台返回<br>数组：return HttpResponse(json.dumps(a), content_type=’application/json’)<br>字典：return HttpResponse(json.dumps(name_dict), content_type=’application/json’)</li><li>url前面加/，指的是根目录。不加则指的是当前页面的子路径。<br><img src="https://img-blog.csdnimg.cn/20190222121737705.png" alt="在这里插入图片描述"></li><li>js清空标签内容：$(“#result”).html(“”)，而非$(“#result”).val(“”)<br>val是value的缩写  是给value属性赋值而已  并不是清空节点内的html元素<br>但是你如果html(‘2’)  就会变成<input type="text" value>2   虽然这个写法不对  但是这个意思</li></ul></li><li><p>python3.5中，import sqlite3 出现 no module named _sqlite3的解决方法<br>检查自己有没有安装sqlite-devel(rpm -qa |grep sqlite-devel) ，没有的话yum -y install sqlite-devel<br>然后进入到Python目录，（cd python目录）<br>然后命令行输入./configure，然后make和make  install<br>这个时候可以输入python，进入python环境后，import sqlite3，看还会不会报错。</p></li><li><p>ImportError: No module named openpyxl,xlrd<br>pip  install openpyxl</p></li><li><p>ImportError: No module named ‘requests’<br>pip install requests</p></li><li><p>How to fix error: django.db.utils.NotSupportedError: URIs not supported<br>这个问题浪费了很长的时间解决，首先是尝试升级qlite的版本，但是升级后依旧不能解决，最后根据提示中的目录将base.py中的字段改后解决了。即参考文章中的第一个方法。摘自:<a href="https://blog.csdn.net/zhuangmezhuang/article/details/82776272" target="_blank" rel="noopener">https://blog.csdn.net/zhuangmezhuang/article/details/82776272</a></p></li><li><p>‘WSGIRequest’ object has no attribute ‘urlopen’</p></li><li><p>views返回几种方式<br> return render_to_response(“search.html”)<br> 属于shortcuts模块，常用需要2个参数，第一个是模板如hello.html，第二个是字典，其中字典key就是模板中的变量。<br> return HttpResponse(“success!”)<br> 常用于直接返回字符串</p></li><li><p>静态文件的使用<br>settings.py 中两处注意：</p><ol><li>setting文件  </li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">-INSTALLED_APPS中 注册了‘django.contrib.staticfiles’，默认生成的文件已注册。 </span><br><span class="line">-指定STATIC_URL 与 STATICFILES_DIRS 的值.</span><br><span class="line"></span><br><span class="line">INSTALLED_APPS=[</span><br><span class="line">    &apos;...&apos;,</span><br><span class="line">    &apos;django.contrib.staticfiles&apos;,</span><br><span class="line">    &apos;...&apos;,</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">STATIC_URL=&apos;/static/&apos;</span><br><span class="line">STATICFILES_DIRS=(BASE_DIR,&apos;static&apos;)</span><br></pre></td></tr></table></figure></li></ul><p>  2.html文件中引用静态文件（常加在link前）：</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;% load staticfiles %&#125;</span><br><span class="line">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;&#123;% static &apos;css/main.css&apos; %&#125;&quot; /&gt;</span><br><span class="line">...</span><br><span class="line">&#123;% static &apos;/image/test.png&apos; %&#125;</span><br></pre></td></tr></table></figure><ul><li><p>打开text文件乱码且每次打开的时候会多出一行？</p><p>本地的ct.txt文件保存格式未必是utf-8，所以需要指定编码格式才更准确，使用newline防止在每次写入默认新添加一空行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">file=open(&quot;templates/ct.txt&quot;,&quot;w&quot;,encoding=&quot;utf-8&quot;, newline=&apos;&apos;)</span><br></pre></td></tr></table></figure></li><li><p>表单提交后不调view接口？<br>表单submit按钮类型写错，应该是submit类型，非button类型。</p></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>搭建博客(blog)踩得最主要的坑</title>
      <link href="/2018/06/07/my-first-blog/"/>
      <url>/2018/06/07/my-first-blog/</url>
      
        <content type="html"><![CDATA[<p>使用过程中博客报错：Unhandled rejection Template render error: (unknown path) [Line 9, Column 39]</p><p>一篇博客中带有大括号的符号导致，以后避免使用或者放在代码框中。</p><p><img src="/images/pasted-60.png" alt="upload successful"></p><h5 id="——以下是搭建过程和问题-——"><a href="#——以下是搭建过程和问题-——" class="headerlink" title="——以下是搭建过程和问题 ——-"></a>——以下是搭建过程和问题 ——-</h5><p>参考博客：<a href="https://samxrtq.github.io/2019/05/16/%E5%BB%BA%E7%AB%8BHEXO-github%E5%8D%9A%E5%AE%A2/" target="_blank" rel="noopener">https://samxrtq.github.io/2019/05/16/%E5%BB%BA%E7%AB%8BHEXO-github%E5%8D%9A%E5%AE%A2/</a></p><ul><li>问题1：<br>hexo fs.SyncWriteStream is deprecated</li></ul><p>查看各种博客，还让再安装一系列的包，最后一步步入坑，比如这种</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-fs --save</span><br><span class="line">npm install hexo-deployer-git@0.3.1 --save</span><br><span class="line">npm install hexo-renderer-ejs@0.3.1 --save</span><br><span class="line">npm install hexo-server@0.2.2 --save</span><br><span class="line"></span><br><span class="line">npm audit fix</span><br></pre></td></tr></table></figure><p>回头来看，其实是思路除了问题，最终从头抓起，应该找到问题源头才行。最后查到了一篇对路解决方案<br><a href="https://blog.csdn.net/qq_31975963/article/details/82882465" target="_blank" rel="noopener">https://blog.csdn.net/qq_31975963/article/details/82882465</a></p><p>在hexo项目中其中有一个hexo-fs的插件调用了这个方法，所以需要更新hexo-fs插件，更新方法如下：</p><p>npm install hexo-fs –save</p><p>更新插件后问题依然无法解决。</p><p>通过–debug来查看在哪里出了问题：</p><p>通过–debug来查看：</p><p>[root@server init]# <font color="red"> hexo –debug</font><br>06:55:32.711 DEBUG Hexo version: 3.5.0<br>06:55:32.714 DEBUG Working directory: /data/wwwroot/init/<br>06:55:32.787 DEBUG Config loaded: /data/wwwroot/init/_config.yml<br>06:55:32.832 DEBUG Plugin loaded: hexo-admin<br>(node:25414) [DEP0061] DeprecationWarning: fs.SyncWriteStream is deprecated.</p><p>问题出在：hexo-admin的hexo-fs<br>因hexo-admin作为后台管理，无法npm uninstall hexo-admin卸载,则找到对应文件，注释：</p><p>打开文件<br>./node_modules/hexo-admin/node_modules/hexo-fs/lib/fs.js</p><p>找到 718行:exports.SyncWriteStream = fs.SyncWriteStream;<br>将对应的exports.SyncWriteStream = fs.SyncWriteStream;注释(前面 //)即可！</p><hr><p>在windows上同步搭建<br>参考：<a href="https://samxrtq.github.io/2019/05/17/Windows%E4%B8%8Emac%E5%8F%8C%E7%AB%AF%E7%94%A8hexo%E5%86%99%E5%8D%9A%E5%AE%A2/" target="_blank" rel="noopener">https://samxrtq.github.io/2019/05/17/Windows%E4%B8%8Emac%E5%8F%8C%E7%AB%AF%E7%94%A8hexo%E5%86%99%E5%8D%9A%E5%AE%A2/</a></p><p>问题：<br>1、如何在本机创建多个key</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#第一步 创建别名key</span><br><span class="line">ssh-keygen -t rsa -f ~/.ssh/id_rsa.github -C &quot;entere@126.com&quot; </span><br><span class="line">#第二步创建config文件</span><br><span class="line">touch ~/.ssh/config</span><br><span class="line">chmod 600 ~/.ssh/config#根据需要进行这一步（win上没用这一步）</span><br><span class="line">#第三步 编辑config文件，将私钥地址附上去</span><br><span class="line">Host github.com</span><br><span class="line">    IdentityFile ~/.ssh/id_rsa.github</span><br></pre></td></tr></table></figure><p>2、hexo d -g的时候提示git不是内部命令<br>解决：检查环境变量，后来发现环境变量的目录git执行文件名字是git_cmd.exe,于是将其改名为git.exe.</p><p><img src="%5Cimages%5Cpasted-29.png" alt="upload successful"><br>3、上个问题解决后随即提示add不是内部或外部命令<br>解决：换成bash命令，脱离cmd</p><p><img src="%5Cimages%5Cpasted-30.png" alt="upload successful"><br>4、错误：git地址提交混乱，其中gitpagesource应该放源码，不该提到原来的git库里，后来重新按照步骤来了一遍好了。<br>5、不该更改_config.yml里原来的配置。<br>6、图片上传后不展示？<br>找大牛解决，替换了marked.js文件<br>7、mac和win不同步？<br>大牛给贴心画出原理图后秒懂，原因是源码没有在git仓库上同步<br><img src="%5Cimages%5Cpasted-33.png" alt="upload successful"></p><p>1.git pull    #将源码从gitpagesource仓库更新<br>2.hexo s后，用admin写博客<br>3.hexo d -g   #将博客推送到chenliyuan.github.io  （hexo d会清空chenliyuan.github.io这个仓库，然后将发布后的html们放上去，chenliyuan.github.io这个仓库就是网址要显示的内容）<br>4.git add.  commit  push  #这一步是为了把源代码上传到GitpageSource仓库，以防你下一个设备用的时候，源代码不同步<br>5.以.md文件存储的，程序会将这些.md文件，给转换为html;你的主题设置，hexo设置，你的网站颜色设置，等等++++你写的博客源码(.md文件)+++图片.然后你hexo g的时候，hexo就会将这些源码进行编译，发布到public文件夹下，那里就是发布后的    其实是一个网站</p>]]></content>
      
      
      
        <tags>
            
            <tag> blog </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
